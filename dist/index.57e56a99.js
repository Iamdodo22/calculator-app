function e(e){return e&&e.__esModule?e.default:e}var t=globalThis,r={},n={},i=t.parcelRequire94c2;null==i&&((i=function(e){if(e in r)return r[e].exports;if(e in n){var t=n[e];delete n[e];var i={id:e,exports:{}};return r[e]=i,t.call(i.exports,i,i.exports),i.exports}var a=Error("Cannot find module '"+e+"'");throw a.code="MODULE_NOT_FOUND",a}).register=function(e,t){n[e]=t},t.parcelRequire94c2=i);var a=i.register;a("cmoHh",function(e,t){!// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -
// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
function(e,t,r){function n(e){var t,r=this,n=(t=4022871197,function(e){e=String(e);for(var r=0;r<e.length;r++){var n=.02519603282416938*(t+=e.charCodeAt(r));t=n>>>0,n-=t,n*=t,t=n>>>0,n-=t,t+=4294967296*n}return(t>>>0)*23283064365386963e-26;// 2^-32
});r.next=function(){var e=2091639*r.s0+23283064365386963e-26*r.c;// 2^-32
return r.s0=r.s1,r.s1=r.s2,r.s2=e-(r.c=0|e)},// Apply the seeding algorithm from Baagoe.
r.c=1,r.s0=n(" "),r.s1=n(" "),r.s2=n(" "),r.s0-=n(e),r.s0<0&&(r.s0+=1),r.s1-=n(e),r.s1<0&&(r.s1+=1),r.s2-=n(e),r.s2<0&&(r.s2+=1)}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function a(e,t){var r=new n(e),a=t&&t.state,o=r.next;return o.int32=function(){return 4294967296*r.next()|0},o.double=function(){return o()+(2097152*o()|0)*11102230246251565e-32;// 2^-53
},o.quick=o,a&&("object"==typeof a&&i(a,r),o.state=function(){return i(r,{})}),o}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.alea=a}(0,e,"function"==typeof define&&define// present with an AMD loader
)}),a("euRi5",function(e,t){!// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper
function(e,t,r){function n(e){var t=this,r="";t.x=0,t.y=0,t.z=0,t.w=0,// Set up generator function.
t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:r+=e;// Mix in string seed, then discard an initial batch of 64 values.
for(var n=0;n<r.length+64;n++)t.x^=0|r.charCodeAt(n),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function a(e,t){var r=new n(e),a=t&&t.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do var e=r.next()>>>11,t=(r.next()>>>0)/4294967296,n=(e+t)/2097152;while(0===n)return n},o.int32=r.next,o.quick=o,a&&("object"==typeof a&&i(a,r),o.state=function(){return i(r,{})}),o}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.xor128=a}(0,e,"function"==typeof define&&define// present with an AMD loader
)}),a("hDsEw",function(e,t){!// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper
function(e,t,r){function n(e){var t=this,r="";// Set up generator function.
t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^(e^e<<1))|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:r+=e;// Mix in string seed, then discard an initial batch of 64 values.
for(var n=0;n<r.length+64;n++)t.x^=0|r.charCodeAt(n),n==r.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function a(e,t){var r=new n(e),a=t&&t.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do var e=r.next()>>>11,t=(r.next()>>>0)/4294967296,n=(e+t)/2097152;while(0===n)return n},o.int32=r.next,o.quick=o,a&&("object"==typeof a&&i(a,r),o.state=function(){return i(r,{})}),o}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.xorwow=a}(0,e,"function"==typeof define&&define// present with an AMD loader
)}),a("3J2Zm",function(e,t){!// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf
function(e,t,r){function n(e){var t=this;// Set up generator function.
t.next=function(){// Update xor generator.
var e,r,n=t.x,i=t.i;return e=n[i],e^=e>>>7,r=e^e<<24^((e=n[i+1&7])^e>>>10)^((e=n[i+3&7])^e>>>3)^((e=n[i+4&7])^e<<7),e=n[i+7&7],e^=e<<13,r^=e^e<<9,n[i]=r,t.i=i+1&7,r},function(e,t){var r,n=[];if(t===(0|t))n[0]=t;else for(r=0,// Seed state using a string.
t=""+t;r<t.length;++r)n[7&r]=n[7&r]<<15^t.charCodeAt(r)+n[r+1&7]<<13;// Enforce an array length of 8, not all zeroes.
for(;n.length<8;)n.push(0);for(r=0;r<8&&0===n[r];++r);// Discard an initial 256 values.
for(8==r?n[7]=-1:n[r],e.x=n,e.i=0,r=256;r>0;--r)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function a(e,t){null==e&&(e=+new Date);var r=new n(e),a=t&&t.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do var e=r.next()>>>11,t=(r.next()>>>0)/4294967296,n=(e+t)/2097152;while(0===n)return n},o.int32=r.next,o.quick=o,a&&(a.x&&i(a,r),o.state=function(){return i(r,{})}),o}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.xorshift7=a}(0,e,"function"==typeof define&&define// present with an AMD loader
)}),a("6Px8M",function(e,t){!// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().
function(e,t,r){function n(e){var t=this;// Set up generator function.
t.next=function(){var e,r,n=t.w,i=t.X,a=t.i;// Result is the combination.
return(// Update Weyl generator.
t.w=n=n+1640531527|0,// Update xor generator.
r=i[a+34&127],e=i[a=a+1&127],r^=r<<13,e^=e<<17,r^=r>>>15,e^=e>>>12,// Update Xor generator array state.
r=i[a]=r^e,t.i=a,r+(n^n>>>16)|0)},function(e,t){var r,n,i,a,o,s=[],u=128;// Initialize circular array and weyl value.
for(t===(0|t)?(// Numeric seeds initialize v, which is used to generates X.
n=t,t=null):(// String seeds are mixed into v and X one character at a time.
t+="\x00",n=0,u=Math.max(u,t.length)),i=0,a=-32;a<u;++a)t&&(n^=t.charCodeAt((a+32)%t.length)),0===a&&(o=n),n^=n<<10,n^=n>>>15,n^=n<<4,n^=n>>>13,a>=0&&(o=o+1640531527|0,i=0==(r=s[127&a]^=n+o)?i+1:0);for(i>=128&&(s[127&(t&&t.length||0)]=-1),// Run the generator 512 times to further mix the state before using it.
// Factoring this as a function slows the main generator, so it is just
// unrolled here.  The weyl generator is not advanced while warming up.
i=127,a=512;a>0;--a)n=s[i+34&127],r=s[i=i+1&127],n^=n<<13,r^=r<<17,n^=n>>>15,r^=r>>>12,s[i]=n^r;// Storing state as object members is faster than using closure variables.
e.w=o,e.X=s,e.i=i}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function a(e,t){null==e&&(e=+new Date);var r=new n(e),a=t&&t.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do var e=r.next()>>>11,t=(r.next()>>>0)/4294967296,n=(e+t)/2097152;while(0===n)return n},o.int32=r.next,o.quick=o,a&&(a.X&&i(a,r),o.state=function(){return i(r,{})}),o}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.xor4096=a}(0,e,"function"==typeof define&&define// present with an AMD loader
)}),a("lDm0S",function(e,t){!// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
function(e,t,r){function n(e){var t=this,r="";// Set up generator function.
t.next=function(){var e=t.b,r=t.c,n=t.d,i=t.a;return e=e<<25^e>>>7^r,r=r-n|0,n=n<<24^n>>>8^i,i=i-e|0,t.b=e=e<<20^e>>>12^r,t.c=r=r-n|0,t.d=n<<16^r>>>16^i,t.a=i-e|0},/* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(// Integer seed.
t.a=e/4294967296|0,t.b=0|e):r+=e;// Mix in string seed, then discard an initial batch of 64 values.
for(var n=0;n<r.length+20;n++)t.b^=0|r.charCodeAt(n),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function a(e,t){var r=new n(e),a=t&&t.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do var e=r.next()>>>11,t=(r.next()>>>0)/4294967296,n=(e+t)/2097152;while(0===n)return n},o.int32=r.next,o.quick=o,a&&("object"==typeof a&&i(a,r),o.state=function(){return i(r,{})}),o}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.tychei=a}(0,e,"function"==typeof define&&define// present with an AMD loader
)}),a("kjyEk",function(e,t){});var o={};function s(){return(o=s=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}).__esModule=!0,o.default=o,s.apply(this,arguments)}(o=s).__esModule=!0,o.default=o;var u={// minimum relative difference between two compared values,
// used by all comparison functions
epsilon:1e-12,// type of default matrix output. Choose 'matrix' (default) or 'array'
matrix:"Matrix",// type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
number:"number",// number of significant digits in BigNumbers
precision:64,// predictable output type of functions. When true, output type depends only
// on the input types. When false (default), output type can vary depending
// on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
// predictable is false, and returns `NaN` when true.
predictable:!1,// random seed for seeded pseudo random number generation
// null = randomly seed
randomSeed:null};// type checks for all known types
//
// note that:
//
// - check by duck-typing on a property like `isUnit`, instead of checking instanceof.
//   instanceof cannot be used because that would not allow to pass data from
//   one instance of math.js to another since each has it's own instance of Unit.
// - check the `isUnit` property via the constructor, so there will be no
//   matches for "fake" instances like plain objects with a property `isUnit`.
//   That is important for security reasons.
// - It must not be possible to override the type checks used internally,
//   for security reasons, so these functions are not exposed in the expression
//   parser.
function l(e){return"number"==typeof e}function c(e){return!!e&&"object"==typeof e&&"function"==typeof e.constructor&&(!0===e.isBigNumber&&"object"==typeof e.constructor.prototype&&!0===e.constructor.prototype.isBigNumber||"function"==typeof e.constructor.isDecimal&&!0===e.constructor.isDecimal(e))}function f(e){return e&&"object"==typeof e&&!0===Object.getPrototypeOf(e).isComplex||!1}function p(e){return e&&"object"==typeof e&&!0===Object.getPrototypeOf(e).isFraction||!1}function m(e){return e&&!0===e.constructor.prototype.isUnit||!1}function d(e){return"string"==typeof e}var h=Array.isArray;function g(e){return e&&!0===e.constructor.prototype.isMatrix||!1}function y(e){return Array.isArray(e)||g(e)}function v(e){return e&&e.isDenseMatrix&&!0===e.constructor.prototype.isMatrix||!1}function x(e){return e&&e.isSparseMatrix&&!0===e.constructor.prototype.isMatrix||!1}function b(e){return e&&!0===e.constructor.prototype.isRange||!1}function N(e){return e&&!0===e.constructor.prototype.isIndex||!1}function w(e){return"boolean"==typeof e}function D(e){return e&&!0===e.constructor.prototype.isResultSet||!1}function E(e){return e&&!0===e.constructor.prototype.isHelp||!1}function A(e){return"function"==typeof e}function S(e){return e instanceof Date}function C(e){return e instanceof RegExp}function M(e){return!!(e&&"object"==typeof e&&e.constructor===Object&&!f(e)&&!p(e))}function F(e){return null===e}function B(e){return void 0===e}function T(e){return e&&!0===e.isAccessorNode&&!0===e.constructor.prototype.isNode||!1}function O(e){return e&&!0===e.isArrayNode&&!0===e.constructor.prototype.isNode||!1}function _(e){return e&&!0===e.isAssignmentNode&&!0===e.constructor.prototype.isNode||!1}function z(e){return e&&!0===e.isBlockNode&&!0===e.constructor.prototype.isNode||!1}function q(e){return e&&!0===e.isConditionalNode&&!0===e.constructor.prototype.isNode||!1}function k(e){return e&&!0===e.isConstantNode&&!0===e.constructor.prototype.isNode||!1}function I(e){return k(e)||$(e)&&1===e.args.length&&k(e.args[0])&&"-+~".includes(e.op)}function R(e){return e&&!0===e.isFunctionAssignmentNode&&!0===e.constructor.prototype.isNode||!1}function P(e){return e&&!0===e.isFunctionNode&&!0===e.constructor.prototype.isNode||!1}function j(e){return e&&!0===e.isIndexNode&&!0===e.constructor.prototype.isNode||!1}function U(e){return e&&!0===e.isNode&&!0===e.constructor.prototype.isNode||!1}function L(e){return e&&!0===e.isObjectNode&&!0===e.constructor.prototype.isNode||!1}function $(e){return e&&!0===e.isOperatorNode&&!0===e.constructor.prototype.isNode||!1}function H(e){return e&&!0===e.isParenthesisNode&&!0===e.constructor.prototype.isNode||!1}function Z(e){return e&&!0===e.isRangeNode&&!0===e.constructor.prototype.isNode||!1}function G(e){return e&&!0===e.isRelationalNode&&!0===e.constructor.prototype.isNode||!1}function V(e){return e&&!0===e.isSymbolNode&&!0===e.constructor.prototype.isNode||!1}function W(e){return e&&!0===e.constructor.prototype.isChain||!1}function Y(e){var t=typeof e;return"object"===t?null===e?"null":c(e)?"BigNumber":e.constructor&&e.constructor.name?e.constructor.name:"Object":t}function J(e){var t=typeof e;// immutable primitive types
if("number"===t||"string"===t||"boolean"===t||null==e)return e;// use clone function of the object when available
if("function"==typeof e.clone)return e.clone();// array
if(Array.isArray(e))return e.map(function(e){return J(e)});if(e instanceof Date)return new Date(e.valueOf());if(c(e))return e;// bignumbers are immutable
// object
if(M(e))return function(e,t){var r={};for(var n in e)K(e,n)&&(r[n]=t(e[n]));return r}(e,J);throw TypeError("Cannot clone: unknown type of value (value: ".concat(e,")"))}function X(e,t){for(var r in t)K(t,r)&&(e[r]=t[r]);return e}function Q(e,t){var r,n,i;if(Array.isArray(e)){if(!Array.isArray(t)||e.length!==t.length)return!1;for(n=0,i=e.length;n<i;n++)if(!Q(e[n],t[n]))return!1;return!0}if("function"==typeof e||!(e instanceof Object))return e===t;if(Array.isArray(t)||!(t instanceof Object))return!1;for(r in e)// noinspection JSUnfilteredForInLoop
if(!(r in t)||!Q(e[r],t[r]))return!1;for(r in t)// noinspection JSUnfilteredForInLoop
if(!(r in e))return!1;return!0}function K(e,t){return e&&Object.hasOwnProperty.call(e,t)}var ee=/* #__PURE__ */function(e){if(e)throw Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");return Object.freeze(u)};/*@__PURE__*/e(o)(ee,u,{MATRIX_OPTIONS:["Matrix","Array"],NUMBER_OPTIONS:["number","BigNumber","Fraction"]});var et={},er={},en={};function ei(e){return(en=ei="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e}).__esModule=!0,en.default=en,ei(e)}(en=ei).__esModule=!0,en.default=en;var ea=en.default,eo={},es=en.default;/**
 * Get a property of a plain object
 * Throws an error in case the object is not a plain object or the
 * property is not defined on the object itself
 * @param {Object} object
 * @param {string} prop
 * @return {*} Returns the property value when safe
 */function eu(e,t){// only allow getting safe properties of a plain object
if(ep(e)&&ec(e,t))return e[t];if("function"==typeof e[t]&&ef(e,t))throw Error('Cannot access method "'+t+'" as a property');throw Error('No access to property "'+t+'"')}/**
 * Set a property on a plain object.
 * Throws an error in case the object is not a plain object or the
 * property would override an inherited property like .constructor or .toString
 * @param {Object} object
 * @param {string} prop
 * @param {*} value
 * @return {*} Returns the value
 */// TODO: merge this function into access.js?
function el(e,t,r){// only allow setting safe properties of a plain object
if(ep(e)&&ec(e,t))return e[t]=r,r;throw Error('No access to property "'+t+'"')}/**
 * Test whether a property is safe to use for an object.
 * For example .toString and .constructor are not safe
 * @param {string} prop
 * @return {boolean} Returns true when safe
 */function ec(e,t){return!!e&&"object"==typeof e&&(!!K(em,t)||!(t in Object.prototype)&&!(t in Function.prototype))}/**
 * Check whether a method is safe.
 * Throws an error when that's not the case (for example for `constructor`).
 * @param {Object} object
 * @param {string} method
 * @return {boolean} Returns true when safe, false otherwise
 */function ef(e,t){return!(null==e||"function"!=typeof e[t]||K(e,t)&&Object.getPrototypeOf&&t in Object.getPrototypeOf(e))&&(!!K(ed,t)||!(t in Object.prototype)&&!(t in Function.prototype))}function ep(e){return"object"==typeof e&&e&&e.constructor===Object}(eo=function(e,t){if("object"!==es(e)||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!==es(n))return n;throw TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}).__esModule=!0,eo.default=eo,(er=function(e){var t=eo(e,"string");return"symbol"===ea(t)?t:String(t)}).__esModule=!0,er.default=er,(et=function(e,t,r){return(t=er(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}).__esModule=!0,et.default=et;var em={length:!0,name:!0},ed={toString:!0,valueOf:!0,toLocaleString:!0};function eh(e){return"boolean"==typeof e||!!isFinite(e)&&e===Math.round(e)}var eg=/* #__PURE__ */Math.sign||function(e){return e>0?1:e<0?-1:0},ey=/* #__PURE__ */Math.log2||function(e){return Math.log(e)/Math.LN2},ev=/* #__PURE__ */Math.log10||function(e){return Math.log(e)/Math.LN10},ex=/* #__PURE__ */Math.log1p||function(e){return Math.log(e+1)},eb=/* #__PURE__ */Math.cbrt||function(e){if(0===e)return e;var t,r=e<0;return r&&(e=-e),isFinite(e)?(t=Math.exp(Math.log(e)/3),// from https://en.wikipedia.org/wiki/Cube_root#Numerical_methods
t=(e/(t*t)+2*t)/3):t=e,r?-t:t},eN=/* #__PURE__ */Math.expm1||function(e){return e>=2e-4||e<=-.0002?Math.exp(e)-1:e+e*e/2+e*e*e/6};/**
 * Formats a number in a given base
 * @param {number} n
 * @param {number} base
 * @param {number} size
 * @returns {string}
 */function ew(e,t,r){var n="";if(r){if(r<1)throw Error("size must be in greater than 0");if(!eh(r))throw Error("size must be an integer");if(e>2**(r-1)-1||e<-(2**(r-1)))throw Error("Value must be in range [-2^".concat(r-1,", 2^").concat(r-1,"-1]"));if(!eh(e))throw Error("Value must be an integer");e<0&&(e+=2**r),n="i".concat(r)}var i="";return e<0&&(e=-e,i="-"),"".concat(i).concat({2:"0b",8:"0o",16:"0x"}[t]).concat(e.toString(t)).concat(n)}function eD(e,t){if("function"==typeof t)return t(e);// handle special cases
if(e===1/0)return"Infinity";if(e===-1/0)return"-Infinity";if(isNaN(e))return"NaN";// default values for options
var r,n,i="auto";if(t&&(t.notation&&(i=t.notation),l(t)?r=t:l(t.precision)&&(r=t.precision),t.wordSize&&"number"!=typeof(n=t.wordSize)))throw Error('Option "wordSize" must be a number');// handle the various notations
switch(i){case"fixed":return eA(e,r);case"exponential":return eS(e,r);case"engineering":return function(e,t){if(isNaN(e)||!isFinite(e))return String(e);var r=eC(eE(e),t),n=r.exponent,i=r.coefficients,a=n%3==0?n:n<0?n-3-n%3:n-n%3;if(l(t))for(;t>i.length||n-a+1>i.length;)i.push(0);else for(var o=Math.abs(n-a)-(i.length-1),s=0;s<o;s++)i.push(0);// push decimal index over by expDiff times
for(// find difference in exponents
var u=Math.abs(n-a),c=1;u>0;)c++,u--;// if all coefficient values are zero after the decimal point and precision is unset, don't add a decimal value.
// otherwise concat with the rest of the coefficients
var f=i.slice(c).join(""),p=l(t)&&f.length||f.match(/[1-9]/)?"."+f:"",m=i.slice(0,c).join("")+p+"e"+(n>=0?"+":"")+a.toString();return r.sign+m}(e,r);case"bin":return ew(e,2,n);case"oct":return ew(e,8,n);case"hex":return ew(e,16,n);case"auto":// remove trailing zeros after the decimal point
return(function(e,t,r){if(isNaN(e)||!isFinite(e))return String(e);// determine lower and upper bound for exponential notation.
var n=r&&void 0!==r.lowerExp?r.lowerExp:-3,i=r&&void 0!==r.upperExp?r.upperExp:5,a=eE(e),o=t?eC(a,t):a;if(o.exponent<n||o.exponent>=i)return eS(e,t);var s=o.coefficients,u=o.exponent;s.length<t&&(s=s.concat(eM(t-s.length))),// append trailing zeros
// TODO: simplify the next statement
s=s.concat(eM(u-s.length+1+(s.length<t?t-s.length:0))),// prepend zeros
s=eM(-u).concat(s);var l=u>0?u:0;return l<s.length-1&&s.splice(l+1,0,"."),o.sign+s.join("")})(e,r,t&&t).replace(/((\.\d*?)(0+))($|e)/,function(){var e=arguments[2],t=arguments[4];return"."!==e?e+t:t});default:throw Error('Unknown notation "'+i+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function eE(e){// parse the input value
var t=String(e).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);if(!t)throw SyntaxError("Invalid number "+e);var r=t[1],n=t[2],i=parseFloat(t[4]||"0"),a=n.indexOf(".");i+=-1!==a?a-1:n.length-1;var o=n.replace(".","")// remove the dot (must be removed before removing leading zeros)
.replace(/^0*/,function(e){return(// remove leading zeros, add their count to the exponent
i-=e.length,"")}).replace(/0*$/,"")// remove trailing zeros
.split("").map(function(e){return parseInt(e)});return 0===o.length&&(o.push(0),i++),{sign:r,coefficients:o,exponent:i}}function eA(e,t){if(isNaN(e)||!isFinite(e))return String(e);var r=eE(e),n="number"==typeof t?eC(r,r.exponent+1+t):r,i=n.coefficients,a=n.exponent+1,o=a+(t||0);return i.length<o&&(i=i.concat(eM(o-i.length))),a<0&&(i=eM(-a+1).concat(i),a=1),a<i.length&&i.splice(a,0,0===a?"0.":"."),n.sign+i.join("")}function eS(e,t){if(isNaN(e)||!isFinite(e))return String(e);// round if needed, else create a clone
var r=eE(e),n=t?eC(r,t):r,i=n.coefficients,a=n.exponent;// append zeros if needed
i.length<t&&(i=i.concat(eM(t-i.length)));// format as `C.CCCe+EEE` or `C.CCCe-EEE`
var o=i.shift();return n.sign+o+(i.length>0?"."+i.join(""):"")+"e"+(a>=0?"+":"")+a}function eC(e,t){// prepend zeros if needed
for(// create a clone
var r={sign:e.sign,coefficients:e.coefficients,exponent:e.exponent},n=r.coefficients;t<=0;)n.unshift(0),r.exponent++,t++;if(n.length>t&&n.splice(t,n.length-t)[0]>=5){var i=t-1;for(n[i]++;10===n[i];)n.pop(),0===i&&(n.unshift(0),r.exponent++,i++),i--,n[i]++}return r}/**
 * Create an array filled with zeros.
 * @param {number} length
 * @return {Array}
 */function eM(e){for(var t=[],r=0;r<e;r++)t.push(0);return t}var eF=Number.EPSILON||2220446049250313e-31;function eB(e,t,r){// if epsilon is null or undefined, test whether x and y are exactly equal
if(null==r)return e===t;if(e===t)return!0;// NaN
if(isNaN(e)||isNaN(t))return!1;// at this point x and y should be finite
if(isFinite(e)&&isFinite(t)){// check numbers are very close, needed when comparing numbers near zero
var n=Math.abs(e-t);return n<=eF||n<=Math.max(Math.abs(e),Math.abs(t))*r}// Infinite and Number or negative Infinite and positive Infinite cases
return!1}var eT=Math.acosh||function(e){return Math.log(Math.sqrt(e*e-1)+e)},eO=Math.asinh||function(e){return Math.log(Math.sqrt(e*e+1)+e)},e_=Math.atanh||function(e){return Math.log((1+e)/(1-e))/2},ez=Math.cosh||function(e){return(Math.exp(e)+Math.exp(-e))/2},eq=Math.sinh||function(e){return(Math.exp(e)-Math.exp(-e))/2},ek=Math.tanh||function(e){var t=Math.exp(2*e);return(t-1)/(t+1)};/**
 * Formats a BigNumber in a given base
 * @param {BigNumber} n
 * @param {number} base
 * @param {number} size
 * @returns {string}
 */function eI(e,t,r){var n=new e.constructor(2),i="";if(r){if(r<1)throw Error("size must be in greater than 0");if(!eh(r))throw Error("size must be an integer");if(e.greaterThan(n.pow(r-1).sub(1))||e.lessThan(n.pow(r-1).mul(-1)))throw Error("Value must be in range [-2^".concat(r-1,", 2^").concat(r-1,"-1]"));if(!e.isInteger())throw Error("Value must be an integer");e.lessThan(0)&&(e=e.add(n.pow(r))),i="i".concat(r)}switch(t){case 2:return"".concat(e.toBinary()).concat(i);case 8:return"".concat(e.toOctal()).concat(i);case 16:return"".concat(e.toHexadecimal()).concat(i);default:throw Error("Base ".concat(t," not supported "))}}function eR(e,t){return void 0!==t?e.toExponential(t-1):e.toExponential()}function eP(e,t){var r=function(e,t){return"number"==typeof e?eD(e,t):c(e)?function(e,t){if("function"==typeof t)return t(e);// handle special cases
if(!e.isFinite())return e.isNaN()?"NaN":e.gt(0)?"Infinity":"-Infinity";// default values for options
var r="auto";if(void 0!==t&&(t.notation&&(r=t.notation),"number"==typeof t?u=t:void 0!==t.precision&&(u=t.precision),t.wordSize&&"number"!=typeof(l=t.wordSize)))throw Error('Option "wordSize" must be a number');// handle the various notations
switch(r){case"fixed":return n=u,e.toFixed(n);case"exponential":return eR(e,u);case"engineering":return i=u,o=(a=e.e)%3==0?a:a<0?a-3-a%3:a-a%3,-1!==(s=e.mul(Math.pow(10,-o)).toPrecision(i)).indexOf("e")&&(s=new e.constructor(s).toFixed()),s+"e"+(a>=0?"+":"")+o.toString();case"bin":return eI(e,2,l);case"oct":return eI(e,8,l);case"hex":return eI(e,16,l);case"auto":// determine lower and upper bound for exponential notation.
// TODO: implement support for upper and lower to be BigNumbers themselves
var n,i,a,o,s,u,l,c=t&&void 0!==t.lowerExp?t.lowerExp:-3,f=t&&void 0!==t.upperExp?t.upperExp:5;// handle special case zero
if(e.isZero())return"0";var p=e.toSignificantDigits(u),m=p.e;// remove trailing zeros after the decimal point
return(m>=c&&m<f?p.toFixed():eR(e,u)).replace(/((\.\d*?)(0+))($|e)/,function(){var e=arguments[2],t=arguments[4];return"."!==e?e+t:t});default:throw Error('Unknown notation "'+r+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}(e,t):// note: we use unsafe duck-typing here to check for Fractions, this is
// ok here since we're only invoking toString or concatenating its values
e&&"object"==typeof e&&"number"==typeof e.s&&"number"==typeof e.n&&"number"==typeof e.d?t&&"decimal"===t.fraction?e.toString():e.s*e.n+"/"+e.d:Array.isArray(e)?/**
 * Recursively format an n-dimensional matrix
 * Example output: "[[1, 2], [3, 4]]"
 * @param {Array} array
 * @param {Object | number | Function} [options]  Formatting options. See
 *                                                lib/utils/number:format for a
 *                                                description of the available
 *                                                options.
 * @returns {string} str
 */function e(t,r){if(!Array.isArray(t))return eP(t,r);for(var n="[",i=t.length,a=0;a<i;a++)0!==a&&(n+=", "),n+=e(t[a],r);return n+"]"}(e,t):d(e)?ej(e):"function"==typeof e?e.syntax?String(e.syntax):"function":e&&"object"==typeof e?"function"==typeof e.format?e.format(t):e&&e.toString(t)!==({}).toString()?e.toString(t):"{"+Object.keys(e).map(r=>ej(r)+": "+eP(e[r],t)).join(", ")+"}":String(e)}(e,t);return t&&"object"==typeof t&&"truncate"in t&&r.length>t.truncate?r.substring(0,t.truncate-3)+"...":r}function ej(e){for(var t=String(e),r="",n=0;n<t.length;){var i=t.charAt(n);r+=i in eU?eU[i]:i,n++}return'"'+r+'"'}var eU={'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","	":"\\t"};function eL(e){return String(e).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function e$(e,t){// we don't want to convert numbers to string, only accept string input
if(!d(e))throw TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: "+Y(e)+", index: 0)");if(!d(t))throw TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: "+Y(t)+", index: 1)");return e===t?0:e>t?1:-1}/**
 * Create a range error with the message:
 *     'Dimension mismatch (<actual size> != <expected size>)'
 * @param {number | number[]} actual        The actual size
 * @param {number | number[]} expected      The expected size
 * @param {string} [relation='!=']          Optional relation between actual
 *                                          and expected size: '!=', '<', etc.
 * @extends RangeError
 */function eH(e,t,r){if(!(this instanceof eH))throw SyntaxError("Constructor must be called with the new operator");this.actual=e,this.expected=t,this.relation=r,this.message="Dimension mismatch ("+(Array.isArray(e)?"["+e.join(", ")+"]":e)+" "+(this.relation||"!=")+" "+(Array.isArray(t)?"["+t.join(", ")+"]":t)+")",this.stack=Error().stack}/**
 * Create a range error with the message:
 *     'Index out of range (index < min)'
 *     'Index out of range (index < max)'
 *
 * @param {number} index     The actual index
 * @param {number} [min=0]   Minimum index (included)
 * @param {number} [max]     Maximum index (excluded)
 * @extends RangeError
 */function eZ(e,t,r){if(!(this instanceof eZ))throw SyntaxError("Constructor must be called with the new operator");this.index=e,arguments.length<3?(this.min=0,this.max=t):(this.min=t,this.max=r),void 0!==this.min&&this.index<this.min?this.message="Index out of range ("+this.index+" < "+this.min+")":void 0!==this.max&&this.index>=this.max?this.message="Index out of range ("+this.index+" > "+(this.max-1)+")":this.message="Index out of range ("+this.index+")",this.stack=Error().stack}function eG(e){for(var t=[];Array.isArray(e);)t.push(e.length),e=e[0];return t}function eV(e,t){if(0===t.length)// scalar
{if(Array.isArray(e))throw new eH(e.length,0)}else!/**
 * Recursively validate whether each element in a multi dimensional array
 * has a size corresponding to the provided size array.
 * @param {Array} array    Array to be validated
 * @param {number[]} size  Array with the size of each dimension
 * @param {number} dim   Current dimension
 * @throws DimensionError
 * @private
 */function e(t,r,n){var i,a=t.length;if(a!==r[n])throw new eH(a,r[n]);if(n<r.length-1){// recursively validate each child array
var o=n+1;for(i=0;i<a;i++){if(!Array.isArray(t[i]))throw new eH(r.length-1,r.length,"<");e(t[i],r,o)}}else for(i=0;i<a;i++)if(Array.isArray(t[i]))throw new eH(r.length+1,r.length,">")}(e,t,0)}function eW(e,t){var r=e.isMatrix?e._size:eG(e);// checks if the source size is not null and matches the valueSize
t._sourceSize.forEach((e,t)=>{if(null!==e&&e!==r[t])throw new eH(e,r[t])})}function eY(e,t){if(void 0!==e){if(!l(e)||!eh(e))throw TypeError("Index must be an integer (value: "+e+")");if(e<0||"number"==typeof t&&e>=t)throw new eZ(e,t)}}function eJ(e){for(var t=0;t<e._dimensions.length;++t){var r=e._dimensions[t];if(r._data&&h(r._data)){if(0===r._size[0])return!0}else if(r.isRange){if(r.start===r.end)return!0}else if(d(r)&&0===r.length)return!0}return!1}function eX(e,t,r){// check the type of the arguments
if(!Array.isArray(t))throw TypeError("Array expected");if(0===t.length)throw Error("Resizing to scalar is not supported");return(// check whether size contains positive integers
t.forEach(function(e){if(!l(e)||!eh(e)||e<0)throw TypeError("Invalid size, must contain positive integers (size: "+eP(t)+")")}),(l(e)||c(e))&&(e=[e]),/**
 * Recursively resize a multi dimensional array
 * @param {Array} array         Array to be resized
 * @param {number[]} size       Array with the size of each dimension
 * @param {number} dim          Current dimension
 * @param {*} [defaultValue]    Value to be filled in in new entries,
 *                              undefined by default.
 * @private
 */function e(t,r,n,i){var a,o,s=t.length,u=r[n],l=Math.min(s,u);if(// apply new length
t.length=u,n<r.length-1){// non-last dimension
var c=n+1;// resize existing child arrays
for(a=0;a<l;a++)Array.isArray(// resize child array
o=t[a])||(o=[o],t[a]=o),e(o,r,c,i);// create new child arrays
for(a=l;a<u;a++)// get child array
o=[],t[a]=o,// resize new child array
e(o,r,c,i)}else{// last dimension
// remove dimensions of existing values
for(a=0;a<l;a++)for(;Array.isArray(t[a]);)t[a]=t[a][0];// fill new elements with the default value
for(a=l;a<u;a++)t[a]=i}}(e,t,0,void 0!==r?r:0),e)}function eQ(e,t){var r=e3(e),n=r.length;if(!Array.isArray(e)||!Array.isArray(t))throw TypeError("Array expected");if(0===t.length)throw new eH(0,n,"!=");var i=e0(t=eK(t,n));if(n!==i)throw new eH(i,n,"!=");try{return(/**
 * Iteratively re-shape a multi dimensional array to fit the specified dimensions
 * @param {Array} array           Array to be reshaped
 * @param {number[]} sizes  List of sizes for each dimension
 * @returns {Array}               Array whose data has been formatted to fit the
 *                                specified dimensions
 */function(e,t){// for each dimensions starting by the last one and ignoring the first one
for(var r,n=e,i=t.length-1;i>0;i--){var a=t[i];r=[];for(var o=n.length/a,s=0;s<o;s++)r.push(n.slice(s*a,(s+1)*a));// set it as the new tmpArray for the next loop turn or for return
n=r}return n}(r,t))}catch(e){if(e instanceof eH)throw new eH(i,n,"!=");throw e}}function eK(e,t){var r=e0(e),n=e.slice(),i=e.indexOf(-1);if(e.indexOf(-1,i+1)>=0)throw Error("More than one wildcard in sizes");if(i>=0){if(t%r==0)n[i]=-t/r;else throw Error("Could not replace wildcard, since "+t+" is no multiple of "+-r)}return n}/**
 * Computes the product of all array elements.
 * @param {number[]} array Array of factors
 * @returns {number}            Product of all elements
 */function e0(e){return e.reduce((e,t)=>e*t,1)}function e1(e,t){// squeeze outer dimensions
for(var r=t||eG(e);Array.isArray(e)&&1===e.length;)e=e[0],r.shift();for(// find the first dimension to be squeezed
var n=r.length;1===r[n-1];)n--;return n<r.length&&(e=/**
 * Recursively squeeze a multi dimensional array
 * @param {Array} array
 * @param {number} dims Required number of dimensions
 * @param {number} dim  Current dimension
 * @returns {Array | *} Returns the squeezed array
 * @private
 */function e(t,r,n){var i,a;if(n<r){var o=n+1;for(i=0,a=t.length;i<a;i++)t[i]=e(t[i],r,o)}else for(;Array.isArray(t);)t=t[0];return t}(e,n,0),r.length=n),e}function e2(e,t,r,n){var i=n||eG(e);// unsqueeze outer dimensions
if(r)for(var a=0;a<r;a++)e=[e],i.unshift(1);for(// unsqueeze inner dimensions
e=/**
 * Recursively unsqueeze a multi dimensional array
 * @param {Array} array
 * @param {number} dims Required number of dimensions
 * @param {number} dim  Current dimension
 * @returns {Array | *} Returns the squeezed array
 * @private
 */function e(t,r,n){var i,a;if(Array.isArray(t)){var o=n+1;for(i=0,a=t.length;i<a;i++)t[i]=e(t[i],r,o)}else for(var s=n;s<r;s++)t=[t];return t}(e,t,0);i.length<t;)i.push(1);return e}function e3(e){if(!Array.isArray(e))return e;var t=[];return e.forEach(function e(r){Array.isArray(r)?r.forEach(e):t.push(r)}),t}function e4(e,t){return Array.prototype.map.call(e,t)}function e5(e,t){Array.prototype.forEach.call(e,t)}function e8(e,t){if(1!==eG(e).length)throw Error("Only one dimensional matrices supported");return Array.prototype.filter.call(e,t)}function e6(e,t){if(1!==eG(e).length)throw Error("Only one dimensional matrices supported");return Array.prototype.filter.call(e,e=>t.test(e))}function e7(e,t){return Array.prototype.join.call(e,t)}function e9(e){if(!Array.isArray(e))throw TypeError("Array input expected");if(0===e.length)return e;var t=[],r=0;t[0]={value:e[0],identifier:0};for(var n=1;n<e.length;n++)e[n]===e[n-1]?r++:r=0,t.push({value:e[n],identifier:r});return t}function te(e){if(!Array.isArray(e))throw TypeError("Array input expected");if(0===e.length)return e;for(var t=[],r=0;r<e.length;r++)t.push(e[r].value);return t}function tt(e,t){for(var r,n=0,i=0;i<e.length;i++){var a=e[i],o=Array.isArray(a);// If the current item is an array but the length does not equal the targetVectorSize
if(0===i&&o&&(n=a.length),o&&a.length!==n)return;var s=o?tt(a,t)// recurse into a nested array
:t(a);if(void 0===r)r=s;// first item
else if(r!==s)return"mixed"}return r}function tr(){var e=Array.prototype.slice.call(arguments,0,-1),t=Array.prototype.slice.call(arguments,-1);if(1===e.length)return e[0];if(e.length>1)return e.slice(1).reduce(function(e,r){return(/**
 * Recursively concatenate two matrices.
 * The contents of the matrices is not cloned.
 * @param {Array} a             Multi dimensional array
 * @param {Array} b             Multi dimensional array
 * @param {number} concatDim    The dimension on which to concatenate (zero-based)
 * @param {number} dim          The current dim (zero-based)
 * @return {Array} c            The concatenated matrix
 * @private
 */function e(t,r,n,i){if(!(i<n))return t.concat(r);// recurse into next dimension
if(t.length!==r.length)throw new eH(t.length,r.length);for(var a=[],o=0;o<t.length;o++)a[o]=e(t[o],r[o],n,i+1);return a}(e,r,t,0))},e[0]);throw Error("Wrong number of arguments in function concat")}function tn(e,t){for(var r=t.length,n=e.length,i=0;i<n;i++){var a=r-n+i;if(e[i]<t[a]&&e[i]>1||e[i]>t[a])throw Error("shape missmatch: missmatch is found in arg with shape (".concat(e,") not possible to broadcast dimension ").concat(n," with size ").concat(e[i]," to size ").concat(t[a]))}}function ti(t,r){var n,i,a,s=eG(t);if(Q(s,r))return t;tn(s,r);var u=function(){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];// check for every size
for(var n=t.map(e=>e.length),i=Math.max(...n),a=Array(i).fill(null),o=0;o<t.length;o++)for(var s=t[o],u=n[o],l=0;l<u;l++){var c=i-u+l;s[l]>a[c]&&(a[c]=s[l])}for(var f=0;f<t.length;f++)tn(t[f],a);return a}(s,r),l=u.length,c=[...Array(l-s.length).fill(1),...s],f=/*@__PURE__*/e(o)([],t);s.length<l&&(s=eG(f=eQ(f,c)));// stretches the array on each dimension to make it the same size as index
for(var p=0;p<l;p++)s[p]<u[p]&&(s=eG((n=f,i=u[p],a=p,f=tr(...Array(i).fill(n),a))));return f}function ta(e,t,r,n){function i(n){// we only pass the requested dependencies to the factory function
// to prevent functions to rely on dependencies that are not explicitly
// requested.
var i=function(e,t){for(var r={},n=0;n<t.length;n++){var i=t[n],a=e[i];void 0!==a&&(r[i]=a)}return r}(n,t.map(to));return function(e,t,r){if(!t.filter(e=>!(e&&"?"===e[0]))// filter optionals
.every(e=>void 0!==r[e])){var n=t.filter(e=>void 0===r[e]);// TODO: create a custom error class for this, a MathjsError or something like that
throw Error('Cannot create function "'.concat(e,'", ')+"some dependencies are missing: ".concat(n.map(e=>'"'.concat(e,'"')).join(", "),"."))}}(e,t,n),r(i)}return i.isFactory=!0,i.fn=e,i.dependencies=t.slice().sort(),n&&(i.meta=n),i}function to(e){return e&&"?"===e[0]?e.slice(1):e}function ts(e){return e&&e.isIndexError?new eZ(e.index+1,e.min+1,void 0!==e.max?e.max+1:void 0):e}function tu(e){var{subset:t}=e;/**
   * Retrieve part of an object:
   *
   * - Retrieve a property from an object
   * - Retrieve a part of a string
   * - Retrieve a matrix subset
   *
   * @param {Object | Array | Matrix | string} object
   * @param {Index} index
   * @return {Object | Array | Matrix | string} Returns the subset
   */return function(e,r){try{if(Array.isArray(e))return t(e,r);if(e&&"function"==typeof e.subset)return e.subset(r);if("string"==typeof e)return t(e,r);if("object"==typeof e){if(!r.isObjectProperty())throw TypeError("Cannot apply a numeric index as object property");return eu(e,r.getObjectProperty())}else throw TypeError("Cannot apply index: unsupported type of object")}catch(e){throw ts(e)}}}eH.prototype=RangeError(),eH.prototype.constructor=RangeError,eH.prototype.name="DimensionError",eH.prototype.isDimensionError=!0,eZ.prototype=RangeError(),eZ.prototype.constructor=RangeError,eZ.prototype.name="IndexError",eZ.prototype.isIndexError=!0;var tl="AccessorNode",tc=ta(tl,["subset","Node"],t=>{var{subset:r,Node:Node}=t,n=tu({subset:r});/**
   * Are parenthesis needed?
   * @private
   */function i(e){// TODO: maybe make a method on the nodes which tells whether they need parenthesis?
return!(T(e)||O(e)||k(e)||P(e)||L(e)||H(e)||V(e))}class a extends Node{/**
     * @constructor AccessorNode
     * @extends {Node}
     * Access an object property or get a matrix subset
     *
     * @param {Node} object                 The object from which to retrieve
     *                                      a property or subset.
     * @param {IndexNode} index             IndexNode containing ranges
     */constructor(e,t){if(super(),!U(e))throw TypeError('Node expected for parameter "object"');if(!j(t))throw TypeError('IndexNode expected for parameter "index"');this.object=e,this.index=t}// readonly property name
get name(){return this.index?this.index.isObjectProperty()?this.index.getObjectProperty():"":this.object.name||""}get type(){return tl}get isAccessorNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){var r=this.object._compile(e,t),i=this.index._compile(e,t);if(!this.index.isObjectProperty())return function(e,t,a){var o=r(e,t,a),s=i(e,t,o);return n(o,s)};var a=this.index.getObjectProperty();return function(e,t,n){// get a property from an object evaluated using the scope.
return eu(r(e,t,n),a)}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){e(this.object,"object",this),e(this.index,"index",this)}/**
     * Create a new AccessorNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AccessorNode} Returns a transformed copy of the node
     */map(e){return new a(this._ifNode(e(this.object,"object",this)),this._ifNode(e(this.index,"index",this)))}/**
     * Create a clone of this node, a shallow copy
     * @return {AccessorNode}
     */clone(){return new a(this.object,this.index)}/**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */_toString(e){var t=this.object.toString(e);return i(this.object)&&(t="("+t+")"),t+this.index.toString(e)}/**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */toHTML(e){var t=this.object.toHTML(e);return i(this.object)&&(t='<span class="math-parenthesis math-round-parenthesis">(</span>'+t+'<span class="math-parenthesis math-round-parenthesis">)</span>'),t+this.index.toHTML(e)}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */_toTex(e){var t=this.object.toTex(e);return i(this.object)&&(t="\\left(' + object + '\\right)"),t+this.index.toTex(e)}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:tl,object:this.object,index:this.index}}/**
     * Instantiate an AccessorNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "AccessorNode", object: ..., index: ...}`,
     *     where mathjs is optional
     * @returns {AccessorNode}
     */static fromJSON(e){return new a(e.object,e.index)}}return /*@__PURE__*/e(et)(a,"name",tl),a},{isClass:!0,isNode:!0}),tf="apply",tp=ta(tf,["typed","isInteger"],e=>{var{typed:t,isInteger:r}=e;/**
   * Apply a function that maps an array to a scalar
   * along a given axis of a matrix or array.
   * Returns a new matrix or array with one less dimension than the input.
   *
   * Syntax:
   *
   *     math.apply(A, dim, callback)
   *
   * Where:
   *
   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.
   *
   * Examples:
   *
   *    const A = [[1, 2], [3, 4]]
   *    const sum = math.sum
   *
   *    math.apply(A, 0, sum)             // returns [4, 6]
   *    math.apply(A, 1, sum)             // returns [3, 7]
   *
   * See also:
   *
   *    map, filter, forEach
   *
   * @param {Array | Matrix} array   The input Matrix
   * @param {number} dim             The dimension along which the callback is applied
   * @param {Function} callback      The callback function that is applied. This Function
   *                                 should take an array or 1-d matrix as an input and
   *                                 return a number.
   * @return {Array | Matrix} res    The residual matrix with the function applied over some dimension.
   */return t(tf,{"Array | Matrix, number | BigNumber, function":function(e,t,n){if(!r(t))throw TypeError("Integer number expected for dimension");var i=Array.isArray(e)?eG(e):e.size();if(t<0||t>=i.length)throw new eZ(t,i.length);return g(e)?e.create(tm(e.valueOf(),t,n)):tm(e,t,n)}})});/**
 * Recursively reduce a matrix
 * @param {Array} mat
 * @param {number} dim
 * @param {Function} callback
 * @returns {Array} ret
 * @private
 */function tm(e,t,r){var n,i,a;if(t<=0){if(!Array.isArray(e[0]))return r(e);for(n=0,a=/**
 * Transpose a matrix
 * @param {Array} mat
 * @returns {Array} ret
 * @private
 */function(e){var t,r,n=e.length,i=e[0].length,a=[];for(r=0;r<i;r++){var o=[];for(t=0;t<n;t++)o.push(e[t][r]);a.push(o)}return a}(e),i=[];n<a.length;n++)i[n]=tm(a[n],t-1,r);return i}for(n=0,i=[];n<e.length;n++)i[n]=tm(e[n],t-1,r);return i}var td=ta("apply",["typed","isInteger"],e=>{var{typed:t,isInteger:r}=e,n=tp({typed:t,isInteger:r});// @see: comment of concat itself
return t("apply",{"...any":function(e){// change dim from one-based to zero-based
var t=e[1];l(t)?e[1]=t-1:c(t)&&(e[1]=t.minus(1));try{return n.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0}),th="ArrayNode",tg=ta(th,["Node"],t=>{var{Node:Node}=t;class r extends Node{/**
     * @constructor ArrayNode
     * @extends {Node}
     * Holds an 1-dimensional array with items
     * @param {Node[]} [items]   1 dimensional array with items
     */constructor(e){// validate input
if(super(),this.items=e||[],!Array.isArray(this.items)||!this.items.every(U))throw TypeError("Array containing Nodes expected")}get type(){return th}get isArrayNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){var r=e4(this.items,function(r){return r._compile(e,t)});if(!("Array"!==e.config.matrix))return function(e,t,n){return e4(r,function(r){return r(e,t,n)})};var n=e.matrix;return function(e,t,i){return n(e4(r,function(r){return r(e,t,i)}))}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){for(var t=0;t<this.items.length;t++)e(this.items[t],"items["+t+"]",this)}/**
     * Create a new ArrayNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ArrayNode} Returns a transformed copy of the node
     */map(e){for(var t=[],n=0;n<this.items.length;n++)t[n]=this._ifNode(e(this.items[n],"items["+n+"]",this));return new r(t)}/**
     * Create a clone of this node, a shallow copy
     * @return {ArrayNode}
     */clone(){return new r(this.items.slice(0))}/**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */_toString(e){return"["+this.items.map(function(t){return t.toString(e)}).join(", ")+"]"}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:th,items:this.items}}/**
     * Instantiate an ArrayNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ArrayNode", items: [...]}`,
     *                       where mathjs is optional
     * @returns {ArrayNode}
     */static fromJSON(e){return new r(e.items)}/**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */toHTML(e){return'<span class="math-parenthesis math-square-parenthesis">[</span>'+this.items.map(function(t){return t.toHTML(e)}).join('<span class="math-separator">,</span>')+'<span class="math-parenthesis math-square-parenthesis">]</span>'}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */_toTex(e){return function t(r,n){var i=r.some(O)&&!r.every(O),a=n||i,o=r.map(function(r){return r.items?t(r.items,!n):r.toTex(e)}).join(a?"&":"\\\\");return i||!a||a&&!n?"\\begin{bmatrix}"+o+"\\end{bmatrix}":o}(this.items,!1)}}return /*@__PURE__*/e(et)(r,"name",th),r},{isClass:!0,isNode:!0}),ty=[{// assignment
AssignmentNode:{},FunctionAssignmentNode:{}},{// conditional expression
ConditionalNode:{latexLeftParens:!1,latexRightParens:!1,latexParens:!1}},{// logical or
"OperatorNode:or":{op:"or",associativity:"left",associativeWith:[]}},{// logical xor
"OperatorNode:xor":{op:"xor",associativity:"left",associativeWith:[]}},{// logical and
"OperatorNode:and":{op:"and",associativity:"left",associativeWith:[]}},{// bitwise or
"OperatorNode:bitOr":{op:"|",associativity:"left",associativeWith:[]}},{// bitwise xor
"OperatorNode:bitXor":{op:"^|",associativity:"left",associativeWith:[]}},{// bitwise and
"OperatorNode:bitAnd":{op:"&",associativity:"left",associativeWith:[]}},{// relational operators
"OperatorNode:equal":{op:"==",associativity:"left",associativeWith:[]},"OperatorNode:unequal":{op:"!=",associativity:"left",associativeWith:[]},"OperatorNode:smaller":{op:"<",associativity:"left",associativeWith:[]},"OperatorNode:larger":{op:">",associativity:"left",associativeWith:[]},"OperatorNode:smallerEq":{op:"<=",associativity:"left",associativeWith:[]},"OperatorNode:largerEq":{op:">=",associativity:"left",associativeWith:[]},RelationalNode:{associativity:"left",associativeWith:[]}},{// bitshift operators
"OperatorNode:leftShift":{op:"<<",associativity:"left",associativeWith:[]},"OperatorNode:rightArithShift":{op:">>",associativity:"left",associativeWith:[]},"OperatorNode:rightLogShift":{op:">>>",associativity:"left",associativeWith:[]}},{// unit conversion
"OperatorNode:to":{op:"to",associativity:"left",associativeWith:[]}},{// range
RangeNode:{}},{// addition, subtraction
"OperatorNode:add":{op:"+",associativity:"left",associativeWith:["OperatorNode:add","OperatorNode:subtract"]},"OperatorNode:subtract":{op:"-",associativity:"left",associativeWith:[]}},{// multiply, divide, modulus
"OperatorNode:multiply":{op:"*",associativity:"left",associativeWith:["OperatorNode:multiply","OperatorNode:divide","Operator:dotMultiply","Operator:dotDivide"]},"OperatorNode:divide":{op:"/",associativity:"left",associativeWith:[],latexLeftParens:!1,latexRightParens:!1,latexParens:!1},"OperatorNode:dotMultiply":{op:".*",associativity:"left",associativeWith:["OperatorNode:multiply","OperatorNode:divide","OperatorNode:dotMultiply","OperatorNode:doDivide"]},"OperatorNode:dotDivide":{op:"./",associativity:"left",associativeWith:[]},"OperatorNode:mod":{op:"mod",associativity:"left",associativeWith:[]}},{// Repeat multiplication for implicit multiplication
"OperatorNode:multiply":{associativity:"left",associativeWith:["OperatorNode:multiply","OperatorNode:divide","Operator:dotMultiply","Operator:dotDivide"]}},{// unary prefix operators
"OperatorNode:unaryPlus":{op:"+",associativity:"right"},"OperatorNode:unaryMinus":{op:"-",associativity:"right"},"OperatorNode:bitNot":{op:"~",associativity:"right"},"OperatorNode:not":{op:"not",associativity:"right"}},{// exponentiation
"OperatorNode:pow":{op:"^",associativity:"right",associativeWith:[],latexRightParens:!1},"OperatorNode:dotPow":{op:".^",associativity:"right",associativeWith:[]}},{// factorial
"OperatorNode:factorial":{op:"!",associativity:"left"}},{// matrix transpose
"OperatorNode:ctranspose":{op:"'",associativity:"left"}}];/**
 * Returns the first non-parenthesis internal node, but only
 * when the 'parenthesis' option is unset or auto.
 * @param {Node} _node
 * @param {string} parenthesis
 * @return {Node}
 */function tv(e,t){if(!t||"auto"!==t)return e;for(var r=e;H(r);)r=r.content;return r}function tx(e,t,r,n){var i=e;"keep"!==t&&(i=e.getContent());for(var a=i.getIdentifier(),o=null,s=0;s<ty.length;s++)if(a in ty[s]){o=s;break}// Bump up precedence of implicit multiplication, except when preceded
// by a "Rule 2" fraction ( [unaryOp]constant / constant )
if("OperatorNode:multiply"===a&&i.implicit&&"show"!==r){var u=tv(i.args[0],t);k(u)&&n&&"OperatorNode:divide"===n.getIdentifier()&&I(tv(n.args[0],t))||"OperatorNode:divide"===u.getIdentifier()&&I(tv(u.args[0],t))&&k(tv(u.args[1]))||(o+=1)}return o}function tb(e,t){var r=e;"keep"!==t&&(r=e.getContent());var n=r.getIdentifier(),i=tx(r,t);if(null===i)return null;var a=ty[i][n];if(K(a,"associativity")){if("left"===a.associativity)return"left";if("right"===a.associativity)return"right";// associativity is invalid
throw Error("'"+n+"' has the invalid associativity '"+a.associativity+"'.")}// associativity is undefined
return null}function tN(e,t,r){// ParenthesisNodes are only ignored when not in 'keep' mode
var n="keep"!==r?e.getContent():e,i="keep"!==r?e.getContent():t,a=n.getIdentifier(),o=i.getIdentifier(),s=tx(n,r);if(null===s)return null;var u=ty[s][a];if(K(u,"associativeWith")&&u.associativeWith instanceof Array){for(var l=0;l<u.associativeWith.length;l++)if(u.associativeWith[l]===o)return!0;return!1}// associativeWith is not defined
return null}var tw="AssignmentNode",tD=ta(tw,["subset","?matrix",// FIXME: should not be needed at all, should be handled by subset
"Node"],t=>{var{subset:r,matrix:n,Node:Node}=t,i=tu({subset:r}),a=function(e){var{subset:t,matrix:r}=e;/**
   * Replace part of an object:
   *
   * - Assign a property to an object
   * - Replace a part of a string
   * - Replace a matrix subset
   *
   * @param {Object | Array | Matrix | string} object
   * @param {Index} index
   * @param {*} value
   * @return {Object | Array | Matrix | string} Returns the original object
   *                                            except in case of a string
   */// TODO: change assign to return the value instead of the object
return function(e,n,i){try{if(Array.isArray(e))return(// shallow copy all (updated) items into the original array
r(e).subset(n,i).valueOf().forEach((t,r)=>{e[r]=t}),e);if(e&&"function"==typeof e.subset)return e.subset(n,i);if("string"==typeof e)return t(e,n,i);if("object"==typeof e){if(!n.isObjectProperty())throw TypeError("Cannot apply a numeric index as object property");return el(e,n.getObjectProperty(),i),e}else throw TypeError("Cannot apply index: unsupported type of object")}catch(e){throw ts(e)}}}({subset:r,matrix:n});/*
   * Is parenthesis needed?
   * @param {node} node
   * @param {string} [parenthesis='keep']
   * @param {string} implicit
   * @private
   */function o(e,t,r){t||(t="keep");var n=tx(e,t,r),i=tx(e.value,t,r);return"all"===t||null!==i&&i<=n}class s extends Node{/**
     * @constructor AssignmentNode
     * @extends {Node}
     *
     * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
     * replace a subset of a matrix like `A[2,2]=42`.
     *
     * Syntax:
     *
     *     new AssignmentNode(symbol, value)
     *     new AssignmentNode(object, index, value)
     *
     * Usage:
     *
     *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2))  // a=2
     *    new AssignmentNode(new SymbolNode('a'),
     *                       new IndexNode('b'),
     *                       new ConstantNode(2))   // a.b=2
     *    new AssignmentNode(new SymbolNode('a'),
     *                       new IndexNode(1, 2),
     *                       new ConstantNode(3))  // a[1,2]=3
     *
     * @param {SymbolNode | AccessorNode} object
     *     Object on which to assign a value
     * @param {IndexNode} [index=null]
     *     Index, property name or matrix index. Optional. If not provided
     *     and `object` is a SymbolNode, the property is assigned to the
     *     global scope.
     * @param {Node} value
     *     The value to be assigned
     */constructor(e,t,r){// validate input
if(super(),this.object=e,this.index=r?t:null,this.value=r||t,!V(e)&&!T(e))throw TypeError('SymbolNode or AccessorNode expected as "object"');if(V(e)&&"end"===e.name)throw Error('Cannot assign to symbol "end"');if(this.index&&!j(this.index))throw TypeError('IndexNode expected as "index"');if(!U(this.value))throw TypeError('Node expected as "value"')}// class name for typing purposes:
// readonly property name
get name(){return this.index?this.index.isObjectProperty()?this.index.getObjectProperty():"":this.object.name||""}get type(){return tw}get isAssignmentNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){var r=this.object._compile(e,t),n=this.index?this.index._compile(e,t):null,o=this.value._compile(e,t),s=this.object.name;if(this.index){if(this.index.isObjectProperty()){// apply an object property for example `a.b=2`
var u=this.index.getObjectProperty();return function(e,t,n){var i=r(e,t,n),a=o(e,t,n);return el(i,u,a),a}}if(V(this.object))return function(e,t,i){var u=r(e,t,i),l=o(e,t,i),c=n(e,t,u);return e.set(s,a(u,c,l)),l};// isAccessorNode(node.object) === true
// update a matrix subset, for example `a.b[2]=3`
// we will not use the compile function of the AccessorNode, but
// compile it ourselves here as we need the parent object of the
// AccessorNode:
// wee need to apply the updated object to parent object
var l=this.object.object._compile(e,t);if(this.object.index.isObjectProperty()){var c=this.object.index.getObjectProperty();return function(e,t,r){var i=l(e,t,r),s=eu(i,c),u=n(e,t,s),f=o(e,t,r);return el(i,c,a(s,u,f)),f}}// if some parameters use the 'end' parameter, we need to calculate
// the size
var f=this.object.index._compile(e,t);return function(e,t,r){var s=l(e,t,r),u=f(e,t,s),c=i(s,u),p=n(e,t,c),m=o(e,t,r);return a(s,u,a(c,p,m)),m}}// apply a variable to the scope, for example `a=2`
if(!V(this.object))throw TypeError("SymbolNode expected as object");return function(e,t,r){var n=o(e,t,r);return e.set(s,n),n}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){e(this.object,"object",this),this.index&&e(this.index,"index",this),e(this.value,"value",this)}/**
     * Create a new AssignmentNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AssignmentNode} Returns a transformed copy of the node
     */map(e){return new s(this._ifNode(e(this.object,"object",this)),this.index?this._ifNode(e(this.index,"index",this)):null,this._ifNode(e(this.value,"value",this)))}/**
     * Create a clone of this node, a shallow copy
     * @return {AssignmentNode}
     */clone(){return new s(this.object,this.index,this.value)}/**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */_toString(e){var t=this.object.toString(e),r=this.index?this.index.toString(e):"",n=this.value.toString(e);return o(this,e&&e.parenthesis,e&&e.implicit)&&(n="("+n+")"),t+r+" = "+n}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:tw,object:this.object,index:this.index,value:this.value}}/**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "AssignmentNode", object: ..., index: ..., value: ...}`,
     *     where mathjs is optional
     * @returns {AssignmentNode}
     */static fromJSON(e){return new s(e.object,e.index,e.value)}/**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */toHTML(e){var t=this.object.toHTML(e),r=this.index?this.index.toHTML(e):"",n=this.value.toHTML(e);return o(this,e&&e.parenthesis,e&&e.implicit)&&(n='<span class="math-paranthesis math-round-parenthesis">(</span>'+n+'<span class="math-paranthesis math-round-parenthesis">)</span>'),t+r+'<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>'+n}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */_toTex(e){var t=this.object.toTex(e),r=this.index?this.index.toTex(e):"",n=this.value.toTex(e);return o(this,e&&e.parenthesis,e&&e.implicit)&&(n="\\left(".concat(n,"\\right)")),t+r+"="+n}}return /*@__PURE__*/e(et)(s,"name",tw),s},{isClass:!0,isNode:!0}),tE="BlockNode",tA=ta(tE,["ResultSet","Node"],t=>{var{ResultSet:r,Node:Node}=t;class n extends Node{/**
     * @constructor BlockNode
     * @extends {Node}
     * Holds a set with blocks
     * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
     *            An array with blocks, where a block is constructed as an
     *            Object with properties block, which is a Node, and visible,
     *            which is a boolean. The property visible is optional and
     *            is true by default
     */constructor(e){// validate input, copy blocks
if(super(),!Array.isArray(e))throw Error("Array expected");this.blocks=e.map(function(e){var t=e&&e.node,r=!e||void 0===e.visible||e.visible;if(!U(t))throw TypeError('Property "node" must be a Node');if("boolean"!=typeof r)throw TypeError('Property "visible" must be a boolean');return{node:t,visible:r}})}get type(){return tE}get isBlockNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){var n=e4(this.blocks,function(r){return{evaluate:r.node._compile(e,t),visible:r.visible}});return function(e,t,i){var a=[];return e5(n,function(r){var n=r.evaluate(e,t,i);r.visible&&a.push(n)}),new r(a)}}/**
     * Execute a callback for each of the child blocks of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){for(var t=0;t<this.blocks.length;t++)e(this.blocks[t].node,"blocks["+t+"].node",this)}/**
     * Create a new BlockNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {BlockNode} Returns a transformed copy of the node
     */map(e){for(var t=[],r=0;r<this.blocks.length;r++){var i=this.blocks[r],a=this._ifNode(e(i.node,"blocks["+r+"].node",this));t[r]={node:a,visible:i.visible}}return new n(t)}/**
     * Create a clone of this node, a shallow copy
     * @return {BlockNode}
     */clone(){return new n(this.blocks.map(function(e){return{node:e.node,visible:e.visible}}))}/**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */_toString(e){return this.blocks.map(function(t){return t.node.toString(e)+(t.visible?"":";")}).join("\n")}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:tE,blocks:this.blocks}}/**
     * Instantiate an BlockNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "BlockNode", blocks: [{node: ..., visible: false}, ...]}`,
     *     where mathjs is optional
     * @returns {BlockNode}
     */static fromJSON(e){return new n(e.blocks)}/**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */toHTML(e){return this.blocks.map(function(t){return t.node.toHTML(e)+(t.visible?"":'<span class="math-separator">;</span>')}).join('<span class="math-separator"><br /></span>')}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */_toTex(e){return this.blocks.map(function(t){return t.node.toTex(e)+(t.visible?"":";")}).join("\\;\\;\n")}}return /*@__PURE__*/e(et)(n,"name",tE),n},{isClass:!0,isNode:!0}),tS="chain",tC=ta(tS,["typed","Chain"],e=>{var{typed:t,Chain:r}=e;/**
   * Wrap any value in a chain, allowing to perform chained operations on
   * the value.
   *
   * All methods available in the math.js library can be called upon the chain,
   * and then will be evaluated with the value itself as first argument.
   * The chain can be closed by executing `chain.done()`, which returns
   * the final value.
   *
   * The chain has a number of special functions:
   *
   * - `done()`     Finalize the chain and return the chain's value.
   * - `valueOf()`  The same as `done()`
   * - `toString()` Executes `math.format()` onto the chain's value, returning
   *                a string representation of the value.
   *
   * Syntax:
   *
   *    math.chain(value)
   *
   * Examples:
   *
   *     math.chain(3)
   *         .add(4)
   *         .subtract(2)
   *         .done()     // 5
   *
   *     math.chain( [[1, 2], [3, 4]] )
   *         .subset(math.index(0, 0), 8)
   *         .multiply(3)
   *         .done()     // [[24, 6], [9, 12]]
   *
   * @param {*} [value]   A value of any type on which to start a chained operation.
   * @return {math.Chain} The created chain
   */return t(tS,{"":function(){return new r},any:function(e){return new r(e)}})}),tM=ta("Chain",["?on","math","typed"],e=>{var{on:t,math:r,typed:n}=e;/**
   * @constructor Chain
   * Wrap any value in a chain, allowing to perform chained operations on
   * the value.
   *
   * All methods available in the math.js library can be called upon the chain,
   * and then will be evaluated with the value itself as first argument.
   * The chain can be closed by executing chain.done(), which will return
   * the final value.
   *
   * The Chain has a number of special functions:
   * - done()             Finalize the chained operation and return the
   *                      chain's value.
   * - valueOf()          The same as done()
   * - toString()         Returns a string representation of the chain's value.
   *
   * @param {*} [value]
   */function i(e){if(!(this instanceof i))throw SyntaxError("Constructor must be called with the new operator");W(e)?this.value=e.value:this.value=e}/**
   * Create a proxy method for the chain
   * @param {string} name
   * @param {function} resolver   The function resolving with the
   *                              function to be proxied
   * @private
   */function a(e,t){var r,n,a,s;r=i.prototype,n=function(){var e=t();if("function"==typeof e)return o(e)},s=!0,Object.defineProperty(r,e,{get:function(){return s&&(a=n(),s=!1),a},set:function(e){a=e,s=!1},configurable:!0,enumerable:!0})}/**
   * Make a function chainable
   * @param {function} fn
   * @return {Function} chain function
   * @private
   */function o(e){return function(){// Here, `this` will be the context of a Chain instance
if(0==arguments.length)return new i(e(this.value));for(var t=[this.value],r=0;r<arguments.length;r++)t[r+1]=arguments[r];if(n.isTypedFunction(e)){var a=n.resolve(e,t);// We want to detect if a rest parameter has matched across the
// value in the chain and the current arguments of this call.
// That is the case if and only if the matching signature has
// exactly one parameter (which then must be a rest parameter
// as it is matching at least two actual arguments).
if(1===a.params.length)throw Error("chain function "+e.name+" cannot match rest parameter between chain value and additional arguments.");return new i(a.implementation.apply(e,t))}return new i(e.apply(e,t))}}/**
   * Attach type information
   */i.prototype.type="Chain",i.prototype.isChain=!0,/**
   * Close the chain. Returns the final value.
   * Does the same as method valueOf()
   * @returns {*} value
   */i.prototype.done=function(){return this.value},/**
   * Close the chain. Returns the final value.
   * Does the same as method done()
   * @returns {*} value
   */i.prototype.valueOf=function(){return this.value},/**
   * Get a string representation of the value in the chain
   * @returns {string}
   */i.prototype.toString=function(){return eP(this.value)},/**
   * Get a JSON representation of the chain
   * @returns {Object}
   */i.prototype.toJSON=function(){return{mathjs:"Chain",value:this.value}},/**
   * Instantiate a Chain from its JSON representation
   * @param {Object} json  An object structured like
   *                       `{"mathjs": "Chain", value: ...}`,
   *                       where mathjs is optional
   * @returns {Chain}
   */i.fromJSON=function(e){return new i(e.value)},/**
   * Create a proxy for a single method, or an object with multiple methods.
   * Example usage:
   *
   *   Chain.createProxy('add', function add (x, y) {...})
   *   Chain.createProxy({
   *     add:      function add (x, y) {...},
   *     subtract: function subtract (x, y) {...}
   *   }
   *
   * @param {string | Object} arg0   A name (string), or an object with
   *                                 functions
   * @param {*} [arg1]               A function, when arg0 is a name
   */i.createProxy=function(e,t){if("string"==typeof e)"function"==typeof t&&(i.prototype[e]=o(t));else{var r=function(t){K(e,t)&&void 0===s[t]&&a(t,()=>e[t])};// createProxy(values)
for(var n in e)r(n)}};var s={expression:!0,docs:!0,type:!0,classes:!0,json:!0,error:!0,isChain:!0// conflicts with the property isChain of a Chain instance
};return(// create proxy for everything that is in math.js
i.createProxy(r),t&&t("import",function(e,t,r){r||a(e,t)}),i)},{isClass:!0}),tF="column",tB=ta(tF,["typed","Index","matrix","range"],e=>{var{typed:t,Index:r,matrix:n,range:i}=e;/**
   * Return a column from a Matrix.
   *
   * Syntax:
   *
   *     math.column(value, index)
   *
   * Example:
   *
   *     // get a column
   *     const d = [[1, 2], [3, 4]]
   *     math.column(d, 1) // returns [[2], [4]]
   *
   * See also:
   *
   *     row
   *
   * @param {Array | Matrix } value   An array or matrix
   * @param {number} column           The index of the column
   * @return {Array | Matrix}         The retrieved column
   */return t(tF,{"Matrix, number":a,"Array, number":function(e,t){return a(n(J(e)),t).valueOf()}});/**
   * Retrieve a column of a matrix
   * @param {Matrix } value  A matrix
   * @param {number} column  The index of the column
   * @return {Matrix}        The retrieved column
   */function a(e,t){// check dimensions
if(2!==e.size().length)throw Error("Only two dimensional matrix is supported");eY(t,e.size()[1]);var a=new r(i(0,e.size()[0]),t),o=e.subset(a);return g(o)?o:n([[o]])}}),tT=ta("column",["typed","Index","matrix","range"],e=>{var{typed:t,Index:r,matrix:n,range:i}=e,a=tB({typed:t,Index:r,matrix:n,range:i});// @see: comment of column itself
return t("column",{"...any":function(e){// change last argument from zero-based to one-based
var t=e.length-1,r=e[t];l(r)&&(e[t]=r-1);try{return a.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0});/**
 * Transpose a matrix
 * @param {Array} mat
 * @returns {Array} ret
 * @private
 */function tO(e){var t,r,n=e.length,i=e[0].length,a=[];for(r=0;r<i;r++){var o=[];for(t=0;t<n;t++)o.push(e[t][r]);a.push(o)}return a}function t_(e){for(var t=0;t<e.length;t++)if(y(e[t]))return!0;return!1}function tz(e,t){g(e)&&(e=e.valueOf());for(var r=0,n=e.length;r<n;r++){var i=e[r];Array.isArray(i)?tz(i,t):t(i)}}function tq(e,t,r){return e&&"function"==typeof e.map?e.map(function(e){return tq(e,t,r)}):t(e)}function tk(e,t,r){var n=Array.isArray(e)?eG(e):e.size();if(t<0||t>=n.length)throw new eZ(t,n.length);return g(e)?e.create(tI(e.valueOf(),t,r)):tI(e,t,r)}/**
 * Recursively reduce a matrix
 * @param {Array} mat
 * @param {number} dim
 * @param {Function} callback
 * @returns {Array} ret
 * @private
 */function tI(e,t,r){var n,i,a,o;if(t<=0){if(Array.isArray(e[0])){for(n=0,o=tO(e),i=[];n<o.length;n++)i[n]=tI(o[n],t-1,r);return i}for(n=1,a=e[0];n<e.length;n++)a=r(a,e[n]);return a}for(n=0,i=[];n<e.length;n++)i[n]=tI(e[n],t-1,r);return i}function tR(e,t,r,n,i,a,o,s,u,l,c){// a arrays
var f,p,m,d,h=e._values,g=e._index,y=e._ptr;// check we need to process values (pattern matrix)
if(n)for(p=y[t],m=y[t+1],f=p;f<m;f++)// check value exists in current j
r[// row
d=g[f]]!==a?(// i is new entry in j
r[d]=a,// add i to pattern of C
o.push(d),l?(// copy value to workspace calling callback function
n[d]=u?s(h[f],c):s(c,h[f]),// function was called on current row
i[d]=a):n[d]=h[f]):(// i exists in C already
n[d]=u?s(h[f],n[d]):s(n[d],h[f]),// function was called on current row
i[d]=a);else for(p=y[t],m=y[t+1],f=p;f<m;f++)// check value exists in current j
r[// row
d=g[f]]!==a?(// i is new entry in j
r[d]=a,// add i to pattern of C
o.push(d)):i[d]=a}var tP="compile",tj=ta(tP,["typed","parse"],e=>{var{typed:t,parse:r}=e;/**
   * Parse and compile an expression.
   * Returns a an object with a function `evaluate([scope])` to evaluate the
   * compiled expression.
   *
   * Syntax:
   *
   *     math.compile(expr)                       // returns one node
   *     math.compile([expr1, expr2, expr3, ...]) // returns an array with nodes
   *
   * Examples:
   *
   *     const code1 = math.compile('sqrt(3^2 + 4^2)')
   *     code1.evaluate() // 5
   *
   *     let scope = {a: 3, b: 4}
   *     const code2 = math.compile('a * b') // 12
   *     code2.evaluate(scope) // 12
   *     scope.a = 5
   *     code2.evaluate(scope) // 20
   *
   *     const nodes = math.compile(['a = 3', 'b = 4', 'a * b'])
   *     nodes[2].evaluate() // 12
   *
   * See also:
   *
   *    parse, evaluate
   *
   * @param {string | string[] | Array | Matrix} expr
   *            The expression to be compiled
   * @return {{evaluate: Function} | Array.<{evaluate: Function}>} code
   *            An object with the compiled expression
   * @throws {Error}
   */return t(tP,{string:function(e){return r(e).compile()},"Array | Matrix":function(e){return tq(e,function(e){return r(e).compile()})}})}),tU="concat",tL=ta(tU,["typed","matrix","isInteger"],e=>{var{typed:t,matrix:r,isInteger:n}=e;/**
   * Concatenate two or more matrices.
   *
   * Syntax:
   *
   *     math.concat(A, B, C, ...)
   *     math.concat(A, B, C, ..., dim)
   *
   * Where:
   *
   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.
   *   By default the last dimension of the matrices.
   *
   * Examples:
   *
   *    const A = [[1, 2], [5, 6]]
   *    const B = [[3, 4], [7, 8]]
   *
   *    math.concat(A, B)                  // returns [[1, 2, 3, 4], [5, 6, 7, 8]]
   *    math.concat(A, B, 0)               // returns [[1, 2], [5, 6], [3, 4], [7, 8]]
   *    math.concat('hello', ' ', 'world') // returns 'hello world'
   *
   * See also:
   *
   *    size, squeeze, subset, transpose
   *
   * @param {... Array | Matrix} args     Two or more matrices
   * @return {Array | Matrix} Concatenated matrix
   */return t(tU,{// TODO: change signature to '...Array | Matrix, dim?' when supported
"...Array | Matrix | number | BigNumber":function(e){var t,i,a=e.length,o=-1,s=!1,u=[];for(t=0;t<a;t++){var f=e[t];if(g(f)&&(s=!0),l(f)||c(f)){if(t!==a-1)throw Error("Dimension must be specified as last argument");if(// last argument contains the dimension on which to concatenate
i=o,!n(o=f.valueOf()))throw TypeError("Integer number expected for dimension");if(o<0||t>0&&o>i)throw new eZ(o,i+1)}else{// this is a matrix or array
var p=J(f).valueOf(),m=eG(p);// verify whether each of the matrices has the same number of dimensions
if(u[t]=p,i=o,o=m.length-1,t>0&&o!==i)throw new eH(i+1,o+1)}}if(0===u.length)throw SyntaxError("At least one matrix expected");for(var d=u.shift();u.length;)d=tr(d,u.shift(),o);return s?r(d):d},"...string":function(e){return e.join("")}})}),t$=ta("concat",["typed","matrix","isInteger"],e=>{var{typed:t,matrix:r,isInteger:n}=e,i=tL({typed:t,matrix:r,isInteger:n});/**
   * Attach a transform function to math.range
   * Adds a property transform containing the transform function.
   *
   * This transform changed the last `dim` parameter of function concat
   * from one-based to zero based
   */return t("concat",{"...any":function(e){// change last argument from one-based to zero-based
var t=e.length-1,r=e[t];l(r)?e[t]=r-1:c(r)&&(e[t]=r.minus(1));try{return i.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0}),tH="ConditionalNode",tZ=ta(tH,["Node"],t=>{var{Node:Node}=t;class r extends Node{/**
     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
     *
     * @param {Node} condition   Condition, must result in a boolean
     * @param {Node} trueExpr    Expression evaluated when condition is true
     * @param {Node} falseExpr   Expression evaluated when condition is true
     *
     * @constructor ConditionalNode
     * @extends {Node}
     */constructor(e,t,r){if(super(),!U(e))throw TypeError("Parameter condition must be a Node");if(!U(t))throw TypeError("Parameter trueExpr must be a Node");if(!U(r))throw TypeError("Parameter falseExpr must be a Node");this.condition=e,this.trueExpr=t,this.falseExpr=r}get type(){return tH}get isConditionalNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){var r=this.condition._compile(e,t),n=this.trueExpr._compile(e,t),i=this.falseExpr._compile(e,t);return function(e,t,a){return!/**
   * Test whether a condition is met
   * @param {*} condition
   * @returns {boolean} true if condition is true or non-zero, else false
   */function(e){if("number"==typeof e||"boolean"==typeof e||"string"==typeof e)return!!e;if(e){if(c(e))return!e.isZero();if(f(e))return!!(e.re||e.im);if(m(e))return!!e.value}if(null==e)return!1;throw TypeError('Unsupported type of condition "'+Y(e)+'"')}(r(e,t,a))?i(e,t,a):n(e,t,a)}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){e(this.condition,"condition",this),e(this.trueExpr,"trueExpr",this),e(this.falseExpr,"falseExpr",this)}/**
     * Create a new ConditionalNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ConditionalNode} Returns a transformed copy of the node
     */map(e){return new r(this._ifNode(e(this.condition,"condition",this)),this._ifNode(e(this.trueExpr,"trueExpr",this)),this._ifNode(e(this.falseExpr,"falseExpr",this)))}/**
     * Create a clone of this node, a shallow copy
     * @return {ConditionalNode}
     */clone(){return new r(this.condition,this.trueExpr,this.falseExpr)}/**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */_toString(e){var t=e&&e.parenthesis?e.parenthesis:"keep",r=tx(this,t,e&&e.implicit),n=this.condition.toString(e),i=tx(this.condition,t,e&&e.implicit);("all"===t||"OperatorNode"===this.condition.type||null!==i&&i<=r)&&(n="("+n+")");var a=this.trueExpr.toString(e),o=tx(this.trueExpr,t,e&&e.implicit);("all"===t||"OperatorNode"===this.trueExpr.type||null!==o&&o<=r)&&(a="("+a+")");var s=this.falseExpr.toString(e),u=tx(this.falseExpr,t,e&&e.implicit);return("all"===t||"OperatorNode"===this.falseExpr.type||null!==u&&u<=r)&&(s="("+s+")"),n+" ? "+a+" : "+s}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:tH,condition:this.condition,trueExpr:this.trueExpr,falseExpr:this.falseExpr}}/**
     * Instantiate an ConditionalNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "ConditionalNode",
     *      "condition": ...,
     *      "trueExpr": ...,
     *      "falseExpr": ...}
     *     ```
     *     where mathjs is optional
     * @returns {ConditionalNode}
     */static fromJSON(e){return new r(e.condition,e.trueExpr,e.falseExpr)}/**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */toHTML(e){var t=e&&e.parenthesis?e.parenthesis:"keep",r=tx(this,t,e&&e.implicit),n=this.condition.toHTML(e),i=tx(this.condition,t,e&&e.implicit);("all"===t||"OperatorNode"===this.condition.type||null!==i&&i<=r)&&(n='<span class="math-parenthesis math-round-parenthesis">(</span>'+n+'<span class="math-parenthesis math-round-parenthesis">)</span>');var a=this.trueExpr.toHTML(e),o=tx(this.trueExpr,t,e&&e.implicit);("all"===t||"OperatorNode"===this.trueExpr.type||null!==o&&o<=r)&&(a='<span class="math-parenthesis math-round-parenthesis">(</span>'+a+'<span class="math-parenthesis math-round-parenthesis">)</span>');var s=this.falseExpr.toHTML(e),u=tx(this.falseExpr,t,e&&e.implicit);return("all"===t||"OperatorNode"===this.falseExpr.type||null!==u&&u<=r)&&(s='<span class="math-parenthesis math-round-parenthesis">(</span>'+s+'<span class="math-parenthesis math-round-parenthesis">)</span>'),n+'<span class="math-operator math-conditional-operator">?</span>'+a+'<span class="math-operator math-conditional-operator">:</span>'+s}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */_toTex(e){return"\\begin{cases} {"+this.trueExpr.toTex(e)+"}, &\\quad{\\text{if }\\;"+this.condition.toTex(e)+"}\\\\{"+this.falseExpr.toTex(e)+"}, &\\quad{\\text{otherwise}}\\end{cases}"}}return /*@__PURE__*/e(et)(r,"name",tH),r},{isClass:!0,isNode:!0}),tG={},tV=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},tW={"{":"\\{","}":"\\}","\\":"\\textbackslash{}","#":"\\#",$:"\\$","%":"\\%","&":"\\&","^":"\\textasciicircum{}",_:"\\_","~":"\\textasciitilde{}"},tY={"–":"\\--","—":"\\---"," ":"~","	":"\\qquad{}","\r\n":"\\newline{}","\n":"\\newline{}"};/**
 * Escape a string to be used in LaTeX documents.
 * @param {string} str the string to be escaped.
 * @param {boolean} params.preserveFormatting whether formatting escapes should
 *  be performed (default: false).
 * @param {function} params.escapeMapFn the function to modify the escape maps.
 * @return {string} the escaped string, ready to be used in LaTeX.
 */tG=function(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=t.preserveFormatting,n=t.escapeMapFn,i=String(e),a="",o=(void 0===n?function(e,t){return tV({},e,t)}:n)(tV({},tW),void 0!==r&&r?tV({},tY):{}),s=Object.keys(o);i;)!function(){var e=!1;s.forEach(function(t,r){!e&&i.length>=t.length&&i.slice(0,t.length)===t&&(a+=o[s[r]],i=i.slice(t.length,i.length),e=!0)}),e||(a+=i.slice(0,1),i=i.slice(1,i.length))}();return a};var tJ={// GREEK LETTERS
Alpha:"A",alpha:"\\alpha",Beta:"B",beta:"\\beta",Gamma:"\\Gamma",gamma:"\\gamma",Delta:"\\Delta",delta:"\\delta",Epsilon:"E",epsilon:"\\epsilon",varepsilon:"\\varepsilon",Zeta:"Z",zeta:"\\zeta",Eta:"H",eta:"\\eta",Theta:"\\Theta",theta:"\\theta",vartheta:"\\vartheta",Iota:"I",iota:"\\iota",Kappa:"K",kappa:"\\kappa",varkappa:"\\varkappa",Lambda:"\\Lambda",lambda:"\\lambda",Mu:"M",mu:"\\mu",Nu:"N",nu:"\\nu",Xi:"\\Xi",xi:"\\xi",Omicron:"O",omicron:"o",Pi:"\\Pi",pi:"\\pi",varpi:"\\varpi",Rho:"P",rho:"\\rho",varrho:"\\varrho",Sigma:"\\Sigma",sigma:"\\sigma",varsigma:"\\varsigma",Tau:"T",tau:"\\tau",Upsilon:"\\Upsilon",upsilon:"\\upsilon",Phi:"\\Phi",phi:"\\phi",varphi:"\\varphi",Chi:"X",chi:"\\chi",Psi:"\\Psi",psi:"\\psi",Omega:"\\Omega",omega:"\\omega",// logic
true:"\\mathrm{True}",false:"\\mathrm{False}",// other
i:"i",// TODO use \i ??
inf:"\\infty",Inf:"\\infty",infinity:"\\infty",Infinity:"\\infty",oo:"\\infty",lim:"\\lim",undefined:"\\mathbf{?}"},tX={transpose:"^\\top",ctranspose:"^H",factorial:"!",pow:"^",dotPow:".^\\wedge",// TODO find ideal solution
unaryPlus:"+",unaryMinus:"-",bitNot:"\\~",// TODO find ideal solution
not:"\\neg",multiply:"\\cdot",divide:"\\frac",// TODO how to handle that properly?
dotMultiply:".\\cdot",// TODO find ideal solution
dotDivide:".:",// TODO find ideal solution
mod:"\\mod",add:"+",subtract:"-",to:"\\rightarrow",leftShift:"<<",rightArithShift:">>",rightLogShift:">>>",equal:"=",unequal:"\\neq",smaller:"<",larger:">",smallerEq:"\\leq",largerEq:"\\geq",bitAnd:"\\&",bitXor:"\\underline{|}",bitOr:"|",and:"\\wedge",xor:"\\veebar",or:"\\vee"},tQ={// arithmetic
abs:{1:"\\left|${args[0]}\\right|"},add:{2:"\\left(${args[0]}".concat(tX.add,"${args[1]}\\right)")},cbrt:{1:"\\sqrt[3]{${args[0]}}"},ceil:{1:"\\left\\lceil${args[0]}\\right\\rceil"},cube:{1:"\\left(${args[0]}\\right)^3"},divide:{2:"\\frac{${args[0]}}{${args[1]}}"},dotDivide:{2:"\\left(${args[0]}".concat(tX.dotDivide,"${args[1]}\\right)")},dotMultiply:{2:"\\left(${args[0]}".concat(tX.dotMultiply,"${args[1]}\\right)")},dotPow:{2:"\\left(${args[0]}".concat(tX.dotPow,"${args[1]}\\right)")},exp:{1:"\\exp\\left(${args[0]}\\right)"},expm1:"\\left(e".concat(tX.pow,"{${args[0]}}-1\\right)"),fix:{1:"\\mathrm{${name}}\\left(${args[0]}\\right)"},floor:{1:"\\left\\lfloor${args[0]}\\right\\rfloor"},gcd:"\\gcd\\left(${args}\\right)",hypot:"\\hypot\\left(${args}\\right)",log:{1:"\\ln\\left(${args[0]}\\right)",2:"\\log_{${args[1]}}\\left(${args[0]}\\right)"},log10:{1:"\\log_{10}\\left(${args[0]}\\right)"},log1p:{1:"\\ln\\left(${args[0]}+1\\right)",2:"\\log_{${args[1]}}\\left(${args[0]}+1\\right)"},log2:"\\log_{2}\\left(${args[0]}\\right)",mod:{2:"\\left(${args[0]}".concat(tX.mod,"${args[1]}\\right)")},multiply:{2:"\\left(${args[0]}".concat(tX.multiply,"${args[1]}\\right)")},norm:{1:"\\left\\|${args[0]}\\right\\|",2:void 0// use default template
},nthRoot:{2:"\\sqrt[${args[1]}]{${args[0]}}"},nthRoots:{2:"\\{y : $y^{args[1]} = {${args[0]}}\\}"},pow:{2:"\\left(${args[0]}\\right)".concat(tX.pow,"{${args[1]}}")},round:{1:"\\left\\lfloor${args[0]}\\right\\rceil",2:void 0// use default template
},sign:{1:"\\mathrm{${name}}\\left(${args[0]}\\right)"},sqrt:{1:"\\sqrt{${args[0]}}"},square:{1:"\\left(${args[0]}\\right)^2"},subtract:{2:"\\left(${args[0]}".concat(tX.subtract,"${args[1]}\\right)")},unaryMinus:{1:"".concat(tX.unaryMinus,"\\left(${args[0]}\\right)")},unaryPlus:{1:"".concat(tX.unaryPlus,"\\left(${args[0]}\\right)")},// bitwise
bitAnd:{2:"\\left(${args[0]}".concat(tX.bitAnd,"${args[1]}\\right)")},bitNot:{1:tX.bitNot+"\\left(${args[0]}\\right)"},bitOr:{2:"\\left(${args[0]}".concat(tX.bitOr,"${args[1]}\\right)")},bitXor:{2:"\\left(${args[0]}".concat(tX.bitXor,"${args[1]}\\right)")},leftShift:{2:"\\left(${args[0]}".concat(tX.leftShift,"${args[1]}\\right)")},rightArithShift:{2:"\\left(${args[0]}".concat(tX.rightArithShift,"${args[1]}\\right)")},rightLogShift:{2:"\\left(${args[0]}".concat(tX.rightLogShift,"${args[1]}\\right)")},// combinatorics
bellNumbers:{1:"\\mathrm{B}_{${args[0]}}"},catalan:{1:"\\mathrm{C}_{${args[0]}}"},stirlingS2:{2:"\\mathrm{S}\\left(${args}\\right)"},// complex
arg:{1:"\\arg\\left(${args[0]}\\right)"},conj:{1:"\\left(${args[0]}\\right)^*"},im:{1:"\\Im\\left\\lbrace${args[0]}\\right\\rbrace"},re:{1:"\\Re\\left\\lbrace${args[0]}\\right\\rbrace"},// logical
and:{2:"\\left(${args[0]}".concat(tX.and,"${args[1]}\\right)")},not:{1:tX.not+"\\left(${args[0]}\\right)"},or:{2:"\\left(${args[0]}".concat(tX.or,"${args[1]}\\right)")},xor:{2:"\\left(${args[0]}".concat(tX.xor,"${args[1]}\\right)")},// matrix
cross:{2:"\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"},ctranspose:{1:"\\left(${args[0]}\\right)".concat(tX.ctranspose)},det:{1:"\\det\\left(${args[0]}\\right)"},dot:{2:"\\left(${args[0]}\\cdot${args[1]}\\right)"},expm:{1:"\\exp\\left(${args[0]}\\right)"},inv:{1:"\\left(${args[0]}\\right)^{-1}"},pinv:{1:"\\left(${args[0]}\\right)^{+}"},sqrtm:{1:"{${args[0]}}".concat(tX.pow,"{\\frac{1}{2}}")},trace:{1:"\\mathrm{tr}\\left(${args[0]}\\right)"},transpose:{1:"\\left(${args[0]}\\right)".concat(tX.transpose)},// probability
combinations:{2:"\\binom{${args[0]}}{${args[1]}}"},combinationsWithRep:{2:"\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"},factorial:{1:"\\left(${args[0]}\\right)".concat(tX.factorial)},gamma:{1:"\\Gamma\\left(${args[0]}\\right)"},lgamma:{1:"\\ln\\Gamma\\left(${args[0]}\\right)"},// relational
equal:{2:"\\left(${args[0]}".concat(tX.equal,"${args[1]}\\right)")},larger:{2:"\\left(${args[0]}".concat(tX.larger,"${args[1]}\\right)")},largerEq:{2:"\\left(${args[0]}".concat(tX.largerEq,"${args[1]}\\right)")},smaller:{2:"\\left(${args[0]}".concat(tX.smaller,"${args[1]}\\right)")},smallerEq:{2:"\\left(${args[0]}".concat(tX.smallerEq,"${args[1]}\\right)")},unequal:{2:"\\left(${args[0]}".concat(tX.unequal,"${args[1]}\\right)")},// special
erf:{1:"erf\\left(${args[0]}\\right)"},// statistics
max:"\\max\\left(${args}\\right)",min:"\\min\\left(${args}\\right)",variance:"\\mathrm{Var}\\left(${args}\\right)",// trigonometry
acos:{1:"\\cos^{-1}\\left(${args[0]}\\right)"},acosh:{1:"\\cosh^{-1}\\left(${args[0]}\\right)"},acot:{1:"\\cot^{-1}\\left(${args[0]}\\right)"},acoth:{1:"\\coth^{-1}\\left(${args[0]}\\right)"},acsc:{1:"\\csc^{-1}\\left(${args[0]}\\right)"},acsch:{1:"\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"},asec:{1:"\\sec^{-1}\\left(${args[0]}\\right)"},asech:{1:"\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"},asin:{1:"\\sin^{-1}\\left(${args[0]}\\right)"},asinh:{1:"\\sinh^{-1}\\left(${args[0]}\\right)"},atan:{1:"\\tan^{-1}\\left(${args[0]}\\right)"},atan2:{2:"\\mathrm{atan2}\\left(${args}\\right)"},atanh:{1:"\\tanh^{-1}\\left(${args[0]}\\right)"},cos:{1:"\\cos\\left(${args[0]}\\right)"},cosh:{1:"\\cosh\\left(${args[0]}\\right)"},cot:{1:"\\cot\\left(${args[0]}\\right)"},coth:{1:"\\coth\\left(${args[0]}\\right)"},csc:{1:"\\csc\\left(${args[0]}\\right)"},csch:{1:"\\mathrm{csch}\\left(${args[0]}\\right)"},sec:{1:"\\sec\\left(${args[0]}\\right)"},sech:{1:"\\mathrm{sech}\\left(${args[0]}\\right)"},sin:{1:"\\sin\\left(${args[0]}\\right)"},sinh:{1:"\\sinh\\left(${args[0]}\\right)"},tan:{1:"\\tan\\left(${args[0]}\\right)"},tanh:{1:"\\tanh\\left(${args[0]}\\right)"},// unit
to:{2:"\\left(${args[0]}".concat(tX.to,"${args[1]}\\right)")},// utils
numeric:function(e,t){// Not sure if this is strictly right but should work correctly for the vast majority of use cases.
return e.args[0].toTex()},// type
number:{0:"0",1:"\\left(${args[0]}\\right)",2:"\\left(\\left(${args[0]}\\right)${args[1]}\\right)"},string:{0:'\\mathtt{""}',1:"\\mathrm{string}\\left(${args[0]}\\right)"},bignumber:{0:"0",1:"\\left(${args[0]}\\right)"},complex:{0:"0",1:"\\left(${args[0]}\\right)",2:"\\left(\\left(${args[0]}\\right)+".concat(tJ.i,"\\cdot\\left(${args[1]}\\right)\\right)")},matrix:{0:"\\begin{bmatrix}\\end{bmatrix}",1:"\\left(${args[0]}\\right)",2:"\\left(${args[0]}\\right)"},sparse:{0:"\\begin{bsparse}\\end{bsparse}",1:"\\left(${args[0]}\\right)"},unit:{1:"\\left(${args[0]}\\right)",2:"\\left(\\left(${args[0]}\\right)${args[1]}\\right)"}},tK={deg:"^\\circ"};function t0(t){return /*@__PURE__*/e(tG)(t,{preserveFormatting:!0})}function t1(e,t){return(t=void 0!==t&&t)?K(tK,e)?tK[e]:"\\mathrm{"+t0(e)+"}":K(tJ,e)?tJ[e]:t0(e)}var t2="ConstantNode",t3=ta(t2,["Node"],t=>{var{Node:Node}=t;class r extends Node{/**
     * A ConstantNode holds a constant value like a number or string.
     *
     * Usage:
     *
     *     new ConstantNode(2.3)
     *     new ConstantNode('hello')
     *
     * @param {*} value    Value can be any type (number, BigNumber, string, ...)
     * @constructor ConstantNode
     * @extends {Node}
     */constructor(e){super(),this.value=e}get type(){return t2}get isConstantNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){var r=this.value;return function(){return r}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){// nothing to do, we don't have any children
}/**
     * Create a new ConstantNode with children produced by the given callback.
     * Trivial because there are no children.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ConstantNode} Returns a clone of the node
     */map(e){return this.clone()}/**
     * Create a clone of this node, a shallow copy
     * @return {ConstantNode}
     */clone(){return new r(this.value)}/**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */_toString(e){return eP(this.value,e)}/**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */toHTML(e){var t=this._toString(e);switch(Y(this.value)){case"number":case"BigNumber":case"Fraction":return'<span class="math-number">'+t+"</span>";case"string":return'<span class="math-string">'+t+"</span>";case"boolean":return'<span class="math-boolean">'+t+"</span>";case"null":return'<span class="math-null-symbol">'+t+"</span>";case"undefined":return'<span class="math-undefined">'+t+"</span>";default:return'<span class="math-symbol">'+t+"</span>"}}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:t2,value:this.value}}/**
     * Instantiate a ConstantNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", value: 2.3}`,
     *                       where mathjs is optional
     * @returns {ConstantNode}
     */static fromJSON(e){return new r(e.value)}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */_toTex(e){var t=this._toString(e);switch(Y(this.value)){case"string":return"\\mathtt{"+t0(t)+"}";case"number":case"BigNumber":if(!isFinite(this.value))return 0>this.value.valueOf()?"-\\infty":"\\infty";var r=t.toLowerCase().indexOf("e");if(-1!==r)return t.substring(0,r)+"\\cdot10^{"+t.substring(r+1)+"}";return t;case"Fraction":return this.value.toLatex();default:return t}}}return /*@__PURE__*/e(et)(r,"name",t2),r},{isClass:!0,isNode:!0});function t4(e,t,r){// TODO: add information with the index (also needs transform in expression parser)
var n;return -1!==String(e).indexOf("Unexpected type")?(n=arguments.length>2?" (type: "+Y(r)+", value: "+JSON.stringify(r)+")":" (type: "+e.data.actual+")",TypeError("Cannot calculate "+t+", unexpected type of argument"+n)):-1!==String(e).indexOf("complex numbers")?(n=arguments.length>2?" (type: "+Y(r)+", value: "+JSON.stringify(r)+")":"",TypeError("Cannot calculate "+t+", no ordering relation is defined for complex numbers"+n)):e}var t5="cumsum",t8=ta(t5,["typed","add","unaryPlus"],e=>{var{typed:t,add:r,unaryPlus:n}=e;/**
   * Compute the cumulative sum of a matrix or a list with values.
   * In case of a (multi dimensional) array or matrix, the cumulative sums
   * along a specified dimension (defaulting to the first) will be calculated.
   *
   * Syntax:
   *
   *     math.cumsum(a, b, c, ...)
   *     math.cumsum(A)
   *
   * Examples:
   *
   *     math.cumsum(2, 1, 4, 3)               // returns [2, 3, 7, 10]
   *     math.cumsum([2, 1, 4, 3])             // returns [2, 3, 7, 10]
   *     math.cumsum([[1, 2], [3, 4]])         // returns [[1, 2], [4, 6]]
   *     math.cumsum([[1, 2], [3, 4]], 0)      // returns [[1, 2], [4, 6]]
   *     math.cumsum([[1, 2], [3, 4]], 1)      // returns [[1, 3], [3, 7]]
   *     math.cumsum([[2, 5], [4, 3], [1, 7]]) // returns [[2, 5], [6, 8], [7, 15]]
   *
   * See also:
   *
   *    mean, median, min, max, prod, std, variance, sum
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The cumulative sum of all values
   */return t(t5,{// sum([a, b, c, d, ...])
Array:i,Matrix:function(e){return e.create(i(e.valueOf()))},// sum([a, b, c, d, ...], dim)
"Array, number | BigNumber":o,"Matrix, number | BigNumber":function(e,t){return e.create(o(e.valueOf(),t))},// cumsum(a, b, c, d, ...)
"...":function(e){if(t_(e))throw TypeError("All values expected to be scalar in function cumsum");return i(e)}});/**
     * Recursively calculate the cumulative sum of an n-dimensional array
     * @param {Array} array
     * @return {number} cumsum
     * @private
     */function i(e){try{return a(e)}catch(e){throw t4(e,t5)}}function a(e){if(0===e.length)return[];for(var t=[n(e[0])],i=1;i<e.length;++i)// 2+-dimensional array along the 0th dimension (the row vectors,
// or higher-d analogues, are literally added to each other).
t.push(r(t[i-1],e[i]));return t}function o(e,t){var r=eG(e);if(t<0||t>=r.length)throw new eZ(t,r.length);try{return /* Possible TODO: Refactor _reduce in collection.js to be able to work here as well */function e(t,r){var n,i,o;if(r<=0){if(!Array.isArray(t[0][0]))return a(t);for(n=0,o=tO(t),i=[];n<o.length;n++)i[n]=e(o[n],r-1);return i}for(n=0,i=[];n<t.length;n++)i[n]=e(t[n],r-1);return i}(e,t)}catch(e){throw t4(e,t5)}}}),t6="cumsum",t7=ta(t6,["typed","add","unaryPlus"],e=>{var{typed:t,add:r,unaryPlus:n}=e,i=t8({typed:t,add:r,unaryPlus:n});return t(t6,{"...any":function(e){// change last argument dim from one-based to zero-based
if(2===e.length&&y(e[0])){var t=e[1];l(t)?e[1]=t-1:c(t)&&(e[1]=t.minus(1))}try{return i.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0}),t9="derivative",re=ta(t9,["typed","config","parse","simplify","equal","isZero","numeric","ConstantNode","FunctionNode","OperatorNode","ParenthesisNode","SymbolNode"],e=>{var{typed:t,config:r,parse:n,simplify:i,equal:a,isZero:o,numeric:s,ConstantNode:u,FunctionNode:l,OperatorNode:c,ParenthesisNode:f,SymbolNode:p}=e;/**
   * Takes the derivative of an expression expressed in parser Nodes.
   * The derivative will be taken over the supplied variable in the
   * second parameter. If there are multiple variables in the expression,
   * it will return a partial derivative.
   *
   * This uses rules of differentiation which can be found here:
   *
   * - [Differentiation rules (Wikipedia)](https://en.wikipedia.org/wiki/Differentiation_rules)
   *
   * Syntax:
   *
   *     math.derivative(expr, variable)
   *     math.derivative(expr, variable, options)
   *
   * Examples:
   *
   *     math.derivative('x^2', 'x')                     // Node '2 * x'
   *     math.derivative('x^2', 'x', {simplify: false})  // Node '2 * 1 * x ^ (2 - 1)'
   *     math.derivative('sin(2x)', 'x'))                // Node '2 * cos(2 * x)'
   *     math.derivative('2*x', 'x').evaluate()          // number 2
   *     math.derivative('x^2', 'x').evaluate({x: 4})    // number 8
   *     const f = math.parse('x^2')
   *     const x = math.parse('x')
   *     math.derivative(f, x)                           // Node {2 * x}
   *
   * See also:
   *
   *     simplify, parse, evaluate
   *
   * @param  {Node | string} expr           The expression to differentiate
   * @param  {SymbolNode | string} variable The variable over which to differentiate
   * @param  {{simplify: boolean}} [options]
   *                         There is one option available, `simplify`, which
   *                         is true by default. When false, output will not
   *                         be simplified.
   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`
   */function m(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{simplify:!0},n={};g(n,e,t.name);var a=y(e,n);return r.simplify?i(a):a}t.addConversion({from:"identifier",to:"SymbolNode",convert:n});var d=t(t9,{"Node, SymbolNode":m,"Node, SymbolNode, Object":m});t.removeConversion({from:"identifier",to:"SymbolNode",convert:n}),d._simplify=!0,d.toTex=function(e){return h.apply(null,e.args)};// FIXME: move the toTex method of derivative to latex.js. Difficulty is that it relies on parse.
// NOTE: the optional "order" parameter here is currently unused
var h=t("_derivTex",{"Node, SymbolNode":function(e,t){return k(e)&&"string"===Y(e.value)?h(n(e.value).toString(),t.toString(),1):h(e.toTex(),t.toString(),1)},"Node, ConstantNode":function(e,t){if("string"===Y(t.value))return h(e,n(t.value));throw Error("The second parameter to 'derivative' is a non-string constant")},"Node, SymbolNode, ConstantNode":function(e,t,r){return h(e.toString(),t.name,r.value)},"string, string, number":function(e,t,r){return(1===r?"{d\\over d"+t+"}":"{d^{"+r+"}\\over d"+t+"^{"+r+"}}")+"\\left[".concat(e,"\\right]")}}),g=t("constTag",{"Object, ConstantNode, string":function(e,t){return e[t]=!0,!0},"Object, SymbolNode, string":function(e,t,r){return(// Treat other variables like constants. For reasoning, see:
//   https://en.wikipedia.org/wiki/Partial_derivative
t.name!==r&&(e[t]=!0,!0))},"Object, ParenthesisNode, string":function(e,t,r){return g(e,t.content,r)},"Object, FunctionAssignmentNode, string":function(e,t,r){return -1===t.params.indexOf(r)?(e[t]=!0,!0):g(e,t.expr,r)},"Object, FunctionNode | OperatorNode, string":function(e,t,r){if(t.args.length>0){for(var n=g(e,t.args[0],r),i=1;i<t.args.length;++i)n=g(e,t.args[i],r)&&n;if(n)return e[t]=!0,!0}return!1}}),y=t("_derivative",{"ConstantNode, Object":function(e){return v(0)},"SymbolNode, Object":function(e,t){return void 0!==t[e]?v(0):v(1)},"ParenthesisNode, Object":function(e,t){return new f(y(e.content,t))},"FunctionAssignmentNode, Object":function(e,t){return void 0!==t[e]?v(0):y(e.expr,t)},"FunctionNode, Object":function(e,t){if(void 0!==t[e])return v(0);var r,n,i,a,o=e.args[0],s=!1,u=!1;switch(e.name){case"cbrt":// d/dx(cbrt(x)) = 1 / (3x^(2/3))
s=!0,n=new c("*","multiply",[v(3),new c("^","pow",[o,new c("/","divide",[v(2),v(3)])])]);break;case"sqrt":case"nthRoot":// d/dx(sqrt(x)) = 1 / (2*sqrt(x))
if(1===e.args.length)s=!0,n=new c("*","multiply",[v(2),new l("sqrt",[o])]);else if(2===e.args.length)return(// Is a variable?
t[// Rearrange from nthRoot(x, a) -> x^(1/a)
r=new c("/","divide",[v(1),e.args[1]])]=t[e.args[1]],y(new c("^","pow",[o,r]),t));break;case"log10":r=v(10);/* fall through! */case"log":if(r||1!==e.args.length){if(1===e.args.length&&r||2===e.args.length&&void 0!==t[e.args[1]])// d/dx(log(x, c)) = 1 / (x*ln(c))
n=new c("*","multiply",[o.clone(),new l("log",[r||e.args[1]])]),s=!0;else if(2===e.args.length)return y(new c("/","divide",[new l("log",[o]),new l("log",[e.args[1]])]),t)}else // d/dx(log(x)) = 1 / x
n=o.clone(),s=!0;break;case"pow":if(2===e.args.length)// Pass to pow operator node parser
return t[r]=t[e.args[1]],y(new c("^","pow",[o,e.args[1]]),t);break;case"exp":// d/dx(e^x) = e^x
n=new l("exp",[o.clone()]);break;case"sin":// d/dx(sin(x)) = cos(x)
n=new l("cos",[o.clone()]);break;case"cos":// d/dx(cos(x)) = -sin(x)
n=new c("-","unaryMinus",[new l("sin",[o.clone()])]);break;case"tan":// d/dx(tan(x)) = sec(x)^2
n=new c("^","pow",[new l("sec",[o.clone()]),v(2)]);break;case"sec":// d/dx(sec(x)) = sec(x)tan(x)
n=new c("*","multiply",[e,new l("tan",[o.clone()])]);break;case"csc":// d/dx(csc(x)) = -csc(x)cot(x)
u=!0,n=new c("*","multiply",[e,new l("cot",[o.clone()])]);break;case"cot":// d/dx(cot(x)) = -csc(x)^2
u=!0,n=new c("^","pow",[new l("csc",[o.clone()]),v(2)]);break;case"asin":// d/dx(asin(x)) = 1 / sqrt(1 - x^2)
s=!0,n=new l("sqrt",[new c("-","subtract",[v(1),new c("^","pow",[o.clone(),v(2)])])]);break;case"acos":// d/dx(acos(x)) = -1 / sqrt(1 - x^2)
s=!0,u=!0,n=new l("sqrt",[new c("-","subtract",[v(1),new c("^","pow",[o.clone(),v(2)])])]);break;case"atan":// d/dx(atan(x)) = 1 / (x^2 + 1)
s=!0,n=new c("+","add",[new c("^","pow",[o.clone(),v(2)]),v(1)]);break;case"asec":// d/dx(asec(x)) = 1 / (|x|*sqrt(x^2 - 1))
s=!0,n=new c("*","multiply",[new l("abs",[o.clone()]),new l("sqrt",[new c("-","subtract",[new c("^","pow",[o.clone(),v(2)]),v(1)])])]);break;case"acsc":// d/dx(acsc(x)) = -1 / (|x|*sqrt(x^2 - 1))
s=!0,u=!0,n=new c("*","multiply",[new l("abs",[o.clone()]),new l("sqrt",[new c("-","subtract",[new c("^","pow",[o.clone(),v(2)]),v(1)])])]);break;case"acot":// d/dx(acot(x)) = -1 / (x^2 + 1)
s=!0,u=!0,n=new c("+","add",[new c("^","pow",[o.clone(),v(2)]),v(1)]);break;case"sinh":// d/dx(sinh(x)) = cosh(x)
n=new l("cosh",[o.clone()]);break;case"cosh":// d/dx(cosh(x)) = sinh(x)
n=new l("sinh",[o.clone()]);break;case"tanh":// d/dx(tanh(x)) = sech(x)^2
n=new c("^","pow",[new l("sech",[o.clone()]),v(2)]);break;case"sech":// d/dx(sech(x)) = -sech(x)tanh(x)
u=!0,n=new c("*","multiply",[e,new l("tanh",[o.clone()])]);break;case"csch":// d/dx(csch(x)) = -csch(x)coth(x)
u=!0,n=new c("*","multiply",[e,new l("coth",[o.clone()])]);break;case"coth":// d/dx(coth(x)) = -csch(x)^2
u=!0,n=new c("^","pow",[new l("csch",[o.clone()]),v(2)]);break;case"asinh":// d/dx(asinh(x)) = 1 / sqrt(x^2 + 1)
s=!0,n=new l("sqrt",[new c("+","add",[new c("^","pow",[o.clone(),v(2)]),v(1)])]);break;case"acosh":// d/dx(acosh(x)) = 1 / sqrt(x^2 - 1); XXX potentially only for x >= 1 (the real spectrum)
s=!0,n=new l("sqrt",[new c("-","subtract",[new c("^","pow",[o.clone(),v(2)]),v(1)])]);break;case"atanh":// d/dx(atanh(x)) = 1 / (1 - x^2)
s=!0,n=new c("-","subtract",[v(1),new c("^","pow",[o.clone(),v(2)])]);break;case"asech":// d/dx(asech(x)) = -1 / (x*sqrt(1 - x^2))
s=!0,u=!0,n=new c("*","multiply",[o.clone(),new l("sqrt",[new c("-","subtract",[v(1),new c("^","pow",[o.clone(),v(2)])])])]);break;case"acsch":// d/dx(acsch(x)) = -1 / (|x|*sqrt(x^2 + 1))
s=!0,u=!0,n=new c("*","multiply",[new l("abs",[o.clone()]),new l("sqrt",[new c("+","add",[new c("^","pow",[o.clone(),v(2)]),v(1)])])]);break;case"acoth":// d/dx(acoth(x)) = -1 / (1 - x^2)
s=!0,u=!0,n=new c("-","subtract",[v(1),new c("^","pow",[o.clone(),v(2)])]);break;case"abs":// d/dx(abs(x)) = abs(x)/x
n=new c("/","divide",[new l(new p("abs"),[o.clone()]),o.clone()]);break;default:throw Error('Cannot process function "'+e.name+'" in derivative: the function is not supported, undefined, or the number of arguments passed to it are not supported')}s?(i="/",a="divide"):(i="*",a="multiply");/* Apply chain rule to all functions:
         F(x)  = f(g(x))
         F'(x) = g'(x)*f'(g(x)) */var f=y(o,t);return u&&(f=new c("-","unaryMinus",[f])),new c(i,a,[f,n])},"OperatorNode, Object":function(e,t){if(void 0!==t[e])return v(0);if("+"===e.op)return new c(e.op,e.fn,e.args.map(function(e){return y(e,t)}));if("-"===e.op){// d/dx(+/-f(x)) = +/-f'(x)
if(e.isUnary())return new c(e.op,e.fn,[y(e.args[0],t)]);// Linearity of differentiation, d/dx(f(x) +/- g(x)) = f'(x) +/- g'(x)
if(e.isBinary())return new c(e.op,e.fn,[y(e.args[0],t),y(e.args[1],t)])}if("*"===e.op){// d/dx(c*f(x)) = c*f'(x)
var r=e.args.filter(function(e){return void 0!==t[e]});if(r.length>0){var n=e.args.filter(function(e){return void 0===t[e]}),i=1===n.length?n[0]:new c("*","multiply",n);return new c("*","multiply",r.concat(y(i,t)))}// Product Rule, d/dx(f(x)*g(x)) = f'(x)*g(x) + f(x)*g'(x)
return new c("+","add",e.args.map(function(r){return new c("*","multiply",e.args.map(function(e){return e===r?y(e,t):e.clone()}))}))}if("/"===e.op&&e.isBinary()){var s=e.args[0],u=e.args[1];return(// d/dx(f(x) / c) = f'(x) / c
void 0!==t[u]?new c("/","divide",[y(s,t),u]):void 0!==t[s]?new c("*","multiply",[new c("-","unaryMinus",[s]),new c("/","divide",[y(u,t),new c("^","pow",[u.clone(),v(2)])])]):new c("/","divide",[new c("-","subtract",[new c("*","multiply",[y(s,t),u.clone()]),new c("*","multiply",[s.clone(),y(u,t)])]),new c("^","pow",[u.clone(),v(2)])]))}if("^"===e.op&&e.isBinary()){var f=e.args[0],p=e.args[1];if(void 0!==t[f])return(// If is secretly constant; 0^f(x) = 1 (in JS), 1^f(x) = 1
k(f)&&(o(f.value)||a(f.value,1))?v(0):new c("*","multiply",[e,new c("*","multiply",[new l("log",[f.clone()]),y(p.clone(),t)])]));if(void 0!==t[p]){if(k(p)){// If is secretly constant; f(x)^0 = 1 -> d/dx(1) = 0
if(o(p.value))return v(0);// Ignore exponent; f(x)^1 = f(x)
if(a(p.value,1))return y(f,t)}// Elementary Power Rule, d/dx(f(x)^c) = c*f'(x)*f(x)^(c-1)
var m=new c("^","pow",[f.clone(),new c("-","subtract",[p,v(1)])]);return new c("*","multiply",[p.clone(),new c("*","multiply",[y(f,t),m])])}// Functional Power Rule, d/dx(f^g) = f^g*[f'*(g/f) + g'ln(f)]
return new c("*","multiply",[new c("^","pow",[f.clone(),p.clone()]),new c("+","add",[new c("*","multiply",[y(f,t),new c("/","divide",[p.clone(),f.clone()])]),new c("*","multiply",[y(p,t),new l("log",[f.clone()])])])])}throw Error('Cannot process operator "'+e.op+'" in derivative: the operator is not supported, undefined, or the number of arguments passed to it are not supported')}});/**
   * Helper function to create a constant node with a specific type
   * (number, BigNumber, Fraction)
   * @param {number} value
   * @param {string} [valueType]
   * @return {ConstantNode}
   */function v(e,t){return new u(s(e,t||r.number))}return d}),rt="diff",rr=ta(rt,["typed","matrix","subtract","number"],e=>{var{typed:t,matrix:r,subtract:n,number:i}=e;/**
   * Create a new matrix or array of the difference between elements of the given array
   * The optional dim parameter lets you specify the dimension to evaluate the difference of
   * If no dimension parameter is passed it is assumed as dimension 0
   *
   * Dimension is zero-based in javascript and one-based in the parser and can be a number or bignumber
   * Arrays must be 'rectangular' meaning arrays like [1, 2]
   * If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays
   *
   * Syntax:
   *
   *     math.diff(arr)
   *     math.diff(arr, dim)
   *
   * Examples:
   *
   *     const arr = [1, 2, 4, 7, 0]
   *     math.diff(arr) // returns [1, 2, 3, -7] (no dimension passed so 0 is assumed)
   *     math.diff(math.matrix(arr)) // returns Matrix [1, 2, 3, -7]
   *
   *     const arr = [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [9, 8, 7, 6, 4]]
   *     math.diff(arr) // returns [[0, 0, 0, 0, 0], [8, 6, 4, 2, -1]]
   *     math.diff(arr, 0) // returns [[0, 0, 0, 0, 0], [8, 6, 4, 2, -1]]
   *     math.diff(arr, 1) // returns [[1, 1, 1, 1], [1, 1, 1, 1], [-1, -1, -1, -2]]
   *     math.diff(arr, math.bignumber(1)) // returns [[1, 1, 1, 1], [1, 1, 1, 1], [-1, -1, -1, -2]]
   *
   *     math.diff(arr, 2) // throws RangeError as arr is 2 dimensional not 3
   *     math.diff(arr, -1) // throws RangeError as negative dimensions are not allowed
   *
   *     // These will all produce the same result
   *     math.diff([[1, 2], [3, 4]])
   *     math.diff([math.matrix([1, 2]), math.matrix([3, 4])])
   *     math.diff([[1, 2], math.matrix([3, 4])])
   *     math.diff([math.matrix([1, 2]), [3, 4]])
   *     // They do not produce the same result as  math.diff(math.matrix([[1, 2], [3, 4]])) as this returns a matrix
   *
   * See Also:
   *
   *      sum
   *      subtract
   *      partitionSelect
   *
   * @param {Array | Matrix} arr      An array or matrix
   * @param {number | BigNumber} dim  Dimension
   * @return {Array | Matrix}         Difference between array elements in given dimension
   */return t(rt,{"Array | Matrix":function(e){return(// No dimension specified => assume dimension 0
g(e)?r(o(e.toArray())):o(e))},"Array | Matrix, number":function(e,t){if(!eh(t))throw RangeError("Dimension must be a whole number");return g(e)?r(a(e.toArray(),t)):a(e,t)},"Array, BigNumber":t.referTo("Array,number",e=>(t,r)=>e(t,i(r))),"Matrix, BigNumber":t.referTo("Matrix,number",e=>(t,r)=>e(t,i(r)))});/**
   * Recursively find the correct dimension in the array/matrix
   * Then Apply _diff to that dimension
   *
   * @param {Array} arr      The array
   * @param {number} dim     Dimension
   * @return {Array}         resulting array
   */function a(e,t){if(g(e)&&(e=e.toArray()),!Array.isArray(e))throw RangeError("Array/Matrix does not have that many dimensions");if(t>0){var r=[];return e.forEach(e=>{r.push(a(e,t-1))}),r}if(0===t)return o(e);throw RangeError("Cannot have negative dimension")}/**
   * Difference between elements in the array
   *
   * @param {Array} arr      An array
   * @return {Array}         resulting array
   */function o(e){for(var t=[],r=e.length,i=1;i<r;i++)t.push(/**
   * Difference between 2 objects
   *
   * @param {Object} obj1    First object
   * @param {Object} obj2    Second object
   * @return {Array}         resulting array
   */function e(t,r){g(t)&&(t=t.toArray()),g(r)&&(r=r.toArray());var i=Array.isArray(t),a=Array.isArray(r);if(i&&a)return(/**
   * Difference of elements in 2 arrays
   *
   * @param {Array} arr1     Array 1
   * @param {Array} arr2     Array 2
   * @return {Array}         resulting array
   */function(t,r){if(t.length!==r.length)throw RangeError("Not all sub-arrays have the same length");for(var n=[],i=t.length,a=0;a<i;a++)n.push(e(t[a],r[a]));return n}(t,r));if(!i&&!a)return n(r,t);// Difference is (second - first) NOT (first - second)
throw TypeError("Cannot calculate difference between 1 array and 1 non-array")}(e[i-1],e[i]));return t}});function rn(e){if(2===e.length&&y(e[0])){var t=(e=e.slice())[1];l(t)?e[1]=t-1:c(t)&&(e[1]=t.minus(1))}return e}var ri="diff",ra=ta(ri,["typed","matrix","subtract","number","bignumber"],e=>{var{typed:t,matrix:r,subtract:n,number:i,bignumber:a}=e,o=rr({typed:t,matrix:r,subtract:n,number:i,bignumber:a});/**
   * Attach a transform function to math.diff
   * Adds a property transform containing the transform function.
   *
   * This transform creates a range which includes the end value
   */return t(ri,{"...any":function(e){e=rn(e);try{return o.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0});class ro{constructor(e){this.wrappedObject=e}keys(){return Object.keys(this.wrappedObject)}get(e){return eu(this.wrappedObject,e)}set(e,t){return el(this.wrappedObject,e,t),this}has(e){return e in this.wrappedObject}}function rs(){return new Map}function ru(e){if(!e)return rs();if(rl(e))return e;if(M(e))return new ro(e);throw Error("createMap can create maps from objects or Maps")}function rl(e){return(// We can use the fast instanceof, or a slower duck typing check.
// The duck typing method needs to cover enough methods to not be confused with DenseMatrix.
!!e&&(e instanceof Map||e instanceof ro||"function"==typeof e.set&&"function"==typeof e.get&&"function"==typeof e.keys&&"function"==typeof e.has))}function rc(e){for(var t=arguments.length,r=Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];for(var i of r)if(i){if(rl(i))for(var a of i.keys())e.set(a,i.get(a));else if(M(i))for(var o of Object.keys(i))e.set(o,i[o])}return e}var rf="evaluate",rp=ta(rf,["typed","parse"],e=>{var{typed:t,parse:r}=e;/**
   * Evaluate an expression.
   *
   * Note the evaluating arbitrary expressions may involve security risks,
   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.
   *
   * Syntax:
   *
   *     math.evaluate(expr)
   *     math.evaluate(expr, scope)
   *     math.evaluate([expr1, expr2, expr3, ...])
   *     math.evaluate([expr1, expr2, expr3, ...], scope)
   *
   * Example:
   *
   *     math.evaluate('(2+3)/4')                // 1.25
   *     math.evaluate('sqrt(3^2 + 4^2)')        // 5
   *     math.evaluate('sqrt(-4)')               // 2i
   *     math.evaluate(['a=3', 'b=4', 'a*b'])    // [3, 4, 12]
   *
   *     let scope = {a:3, b:4}
   *     math.evaluate('a * b', scope)           // 12
   *
   * See also:
   *
   *    parse, compile
   *
   * @param {string | string[] | Matrix} expr   The expression to be evaluated
   * @param {Object} [scope]                    Scope to read/write variables
   * @return {*} The result of the expression
   * @throws {Error}
   */return t(rf,{string:function(e){var t=rs();return r(e).compile().evaluate(t)},"string, Map | Object":function(e,t){return r(e).compile().evaluate(t)},"Array | Matrix":function(e){var t=rs();return tq(e,function(e){return r(e).compile().evaluate(t)})},"Array | Matrix, Map | Object":function(e,t){return tq(e,function(e){return r(e).compile().evaluate(t)})}})}),rm={};function rd(t,r,n,i,a){if(!/*@__PURE__*/e(rm).isTypedFunction(t))return t(r,n,i);// invoke the typed callback function with the matching number of arguments only
var o=[r,n,i],s=/*@__PURE__*/e(rm).resolve(t,o);if(s)return p(s.implementation,o);var u=[r,n],l=/*@__PURE__*/e(rm).resolve(t,u);if(l)return p(l.implementation,u);var c=[r],f=/*@__PURE__*/e(rm).resolve(t,c);return f?p(f.implementation,c):p(t,o);/**
   * @param {function} signature The selected signature of the typed-function
   * @param {Array} args List with arguments to apply to the selected signature
   * @returns {*} Returns the return value of the invoked signature
   * @throws {TypeError} Throws an error when no matching signature was found
   */function p(e,o){try{return e.apply(e,o)}catch(e){var s;// Enrich the error message so the user understands that it took place inside the callback function
if(e instanceof TypeError&&(null===(s=e.data)||void 0===s?void 0:s.category)==="wrongType"){var u=[];throw u.push("value: ".concat(Y(r))),o.length>=2&&u.push("index: ".concat(Y(n))),o.length>=3&&u.push("array: ".concat(Y(i))),TypeError("Function ".concat(a," cannot apply callback arguments ")+"".concat(t.name,"(").concat(u.join(", "),") at index ").concat(JSON.stringify(n)))}throw TypeError("Function ".concat(a," cannot apply callback arguments ")+"to function ".concat(t.name,": ").concat(e.message))}}}function rh(e){for(var t=arguments.length,r=Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];return"function"==typeof e.createSubScope?rc(e.createSubScope(),...r):rc(rs(),e,...r)}function rg(e,t,r){// find an undefined symbol
var n=e.filter(function(e){return V(e)&&!(e.name in t)&&!r.has(e.name)})[0];if(!n)throw Error('No undefined variable found in inline expression "'+e+'"');// create a test function for this equation
var i=n.name,a=rh(r),o=e.compile();// variable name
return function(e){return a.set(i,e),o.evaluate(a)}}rm=function(){function e(){return!0}function t(){return!1}function r(){}let n="Argument is not a typed-function.";return(/**
   * @typedef {{
   *   params: Param[],
   *   fn: function,
   *   test: function,
   *   implementation: function
   * }} Signature
   *
   * @typedef {{
   *   types: Type[],
   *   hasAny: boolean,
   *   hasConversion: boolean,
   *   restParam: boolean
   * }} Param
   *
   * @typedef {{
   *   name: string,
   *   typeIndex: number,
   *   test: function,
   *   isAny: boolean,
   *   conversion?: ConversionDef,
   *   conversionIndex: number,
   * }} Type
   *
   * @typedef {{
   *   from: string,
   *   to: string,
   *   convert: function (*) : *
   * }} ConversionDef
   *
   * @typedef {{
   *   name: string,
   *   test: function(*) : boolean,
   *   isAny?: boolean
   * }} TypeDef
   *//**
   * @returns {() => function}
   */function i(){let a,o;// data type tests
/**
     * Returns true if the argument is a non-null "plain" object
     */function s(e){return"object"==typeof e&&null!==e&&e.constructor===Object}let u=[{name:"number",test:function(e){return"number"==typeof e}},{name:"string",test:function(e){return"string"==typeof e}},{name:"boolean",test:function(e){return"boolean"==typeof e}},{name:"Function",test:function(e){return"function"==typeof e}},{name:"Array",test:Array.isArray},{name:"Date",test:function(e){return e instanceof Date}},{name:"RegExp",test:function(e){return e instanceof RegExp}},{name:"Object",test:s},{name:"null",test:function(e){return null===e}},{name:"undefined",test:function(e){return void 0===e}}],l={name:"any",test:e,isAny:!0},c=0,f={createCount:0};/**
     * Takes a type name and returns the corresponding official type object
     * for that type.
     *
     * @param {string} typeName
     * @returns {TypeDef} type
     */function p(e){let t;let r=a.get(e);if(r)return r;// Remainder is error handling
let n='Unknown type "'+e+'"',i=e.toLowerCase();for(t of o)if(t.toLowerCase()===i){n+='. Did you mean "'+t+'" ?';break}throw TypeError(n)}/**
     * Adds an array `types` of type definitions to this typed instance.
     * Each type definition should be an object with properties:
     * 'name' - a string giving the name of the type; 'test' - function
     * returning a boolean that tests membership in the type; and optionally
     * 'isAny' - true only for the 'any' type.
     *
     * The second optional argument, `before`, gives the name of a type that
     * these types should be added before. The new types are added in the
     * order specified.
     * @param {TypeDef[]} types
     * @param {string | boolean} [beforeSpec='any'] before
     */function m(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"any",r=t?p(t).index:o.length,n=[];for(let t=0;t<e.length;++t){if(!e[t]||"string"!=typeof e[t].name||"function"!=typeof e[t].test)throw TypeError("Object with properties {name: string, test: function} expected");let i=e[t].name;if(a.has(i))throw TypeError('Duplicate type name "'+i+'"');n.push(i),a.set(i,{name:i,test:e[t].test,isAny:e[t].isAny,index:r+t,conversionsTo:[]// Newly added type can't have any conversions to it
})}// update the typeList
let i=o.slice(r);o=o.slice(0,r).concat(n).concat(i);// Fix the indices
for(let e=r+n.length;e<o.length;++e)a.get(o[e]).index=e}/**
     * Removes all types and conversions from this typed instance.
     * May cause previously constructed typed-functions to throw
     * strange errors when they are called with types that do not
     * match any of their signatures.
     */function d(){a=new Map,o=[],c=0,m([l],!1)}// initialize the types to the default list
/**
     * Find the type names that match a value.
     * @param {*} value
     * @return {string[]} Array of names of types for which
     *                  the type test matches the value.
     */function h(e){let t=o.filter(t=>{let r=a.get(t);return!r.isAny&&r.test(e)});return t.length?t:["any"]}/**
     * Check if an entity is a typed function created by any instance
     * @param {any} entity
     * @returns {boolean}
     */function g(e){return e&&"function"==typeof e&&"_typedFunctionData"in e}/**
     * Find a specific signature from a (composed) typed function, for example:
     *
     *   typed.findSignature(fn, ['number', 'string'])
     *   typed.findSignature(fn, 'number, string')
     *   typed.findSignature(fn, 'number,string', {exact: true})
     *
     * This function findSignature will by default return the best match to
     * the given signature, possibly employing type conversions.
     *
     * The (optional) third argument is a plain object giving options
     * controlling the signature search. Currently the only implemented
     * option is `exact`: if specified as true (default is false), only
     * exact matches will be returned (i.e. signatures for which `fn` was
     * directly defined). Note that a (possibly different) type matching
     * `any`, or one or more instances of TYPE matching `...TYPE` are
     * considered exact matches in this regard, as no conversions are used.
     *
     * This function returns a "signature" object, as does `typed.resolve()`,
     * which is a plain object with four keys: `params` (the array of parameters
     * for this signature), `fn` (the originally supplied function for this
     * signature), `test` (a generated function that determines if an argument
     * list matches this signature, and `implementation` (the function to call
     * on a matching argument list, that performs conversions if necessary and
     * then calls the originally supplied function).
     *
     * @param {Function} fn                   A typed-function
     * @param {string | string[]} signature
     *     Signature to be found, can be an array or a comma separated string.
     * @param {object} options  Controls the signature search as documented
     * @return {{ params: Param[], fn: function, test: function, implementation: function }}
     *     Returns the matching signature, or throws an error when no signature
     *     is found.
     */function y(e,t,r){let i,a;if(!g(e))throw TypeError(n);// Canonicalize input
let o=r&&r.exact,s=Array.isArray(t)?t.join(","):t,u=N(s),l=v(u);if(!o||l in e.signatures){// OK, we can check the internal signatures
let t=e._typedFunctionData.signatureMap.get(l);if(t)return t}// Oh well, we did not; so we have to go back and check the parameters
// one by one, in order to catch things like `any` and rest params.
// Note here we can assume there is at least one parameter, because
// the empty signature would have matched successfully above.
let c=u.length;if(o){let t;for(t in i=[],e.signatures)i.push(e._typedFunctionData.signatureMap.get(t))}else i=e._typedFunctionData.signatures;for(let e=0;e<c;++e){let t;let r=u[e],n=[];for(t of i){let i=E(t.params,e);if(i&&(!r.restParam||i.restParam)){if(!i.hasAny){// have to check all of the wanted types are available
let e=b(i);if(r.types.some(t=>!e.has(t.name)))continue}// OK, this looks good
n.push(t)}}if(0===(i=n).length)break}// Return the first remaining signature that was totally matched:
for(a of i)if(a.params.length<=c)return a;throw TypeError("Signature not found (signature: "+(e.name||"unnamed")+"("+v(u,", ")+"))")}/**
     * Stringify parameters in a normalized way
     * @param {Param[]} params
     * @param {string} [','] separator
     * @return {string}
     */function v(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:",";return e.map(e=>e.name).join(t)}/**
     * Expands a parsed parameter with the types available from currently
     * defined conversions.
     * @param {Param} param
     * @return {Param} param
     */function x(e){let t=e.types.map(e=>e.name),r=/**
     * Produce a list of all conversions from distinct types to one of
     * the given types.
     *
     * @param {string[]} typeNames
     * @return {ConversionDef[]} Returns the conversions that are available
     *                        resulting in any given type (if any)
     */function(e){if(0===e.length)return[];let t=e.map(p);e.length>1&&t.sort((e,t)=>e.index-t.index);let r=t[0].conversionsTo;if(1===e.length)return r;r=r.concat([]);// shallow copy the matches
// Since the types are now in index order, we just want the first
// occurrence of any from type:
let n=new Set(e);for(let e=1;e<t.length;++e){let i;for(i of t[e].conversionsTo)n.has(i.from)||(r.push(i),n.add(i.from))}return r}(t),n=e.hasAny,i=e.name,a=r.map(function(e){let t=p(e.from);return n=t.isAny||n,i+="|"+e.from,{name:e.from,typeIndex:t.index,test:t.test,isAny:t.isAny,conversion:e,conversionIndex:e.index}});return{types:e.types.concat(a),name:i,hasAny:n,hasConversion:a.length>0,restParam:e.restParam}}/**
     * Return the set of type names in a parameter.
     * Caches the result for efficiency
     *
     * @param {Param} param
     * @return {Set<string>} typenames
     */function b(e){return e.typeSet||(e.typeSet=new Set,e.types.forEach(t=>e.typeSet.add(t.name))),e.typeSet}/**
     * Parse a signature with comma separated parameters,
     * like "number | boolean, ...string"
     *
     * @param {string} signature
     * @return {Param[]} params
     */function N(e){let t=[];if("string"!=typeof e)throw TypeError("Signatures must be strings");let r=e.trim();if(""===r)return t;let n=r.split(",");for(let e=0;e<n.length;++e){let r=/**
     * Parse a parameter, like "...number | boolean"
     * @param {string} param
     * @return {Param} param
     */function(e){let t=0===e.indexOf("..."),r=t?e.length>3?e.slice(3):"any":e,n=r.split("|").map(e=>p(e.trim())),i=!1,a=t?"...":"",o=n.map(function(e){return i=e.isAny||i,a+=e.name+"|",{name:e.name,typeIndex:e.index,test:e.test,isAny:e.isAny,conversion:null,conversionIndex:-1}});return{types:o,name:a.slice(0,-1),hasAny:i,hasConversion:!1,restParam:t}}(n[e].trim());if(r.restParam&&e!==n.length-1)throw SyntaxError('Unexpected rest parameter "'+n[e]+'": only allowed for the last parameter');// if invalid, short-circuit (all the types may have been filtered)
if(0===r.types.length)return null;t.push(r)}return t}/**
     * Test whether a set of params contains a restParam
     * @param {Param[]} params
     * @return {boolean} Returns true when the last parameter is a restParam
     */function w(e){let t=q(e);return!!t&&t.restParam}/**
     * Create a type test for a single parameter, which can have one or multiple
     * types.
     * @param {Param} param
     * @return {function(x: *) : boolean} Returns a test function
     */function D(t){if(!t||0===t.types.length)return e;if(1===t.types.length)return p(t.types[0].name).test;if(2===t.types.length){let e=p(t.types[0].name).test,r=p(t.types[1].name).test;return function(t){return e(t)||r(t)}}{// param.types.length > 2
let e=t.types.map(function(e){return p(e.name).test});return function(t){for(let r=0;r<e.length;r++)if(e[r](t))return!0;return!1}}}/**
     * Find the parameter at a specific index of a Params list.
     * Handles rest parameters.
     * @param {Param[]} params
     * @param {number} index
     * @return {Param | null} Returns the matching parameter when found,
     *                        null otherwise.
     */function E(e,t){return t<e.length?e[t]:w(e)?q(e):null}/**
     * Get all type names of a parameter
     * @param {Params[]} params
     * @param {number} index
     * @return {string[]} Returns an array with type names
     */function A(e,t){let r=E(e,t);return r?b(r):new Set}/**
     * Test whether a type is an exact type or conversion
     * @param {Type} type
     * @return {boolean} Returns true when
     */function S(e){return null===e.conversion||void 0===e.conversion}/**
     * Helper function for creating error messages: create an array with
     * all available types on a specific argument index.
     * @param {Signature[]} signatures
     * @param {number} index
     * @return {string[]} Returns an array with available types
     */function C(e,t){let r=new Set;return e.forEach(e=>{let n;let i=A(e.params,t);for(n of i)r.add(n)}),r.has("any")?["any"]:Array.from(r)}/**
     * Create
     * @param {string} name             The name of the function
     * @param {array.<*>} args          The actual arguments passed to the function
     * @param {Signature[]} signatures  A list with available signatures
     * @return {TypeError} Returns a type error with additional data
     *                     attached to it in the property `data`
     */function M(e,t,r){let n,i,a;let o=e||"unnamed",s=r;// test for wrong type at some index
for(a=0;a<t.length;a++){let e=[];if(s.forEach(r=>{let n=E(r.params,a),i=D(n);(a<r.params.length||w(r.params))&&i(t[a])&&e.push(r)}),0===e.length){if(// no matching signatures anymore, throw error "wrong type"
(i=C(s,a)).length>0){let e=h(t[a]);return(n=TypeError("Unexpected type of argument in function "+o+" (expected: "+i.join(" or ")+", actual: "+e.join(" | ")+", index: "+a+")")).data={category:"wrongType",fn:o,index:a,actual:e,expected:i},n}}else s=e}// test for too few arguments
let u=s.map(function(e){return w(e.params)?1/0:e.params.length});if(t.length<Math.min.apply(null,u))return(n=TypeError("Too few arguments in function "+o+" (expected: "+(i=C(s,a)).join(" or ")+", index: "+t.length+")")).data={category:"tooFewArgs",fn:o,index:t.length,expected:i},n;// test for too many arguments
let l=Math.max.apply(null,u);if(t.length>l)return(n=TypeError("Too many arguments in function "+o+" (expected: "+l+", actual: "+t.length+")")).data={category:"tooManyArgs",fn:o,index:t.length,expectedLength:l},n;// Generic error
let c=[];for(let e=0;e<t.length;++e)c.push(h(t[e]).join("|"));return(n=TypeError('Arguments of type "'+c.join(", ")+'" do not match any of the defined signatures of function '+o+".")).data={category:"mismatch",actual:c},n}/**
     * Find the lowest index of all exact types of a parameter (no conversions)
     * @param {Param} param
     * @return {number} Returns the index of the lowest type in typed.types
     */function F(e){let t=o.length+1;for(let r=0;r<e.types.length;r++)S(e.types[r])&&(t=Math.min(t,e.types[r].typeIndex));return t}/**
     * Find the lowest index of the conversion of all types of the parameter
     * having a conversion
     * @param {Param} param
     * @return {number} Returns the lowest index of the conversions of this type
     */function B(e){let t=c+1;for(let r=0;r<e.types.length;r++)S(e.types[r])||(t=Math.min(t,e.types[r].conversionIndex));return t}/**
     * Compare two signatures
     * @param {Signature} signature1
     * @param {Signature} signature2
     * @return {number} returns a negative number when param1 must get a lower
     *                  index than param2, a positive number when the opposite,
     *                  or zero when both are equal
     */function T(e,t){let r,n;let i=e.params,a=t.params,o=q(i),s=q(a),u=w(i),l=w(a);// 1) An "any rest param" is least preferred
if(u&&o.hasAny){if(!l||!s.hasAny)return 1}else if(l&&s.hasAny)return -1;// 2) Minimize the number of 'any' parameters
let c=0,f=0;for(r of i)r.hasAny&&++c,r.hasConversion&&++f;let p=0,m=0;for(r of a)r.hasAny&&++p,r.hasConversion&&++m;if(c!==p)return c-p;// 3) A conversion rest param is less preferred
if(u&&o.hasConversion){if(!l||!s.hasConversion)return 1}else if(l&&s.hasConversion)return -1;// 4) Minimize the number of conversions
if(f!==m)return f-m;// 5) Prefer no rest param
if(u){if(!l)return 1}else if(l)return -1;// 6) Prefer shorter with rest param, longer without
let d=(i.length-a.length)*(u?-1:1);if(0!==d)return d;// Signatures are identical in each of the above metrics.
// In particular, they are the same length.
// We can therefore compare the parameters one by one.
// First we count which signature has more preferred parameters.
let h=[],g=0;for(let e=0;e<i.length;++e){let t=/**
     * Compare two params
     * @param {Param} param1
     * @param {Param} param2
     * @return {number} returns -1 when param1 must get a lower
     *                  index than param2, 1 when the opposite,
     *                  or zero when both are equal
     */function(e,t){// We compare a number of metrics on a param in turn:
// 1) 'any' parameters are the least preferred
if(e.hasAny){if(!t.hasAny)return 1}else if(t.hasAny)return -1;// 2) Prefer non-rest to rest parameters
if(e.restParam){if(!t.restParam)return 1}else if(t.restParam)return -1;// 3) Prefer exact type match to conversions
if(e.hasConversion){if(!t.hasConversion)return 1}else if(t.hasConversion)return -1;// 4) Prefer lower type index:
let r=F(e)-F(t);if(r<0)return -1;if(r>0)return 1;// 5) Prefer lower conversion index
let n=B(e)-B(t);return n<0?-1:n>0?1:0}(i[e],a[e]);h.push(t),g+=t}if(0!==g)return g;for(n of h)if(0!==n)return n;// It's a tossup:
return 0}/**
     * Compile conversion for a parameter to the right type
     * @param {Param} param
     * @return {function} Returns the wrapped function that will convert arguments
     *
     */function O(e){let t,r,n,i;let a=[],o=[];switch(e.types.forEach(function(e){e.conversion&&(a.push(p(e.conversion.from).test),o.push(e.conversion.convert))}),o.length){case 0:return function(e){return e};case 1:return t=a[0],n=o[0],function(e){return t(e)?n(e):e};case 2:return t=a[0],r=a[1],n=o[0],i=o[1],function(e){return t(e)?n(e):r(e)?i(e):e};default:return function(e){for(let t=0;t<o.length;t++)if(a[t](e))return o[t](e);return e}}}/**
     * Action to take on mismatch
     * @param {string} name      Name of function that was attempted to be called
     * @param {Array} args       Actual arguments to the call
     * @param {Array} signatures Known signatures of the named typed-function
     */function _(e,t,r){throw M(e,t,r)}/**
     * Return all but the last items of an array or function Arguments
     * @param {Array | Arguments} arr
     * @return {Array}
     */function z(e){return k(e,0,e.length-1)}/**
     * return the last item of an array or function Arguments
     * @param {Array | Arguments} arr
     * @return {*}
     */function q(e){return e[e.length-1]}/**
     * Slice an array or function Arguments
     * @param {Array | Arguments | IArguments} arr
     * @param {number} start
     * @param {number} [end]
     * @return {Array}
     */function k(e,t,r){return Array.prototype.slice.call(e,t,r)}function I(e,t){return{referTo:{references:e,callback:t}}}/**
     * Create a reference callback to the typed-function itself
     *
     * @param {(self: function) => function} callback
     * @returns {{referToSelf: { callback: function }}}
     */function R(e){if("function"!=typeof e)throw TypeError("Callback function expected as first argument");return{referToSelf:{callback:e}}}/**
     * Test whether something is a referTo object, holding a list with reference
     * signatures and a callback.
     *
     * @param {Object | function} objectOrFn
     * @returns {boolean}
     */function P(e){return e&&"object"==typeof e.referTo&&Array.isArray(e.referTo.references)&&"function"==typeof e.referTo.callback}/**
     * Test whether something is a referToSelf object, holding a callback where
     * to pass `self`.
     *
     * @param {Object | function} objectOrFn
     * @returns {boolean}
     */function j(e){return e&&"object"==typeof e.referToSelf&&"function"==typeof e.referToSelf.callback}/**
     * Check if name is (A) new, (B) a match, or (C) a mismatch; and throw
     * an error in case (C).
     *
     * @param { string | undefined } nameSoFar
     * @param { string | undefined } newName
     * @returns { string } updated name
     */function U(e,t){if(!e)return t;if(t&&t!==e){let r=Error("Function names do not match (expected: "+e+", actual: "+t+")");throw r.data={actual:t,expected:e},r}return e}d(),m(u);let L=f;/**
     * Verify that the ConversionDef conversion has a valid format.
     *
     * @param {conversionDef} conversion
     * @return {void}
     * @throws {TypeError|SyntaxError}
     */function $(e){if(!e||"string"!=typeof e.from||"string"!=typeof e.to||"function"!=typeof e.convert)throw TypeError("Object with properties {from: string, to: string, convert: function} expected");if(e.to===e.from)throw SyntaxError('Illegal to define conversion from "'+e.from+'" to itself.')}return(/**
     * Originally the main function was a typed function itself, but then
     * it might not be able to generate error messages if the client
     * replaced the type system with different names.
     *
     * Main entry: typed([name], functions/objects with signatures...)
     *
     * Assembles and returns a new typed-function from the given items
     * that provide signatures and implementations, each of which may be
     * * a plain object mapping (string) signatures to implementing functions,
     * * a previously constructed typed function, or
     * * any other single function with a string-valued property `signature`.
      * The name of the resulting typed-function will be given by the
     * string-valued name argument if present, or if not, by the name
     * of any of the arguments that have one, as long as any that do are
     * consistent with each other. If no name is specified, the name will be
     * an empty string.
     *
     * @param {string} maybeName [optional]
     * @param {(function|object)[]} signature providers
     * @returns {typed-function}
     */(f=function(e){let n="string"==typeof e,i=n?1:0,a=n?e:"",o={};for(let e=i;e<arguments.length;++e){let t;let r=arguments[e],i={};if("function"==typeof r?(t=r.name,"string"==typeof r.signature?i[r.signature]=r:g(r)&&(i=r.signatures)):s(r)&&(// Case 3: Plain object, assume keys = signatures, values = functions
i=r,n||(t=/**
     * Retrieve the implied name from an object with signature keys
     * and function values, checking whether all value names match
     *
     * @param { {string: function} } obj
     */function(e){let t;for(let r in e)// are typed functions or functions with a signature property
Object.prototype.hasOwnProperty.call(e,r)&&(g(e[r])||"string"==typeof e[r].signature)&&(t=U(t,e[r].name));return t}(r))),0===Object.keys(i).length){let t=TypeError("Argument to 'typed' at index "+e+" is not a (typed) function, nor an object with signatures as keys and functions as values.");throw t.data={index:e,argument:r},t}n||(a=U(a,t)),/**
     * Copy all of the signatures from the second argument into the first,
     * which is modified by side effect, checking for conflicts
     *
     * @param {Object.<string, function|typed-reference>} dest
     * @param {Object.<string, function|typed-reference>} source
     */function(e,t){let r;for(r in t)if(Object.prototype.hasOwnProperty.call(t,r)){if(r in e&&t[r]!==e[r]){let n=Error('Signature "'+r+'" is defined twice');throw n.data={signature:r,sourceFunction:t[r],destFunction:e[r]},n}e[r]=t[r]}}(o,i)}return(/**
     * Create a typed function
     * @param {String} name               The name for the typed function
     * @param {Object.<string, function>} rawSignaturesMap
     *                                    An object with one or
     *                                    multiple signatures as key, and the
     *                                    function corresponding to the
     *                                    signature as value.
     * @return {function}  Returns the created typed function.
     */function(e,n){let i,a;if(f.createCount++,0===Object.keys(n).length)throw SyntaxError("No signatures provided");f.warnAgainstDeprecatedThis&&/**
     * Validate whether any of the function bodies contains a self-reference
     * usage like `this(...)` or `this.signatures`. This self-referencing is
     * deprecated since typed-function v3. It has been replaced with
     * the functions typed.referTo and typed.referToSelf.
     * @param {Object.<string, function>} signaturesMap
     */function(e){// TODO: remove this deprecation warning logic some day (it's introduced in v3)
// match occurrences like 'this(' and 'this.signatures'
let t=/\bthis(\(|\.signatures\b)/;Object.keys(e).forEach(r=>{let n=e[r];if(t.test(n.toString()))throw SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.")})}(n);// Main processing loop for signatures
let o=[],s=[],u={},l=[];for(i in n){let e;// A) Protect against polluted Object prototype:
if(!Object.prototype.hasOwnProperty.call(n,i))continue;// B) Parse the signature
let t=N(i);if(!t)continue;// C) Check for conflicts
o.forEach(function(e){if(/**
     * Test whether two param lists represent conflicting signatures
     * @param {Param[]} params1
     * @param {Param[]} params2
     * @return {boolean} Returns true when the signatures conflict, false otherwise.
     */function(e,t){let r=Math.max(e.length,t.length);for(let n=0;n<r;n++){let r;let i=A(e,n),a=A(t,n),o=!1;for(r of a)if(i.has(r)){o=!0;break}if(!o)return!1}let n=e.length,i=t.length,a=w(e),o=w(t);return a?o?n===i:i>=n:o?n>=i:n===i}(e,t))throw TypeError('Conflicting signatures "'+v(e)+'" and "'+v(t)+'".')}),o.push(t);let r=s.length;s.push(n[i]);let a=t.map(x);// E) Split the signatures and collect them up
for(e of function e(t,r,n){if(!(r<t.length))return[n];{var i,a;let o=t[r],s=[];if(o.restParam){// split the types of a rest parameter in two:
// one with only exact types, and one with exact types and conversions
let e=o.types.filter(S);e.length<o.types.length&&s.push({types:e,name:"..."+e.map(e=>e.name).join("|"),hasAny:e.some(e=>e.isAny),hasConversion:!1,restParam:!0}),s.push(o)}else s=o.types.map(function(e){return{types:[e],name:e.name,hasAny:e.isAny,hasConversion:e.conversion,restParam:!1}});// recurse over the groups with types
return i=s,a=function(i){return e(t,r+1,n.concat([i]))},Array.prototype.concat.apply([],i.map(a))}}(a,0,[])){let t=v(e);l.push({params:e,name:t,fn:r}),e.every(e=>!e.hasConversion)&&(u[t]=r)}}l.sort(T);let c=/**
     * Resolve any references in the functionList for the typed function
     * itself. The signatureMap tells which index in the functionList a
     * given signature should be mapped to (for use in resolving typed.referTo)
     * and self provides the destions of a typed.referToSelf.
     *
     * @param {Array<function | typed-reference-object>} functionList
     * @param {Object.<string, function>} signatureMap
     * @param {function} self  The typed-function itself
     * @return {Array<function>} The list of resolved functions
     */function(e,t,r){let n=e.map(e=>j(e)?R(e.referToSelf.callback):P(e)?I(e.referTo.references,e.referTo.callback):e),i=Array(n.length).fill(!1),a=!0;for(;a;){a=!1;let e=!0;for(let o=0;o<n.length;++o){if(i[o])continue;let s=n[o];if(j(s))n[o]=s.referToSelf.callback(r),n[o].referToSelf=s.referToSelf,i[o]=!0,e=!1;else if(P(s)){let r=/**
     * Take a list of references, a list of functions functionList, and a
     * signatureMap indexing signatures into functionList, and return
     * the list of resolutions, or a false-y value if they don't all
     * resolve in a valid way (yet).
     *
     * @param {string[]} references
     * @param {Array<function|typed-reference} functionList
     * @param {Object.<string, integer>} signatureMap
     * @return {function[] | false} resolutions
     */function(e,t,r){let n;let i=[];for(n of e){let e=r[n];if("number"!=typeof e)throw TypeError('No definition for referenced signature "'+n+'"');if("function"!=typeof(e=t[e]))return!1;i.push(e)}return i}(s.referTo.references,n,t);r?(n[o]=s.referTo.callback.apply(this,r),n[o].referTo=s.referTo,i[o]=!0,e=!1):a=!0}}if(e&&a)throw SyntaxError("Circular reference detected in resolving typed.referTo")}return n}(s,u,ef);// Fill in the proper function for each signature
for(a in u)Object.prototype.hasOwnProperty.call(u,a)&&(u[a]=c[u[a]]);let p=[],m=new Map;for(a of l)// _after_ the signature sorting step above; otherwise we might
// remove the wrong one.
m.has(a.name)||(a.fn=c[a.fn],p.push(a),m.set(a.name,a));// we create a highly optimized checks for the first couple of signatures with max 2 arguments
let d=p[0]&&p[0].params.length<=2&&!w(p[0].params),h=p[1]&&p[1].params.length<=2&&!w(p[1].params),g=p[2]&&p[2].params.length<=2&&!w(p[2].params),y=p[3]&&p[3].params.length<=2&&!w(p[3].params),b=p[4]&&p[4].params.length<=2&&!w(p[4].params),E=p[5]&&p[5].params.length<=2&&!w(p[5].params);for(let e=0;e<p.length;++e)p[e].test=/**
     * Create a test for all parameters of a signature
     * @param {Param[]} params
     * @return {function(args: Array<*>) : boolean}
     */function(e){let t,r,n;if(w(e)){// variable arguments like '...number'
t=z(e).map(D);let r=t.length,n=D(q(e)),i=function(e){for(let t=r;t<e.length;t++)if(!n(e[t]))return!1;return!0};return function(e){for(let r=0;r<t.length;r++)if(!t[r](e[r]))return!1;return i(e)&&e.length>=r+1}}return(// no variable arguments
0===e.length?function(e){return 0===e.length}:1===e.length?(r=D(e[0]),function(e){return r(e[0])&&1===e.length}):2===e.length?(r=D(e[0]),n=D(e[1]),function(e){return r(e[0])&&n(e[1])&&2===e.length}):(// arguments.length > 2
t=e.map(D),function(e){for(let r=0;r<t.length;r++)if(!t[r](e[r]))return!1;return e.length===t.length}))}(p[e].params);let C=d?D(p[0].params[0]):t,M=h?D(p[1].params[0]):t,F=g?D(p[2].params[0]):t,B=y?D(p[3].params[0]):t,_=b?D(p[4].params[0]):t,U=E?D(p[5].params[0]):t,L=d?D(p[0].params[1]):t,$=h?D(p[1].params[1]):t,H=g?D(p[2].params[1]):t,Z=y?D(p[3].params[1]):t,G=b?D(p[4].params[1]):t,V=E?D(p[5].params[1]):t;for(let e=0;e<p.length;++e)p[e].implementation=/**
     * Preprocess arguments before calling the original function:
     * - if needed convert the parameters
     * - in case of rest parameters, move the rest parameters into an Array
     * @param {Param[]} params
     * @param {function} fn
     * @return {function} Returns a wrapped function
     */function(e,t){let r=t;// TODO: can we make this wrapper function smarter/simpler?
if(e.some(e=>e.hasConversion)){let n=w(e),i=e.map(O);r=function(){let e=[],r=n?arguments.length-1:arguments.length;for(let t=0;t<r;t++)e[t]=i[t](arguments[t]);return n&&(e[r]=arguments[r].map(i[r])),t.apply(this,e)}}let n=r;if(w(e)){let t=e.length-1;n=function(){return r.apply(this,k(arguments,0,t).concat([k(arguments,t)]))}}return n}(p[e].params,p[e].fn);let W=d?p[0].implementation:r,Y=h?p[1].implementation:r,J=g?p[2].implementation:r,X=y?p[3].implementation:r,Q=b?p[4].implementation:r,K=E?p[5].implementation:r,ee=d?p[0].params.length:-1,et=h?p[1].params.length:-1,er=g?p[2].params.length:-1,en=y?p[3].params.length:-1,ei=b?p[4].params.length:-1,ea=E?p[5].params.length:-1,eo=d&&h&&g&&y&&b&&E?6:0,es=p.length,eu=p.map(e=>e.test),el=p.map(e=>e.implementation),ec=function(){for(let e=eo;e<es;e++)if(eu[e](arguments))return el[e].apply(this,arguments);return f.onMismatch(e,arguments,p)};// fast, specialized version. Falls back to the slower, generic one if needed
function ef(e,t){return arguments.length===ee&&C(e)&&L(t)?W.apply(this,arguments):arguments.length===et&&M(e)&&$(t)?Y.apply(this,arguments):arguments.length===er&&F(e)&&H(t)?J.apply(this,arguments):arguments.length===en&&B(e)&&Z(t)?X.apply(this,arguments):arguments.length===ei&&_(e)&&G(t)?Q.apply(this,arguments):arguments.length===ea&&U(e)&&V(t)?K.apply(this,arguments):ec.apply(this,arguments)}// attach name the typed function
try{Object.defineProperty(ef,"name",{value:e})}catch(e){// the function name is not essential for the functioning, it's mostly useful for debugging,
// so it's fine to have unnamed functions.
}// attach signatures to the function.
return(// This property is close to the original collection of signatures
// used to create the typed-function, just with unions split:
ef.signatures=u,// Also serves as the flag that this is a typed-function
ef._typedFunctionData={signatures:p,signatureMap:m},ef)}(a||"",o))}).create=i,f.createCount=L.createCount,f.onMismatch=_,f.throwMismatchError=_,f.createError=M,f.clear=d,f.clearConversions=/**
     * Removes all conversions, leaving the types alone.
     */function(){let e;for(e of o)a.get(e).conversionsTo=[];c=0},f.addTypes=m,f._findType=p,f.referTo=/**
     * Create a reference callback to one or multiple signatures
     *
     * Syntax:
     *
     *     typed.referTo(signature1, signature2, ..., function callback(fn1, fn2, ...) {
     *       // ...
     *     })
     *
     * @returns {{referTo: {references: string[], callback}}}
     */function(){let e=z(arguments).map(e=>v(N(e))),t=q(arguments);if("function"!=typeof t)throw TypeError("Callback function expected as last argument");return I(e,t)},f.referToSelf=R,f.convert=/**
     * Convert a given value to another data type, specified by type name.
     *
     * @param {*} value
     * @param {string} typeName
     */function(e,t){// check conversion is needed
let r=p(t);if(r.test(e))return e;let n=r.conversionsTo;if(0===n.length)throw Error("There are no conversions to "+t+" defined.");for(let t=0;t<n.length;t++){let r=p(n[t].from);if(r.test(e))return n[t].convert(e)}throw Error("Cannot convert "+e+" to "+t)},f.findSignature=y,f.find=/**
     * Find the proper function to call for a specific signature from
     * a (composed) typed function, for example:
     *
     *   typed.find(fn, ['number', 'string'])
     *   typed.find(fn, 'number, string')
     *   typed.find(fn, 'number,string', {exact: true})
     *
     * This function find will by default return the best match to
     * the given signature, possibly employing type conversions (and returning
     * a function that will perform those conversions as needed). The
     * (optional) third argument is a plain object giving options contolling
     * the signature search. Currently only the option `exact` is implemented,
     * which defaults to "false". If `exact` is specified as true, then only
     * exact matches will be returned (i.e. signatures for which `fn` was
     * directly defined). Uses of `any` and `...TYPE` are considered exact if
     * no conversions are necessary to apply the corresponding function.
     *
     * @param {Function} fn                   A typed-function
     * @param {string | string[]} signature
     *     Signature to be found, can be an array or a comma separated string.
     * @param {object} options  Controls the signature match as documented
     * @return {function}
     *     Returns the function to call for the given signature, or throws an
     *     error if no match is found.
     */function(e,t,r){return y(e,t,r).implementation},f.isTypedFunction=g,f.warnAgainstDeprecatedThis=!0,/**
     * add a type (convenience wrapper for typed.addTypes)
     * @param {{name: string, test: function}} type
     * @param {boolean} [beforeObjectTest=true]
     *                          If true, the new test will be inserted before
     *                          the test with name 'Object' (if any), since
     *                          tests for Object match Array and classes too.
     */f.addType=function(e,t){let r="any";!1!==t&&a.has("Object")&&(r="Object"),f.addTypes([e],r)},/**
     * Add a conversion
     *
     * @param {ConversionDef} conversion
     * @returns {void}
     * @throws {TypeError}
     */f.addConversion=function(e){$(e);let t=p(e.to);if(t.conversionsTo.every(function(t){return t.from!==e.from}))t.conversionsTo.push({from:e.from,convert:e.convert,index:c++});else throw Error('There is already a conversion from "'+e.from+'" to "'+t.name+'"')},/**
     * Convenience wrapper to call addConversion on each conversion in a list.
     *
     @param {ConversionDef[]} conversions
     @returns {void}
     @throws {TypeError}
     */f.addConversions=function(e){e.forEach(f.addConversion)},/**
     * Remove the specified conversion. The format is the same as for
     * addConversion, and the convert function must match or an error
     * is thrown.
     *
     * @param {{from: string, to: string, convert: function}} conversion
     * @returns {void}
     * @throws {TypeError|SyntaxError|Error}
     */f.removeConversion=function(e){$(e);let t=p(e.to),r=/**
     * Return the first item from an array for which test(arr[i]) returns true
     * @param {Array} arr
     * @param {function} test
     * @return {* | undefined} Returns the first matching item
     *                         or undefined when there is no match
     */function(e,t){for(let r=0;r<e.length;r++)if(t(e[r]))return e[r]}(t.conversionsTo,t=>t.from===e.from);if(!r)throw Error("Attempt to remove nonexistent conversion from "+e.from+" to "+e.to);if(r.convert!==e.convert)throw Error("Conversion to remove does not match existing conversion");let n=t.conversionsTo.indexOf(r);t.conversionsTo.splice(n,1)},/**
     * Produce the specific signature that a typed function
     * will execute on the given arguments. Here, a "signature" is an
     * object with properties 'params', 'test', 'fn', and 'implementation'.
     * This last property is a function that converts params as necessary
     * and then calls 'fn'. Returns null if there is no matching signature.
     * @param {typed-function} tf
     * @param {any[]} argList
     * @returns {{params: string, test: function, fn: function, implementation: function}}
     */f.resolve=function(e,t){if(!g(e))throw TypeError(n);let r=e._typedFunctionData.signatures;for(let e=0;e<r.length;++e)if(r[e].test(t))return r[e];return null},f)}())}();var ry=ta("filter",["typed"],e=>{var{typed:t}=e;/**
   * Attach a transform function to math.filter
   * Adds a property transform containing the transform function.
   *
   * This transform adds support for equations as test function for math.filter,
   * so you can do something like 'filter([3, -2, 5], x > 0)'.
   */function r(e,t,r){var i,a;return e[0]&&(i=e[0].compile().evaluate(r)),e[1]&&(a=V(e[1])||R(e[1])?e[1].compile().evaluate(r):rg(e[1],t,r)),n(i,a)}r.rawArgs=!0;// one based version of function filter
var n=t("filter",{"Array, function":rv,"Matrix, function":function(e,t){return e.create(rv(e.toArray(),t))},"Array, RegExp":e6,"Matrix, RegExp":function(e,t){return e.create(e6(e.toArray(),t))}});return r},{isTransformFunction:!0});/**
 * Filter values in a callback given a callback function
 *
 * !!! Passes a one-based index !!!
 *
 * @param {Array} x
 * @param {Function} callback
 * @return {Array} Returns the filtered array
 * @private
 */function rv(e,t){return e8(e,function(e,r,n){// invoke the callback function with the right number of arguments
return rd(t,e,[r+1],n,"filter")})}var rx=ta("forEach",["typed"],e=>{var{typed:t}=e;/**
   * Attach a transform function to math.forEach
   * Adds a property transform containing the transform function.
   *
   * This transform creates a one-based index instead of a zero-based index
   */function r(e,t,r){var i,a;return e[0]&&(i=e[0].compile().evaluate(r)),e[1]&&(a=V(e[1])||R(e[1])?e[1].compile().evaluate(r):rg(e[1],t,r)),n(i,a)}r.rawArgs=!0;// one-based version of forEach
var n=t("forEach",{"Array | Matrix, function":function(e,t){!function r(n,i){if(!Array.isArray(n))return rd(t,n,i,e,"forEach");e5(n,function(e,t){// we create a copy of the index array and append the new index value
r(e,i.concat(t+1));// one based index, hence i+1
})}(e.valueOf(),[]);// pass Array
}});return r},{isTransformFunction:!0}),rb=new Set(["end"]),rN="FunctionAssignmentNode",rw=ta(rN,["typed","Node"],t=>{var{typed:r,Node:Node}=t;/**
   * Is parenthesis needed?
   * @param {Node} node
   * @param {Object} parenthesis
   * @param {string} implicit
   * @private
   */function n(e,t,r){var n=tx(e,t,r),i=tx(e.expr,t,r);return"all"===t||null!==i&&i<=n}class i extends Node{/**
     * @constructor FunctionAssignmentNode
     * @extends {Node}
     * Function assignment
     *
     * @param {string} name           Function name
     * @param {string[] | Array.<{name: string, type: string}>} params
     *                                Array with function parameter names, or an
     *                                array with objects containing the name
     *                                and type of the parameter
     * @param {Node} expr             The function expression
     */constructor(e,t,r){// validate input
if(super(),"string"!=typeof e)throw TypeError('String expected for parameter "name"');if(!Array.isArray(t))throw TypeError('Array containing strings or objects expected for parameter "params"');if(!U(r))throw TypeError('Node expected for parameter "expr"');if(rb.has(e))throw Error('Illegal function name, "'+e+'" is a reserved keyword');var n=new Set;for(var i of t){var a="string"==typeof i?i:i.name;if(n.has(a))throw Error('Duplicate parameter name "'.concat(a,'"'));n.add(a)}this.name=e,this.params=t.map(function(e){return e&&e.name||e}),this.types=t.map(function(e){return e&&e.type||"any"}),this.expr=r}get type(){return rN}get isFunctionAssignmentNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){var n=Object.create(t);e5(this.params,function(e){n[e]=!0});// compile the function expression with the child args
var i=this.expr._compile(e,n),a=this.name,o=this.params,s=e7(this.types,","),u=a+"("+e7(this.params,", ")+")";return function(e,t,n){var l={};l[s]=function(){for(var r=Object.create(t),a=0;a<o.length;a++)r[o[a]]=arguments[a];return i(e,r,n)};var c=r(a,l);return c.syntax=u,e.set(a,c),c}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){e(this.expr,"expr",this)}/**
     * Create a new FunctionAssignmentNode whose children are the results of
     * calling the provided callback function for each child of the original
     * node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
     */map(e){var t=this._ifNode(e(this.expr,"expr",this));return new i(this.name,this.params.slice(0),t)}/**
     * Create a clone of this node, a shallow copy
     * @return {FunctionAssignmentNode}
     */clone(){return new i(this.name,this.params.slice(0),this.expr)}/**
     * get string representation
     * @param {Object} options
     * @return {string} str
     */_toString(e){var t=e&&e.parenthesis?e.parenthesis:"keep",r=this.expr.toString(e);return n(this,t,e&&e.implicit)&&(r="("+r+")"),this.name+"("+this.params.join(", ")+") = "+r}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){var e=this.types;return{mathjs:rN,name:this.name,params:this.params.map(function(t,r){return{name:t,type:e[r]}}),expr:this.expr}}/**
     * Instantiate an FunctionAssignmentNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "FunctionAssignmentNode",
     *      name: ..., params: ..., expr: ...}
     *     ```
     *     where mathjs is optional
     * @returns {FunctionAssignmentNode}
     */static fromJSON(e){return new i(e.name,e.params,e.expr)}/**
     * get HTML representation
     * @param {Object} options
     * @return {string} str
     */toHTML(e){for(var t=e&&e.parenthesis?e.parenthesis:"keep",r=[],i=0;i<this.params.length;i++)r.push('<span class="math-symbol math-parameter">'+eL(this.params[i])+"</span>");var a=this.expr.toHTML(e);return n(this,t,e&&e.implicit)&&(a='<span class="math-parenthesis math-round-parenthesis">(</span>'+a+'<span class="math-parenthesis math-round-parenthesis">)</span>'),'<span class="math-function">'+eL(this.name)+'</span><span class="math-parenthesis math-round-parenthesis">(</span>'+r.join('<span class="math-separator">,</span>')+'<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>'+a}/**
     * get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */_toTex(e){var t=e&&e.parenthesis?e.parenthesis:"keep",r=this.expr.toTex(e);return n(this,t,e&&e.implicit)&&(r="\\left(".concat(r,"\\right)")),"\\mathrm{"+this.name+"}\\left("+this.params.map(t1).join(",")+"\\right)="+r}}return /*@__PURE__*/e(et)(i,"name",rN),i},{isClass:!0,isNode:!0}),rD="FunctionNode",rE=ta(rD,["math","Node","SymbolNode"],t=>{var{math:r,Node:Node,SymbolNode:n}=t,i=e=>eP(e,{truncate:78});/*
   * Expand a LaTeX template
   *
   * @param {string} template
   * @param {Node} node
   * @param {Object} options
   * @private
   **/function a(e,t,r){for(var n,i="",a=/\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi,o=0;null!==(n=a.exec(e));)if(// go through all matches
// add everything in front of the match to the LaTeX string
i+=e.substring(o,n.index),o=n.index,"$$"===n[0])// escaped dollar sign
i+="$",o++;else{// template parameter
o+=n[0].length;var s=t[n[1]];if(!s)throw ReferenceError("Template: Property "+n[1]+" does not exist.");if(void 0===n[2])switch(typeof s){case"string":i+=s;break;case"object":if(U(s))i+=s.toTex(r);else if(Array.isArray(s))i+=s.map(function(e,t){if(U(e))return e.toTex(r);throw TypeError("Template: "+n[1]+"["+t+"] is not a Node.")}).join(",");else throw TypeError("Template: "+n[1]+" has to be a Node, String or array of Nodes");break;default:throw TypeError("Template: "+n[1]+" has to be a Node, String or array of Nodes")}else // with square brackets
if(U(s[n[2]]&&s[n[2]]))i+=s[n[2]].toTex(r);else throw TypeError("Template: "+n[1]+"["+n[2]+"] is not a Node.")}return i+e.slice(o)}class o extends Node{/**
     * @constructor FunctionNode
     * @extends {./Node}
     * invoke a list with arguments on a node
     * @param {./Node | string} fn
     *     Item resolving to a function on which to invoke
     *     the arguments, typically a SymboNode or AccessorNode
     * @param {./Node[]} args
     */constructor(e,t){// validate input
if(super(),"string"==typeof e&&(e=new n(e)),!U(e))throw TypeError('Node expected as parameter "fn"');if(!Array.isArray(t)||!t.every(U))throw TypeError('Array containing Nodes expected for parameter "args"');this.fn=e,this.args=t||[]}// readonly property name
get name(){return this.fn.name||""}get type(){return rD}get isFunctionNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){// compile arguments
var r=this.args.map(r=>r._compile(e,t));if(V(this.fn)){var n=this.fn.name;if(t[n]){// the function symbol is an argName
var a=this.args;return function(t,o,s){var u=eu(o,n);if("function"!=typeof u)throw TypeError("Argument '".concat(n,"' was not a function; received: ").concat(i(u)));if(u.rawArgs)return u(a,e,rh(t,o),t);var l=r.map(e=>e(t,o,s));return u.apply(u,l)}}// we can statically determine whether the function
// has the rawArgs property
var s=n in e?eu(e,n):void 0,u="function"==typeof s&&!0===s.rawArgs,l=t=>{var r;if(t.has(n))r=t.get(n);else{if(!(n in e))return o.onUndefinedFunction(n);r=eu(e,n)}if("function"==typeof r)return r;throw TypeError("'".concat(n,"' is not a function; its value is:\n  ").concat(i(r)))};if(u){// pass unevaluated parameters (nodes) to the function
// "raw" evaluation
var c=this.args;return function(t,r,n){return l(t)(c,e,rh(t,r),t)}}switch(r.length){case 0:return function(e,t,r){return l(e)()};case 1:return function(e,t,n){return l(e)((0,r[0])(e,t,n))};case 2:return function(e,t,n){var i=l(e),a=r[0],o=r[1];return i(a(e,t,n),o(e,t,n))};default:return function(e,t,n){return l(e)(...r.map(r=>r(e,t,n)))}}}else if(T(this.fn)&&j(this.fn.index)&&this.fn.index.isObjectProperty()){// execute the function with the right context:
// the object of the AccessorNode
var f=this.fn.object._compile(e,t),p=this.fn.index.getObjectProperty(),m=this.args;return function(t,n,i){var a=f(t,n,i),o=/**
 * Validate whether a method is safe.
 * Throws an error when that's not the case.
 * @param {Object} object
 * @param {string} method
 * @return {function} Returns the method when valid
 */function(e,t){if(!ef(e,t))throw Error('No access to method "'+t+'"');return e[t]}(a,p);if(null!=o&&o.rawArgs)return o(m,e,rh(t,n),t);// "regular" evaluation
var s=r.map(e=>e(t,n,i));return o.apply(a,s)}}else{// node.fn.isAccessorNode && !node.fn.index.isObjectProperty()
// we have to dynamically determine whether the function has the
// rawArgs property
var d=this.fn.toString(),h=this.fn._compile(e,t),g=this.args;return function(t,n,a){var o=h(t,n,a);if("function"!=typeof o)throw TypeError("Expression '".concat(d,"' did not evaluate to a function; value is:")+"\n  ".concat(i(o)));if(o.rawArgs)return o(g,e,rh(t,n),t);// "regular" evaluation
var s=r.map(e=>e(t,n,a));return o.apply(o,s)}}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){e(this.fn,"fn",this);for(var t=0;t<this.args.length;t++)e(this.args[t],"args["+t+"]",this)}/**
     * Create a new FunctionNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionNode} Returns a transformed copy of the node
     */map(e){for(var t=this._ifNode(e(this.fn,"fn",this)),r=[],n=0;n<this.args.length;n++)r[n]=this._ifNode(e(this.args[n],"args["+n+"]",this));return new o(t,r)}/**
     * Create a clone of this node, a shallow copy
     * @return {FunctionNode}
     */clone(){return new o(this.fn,this.args.slice(0))}/**
     * Throws an error 'Undefined function {name}'
     * @param {string} name
     *//**
     * Get string representation. (wrapper function)
     * This overrides parts of Node's toString function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toString
     * function.
     *
     * @param {Object} options
     * @return {string} str
     * @override
     */toString(e){var t,r=this.fn.toString(e);return(e&&"object"==typeof e.handler&&K(e.handler,r)&&(t=e.handler[r](this,e)),void 0!==t)?t:super.toString(e)}/**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */_toString(e){var t=this.args.map(function(t){return t.toString(e)});// format the arguments like "add(2, 4.2)"
return(R(this.fn)?"("+this.fn.toString(e)+")":this.fn.toString(e))+"("+t.join(", ")+")"}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:rD,fn:this.fn,args:this.args}}/**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "FunctionNode", fn: ..., args: ...}`,
     *                       where mathjs is optional
     * @returns {FunctionNode}
     *//**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */toHTML(e){var t=this.args.map(function(t){return t.toHTML(e)});// format the arguments like "add(2, 4.2)"
return'<span class="math-function">'+eL(this.fn)+'</span><span class="math-paranthesis math-round-parenthesis">(</span>'+t.join('<span class="math-separator">,</span>')+'<span class="math-paranthesis math-round-parenthesis">)</span>'}/**
     * Get LaTeX representation. (wrapper function)
     * This overrides parts of Node's toTex function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toTex
     * function.
     *
     * @param {Object} options
     * @return {string}
     */toTex(e){var t;return(e&&"object"==typeof e.handler&&K(e.handler,this.name)&&(t=e.handler[this.name](this,e)),void 0!==t)?t:super.toTex(e)}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */_toTex(e){var t,n,i=this.args.map(function(t){// get LaTeX of the arguments
return t.toTex(e)});switch(tQ[this.name]&&(t=tQ[this.name]),r[this.name]&&("function"==typeof r[this.name].toTex||"object"==typeof r[this.name].toTex||"string"==typeof r[this.name].toTex)&&(t=r[this.name].toTex),typeof t){case"function":// a callback function
n=t(this,e);break;case"string":// a template string
n=a(t,this,e);break;case"object":// an object with different "converters" for different
// numbers of arguments
switch(typeof t[i.length]){case"function":n=t[i.length](this,e);break;case"string":n=a(t[i.length],this,e)}}return void 0!==n?n:a("\\mathrm{${name}}\\left(${args}\\right)",this,e)}/**
     * Get identifier.
     * @return {string}
     */getIdentifier(){return this.type+":"+this.name}}return /*@__PURE__*/e(et)(o,"name",rD),/*@__PURE__*/e(et)(o,"onUndefinedFunction",function(e){throw Error("Undefined function "+e)}),/*@__PURE__*/e(et)(o,"fromJSON",function(e){return new o(e.fn,e.args)}),o},{isClass:!0,isNode:!0}),rA={name:"e",category:"Constants",syntax:["e"],description:"Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",examples:["e","e ^ 2","exp(2)","log(e)"],seealso:["exp"]},rS={name:"pi",category:"Constants",syntax:["pi"],description:"The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",examples:["pi","sin(pi/2)"],seealso:["tau"]},rC={// construction functions
bignumber:{name:"bignumber",category:"Construction",syntax:["bignumber(x)"],description:"Create a big number from a number or string.",examples:["0.1 + 0.2","bignumber(0.1) + bignumber(0.2)",'bignumber("7.2")','bignumber("7.2e500")',"bignumber([0.1, 0.2, 0.3])"],seealso:["boolean","complex","fraction","index","matrix","string","unit"]},boolean:{name:"boolean",category:"Construction",syntax:["x","boolean(x)"],description:"Convert a string or number into a boolean.",examples:["boolean(0)","boolean(1)","boolean(3)",'boolean("true")','boolean("false")',"boolean([1, 0, 1, 1])"],seealso:["bignumber","complex","index","matrix","number","string","unit"]},complex:{name:"complex",category:"Construction",syntax:["complex()","complex(re, im)","complex(string)"],description:"Create a complex number.",examples:["complex()","complex(2, 3)",'complex("7 - 2i")'],seealso:["bignumber","boolean","index","matrix","number","string","unit"]},createUnit:{name:"createUnit",category:"Construction",syntax:["createUnit(definitions)","createUnit(name, definition)"],description:"Create a user-defined unit and register it with the Unit type.",examples:['createUnit("foo")','createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})','createUnit("mph", "1 mile/hour")'],seealso:["unit","splitUnit"]},fraction:{name:"fraction",category:"Construction",syntax:["fraction(num)","fraction(matrix)","fraction(num,den)","fraction({n: num, d: den})"],description:"Create a fraction from a number or from integer numerator and denominator.",examples:["fraction(0.125)","fraction(1, 3) + fraction(2, 5)","fraction({n: 333, d: 53})","fraction([sqrt(9), sqrt(10), sqrt(11)])"],seealso:["bignumber","boolean","complex","index","matrix","string","unit"]},index:{name:"index",category:"Construction",syntax:["[start]","[start:end]","[start:step:end]","[start1, start 2, ...]","[start1:end1, start2:end2, ...]","[start1:step1:end1, start2:step2:end2, ...]"],description:"Create an index to get or replace a subset of a matrix",examples:["A = [1, 2, 3; 4, 5, 6]","A[1, :]","A[1, 2] = 50","A[1:2, 1:2] = 1","B = [1, 2, 3]","B[B>1 and B<3]"],seealso:["bignumber","boolean","complex","matrix,","number","range","string","unit"]},matrix:{name:"matrix",category:"Construction",syntax:["[]","[a1, b1, ...; a2, b2, ...]","matrix()",'matrix("dense")',"matrix([...])"],description:"Create a matrix.",examples:["[]","[1, 2, 3]","[1, 2, 3; 4, 5, 6]","matrix()","matrix([3, 4])",'matrix([3, 4; 5, 6], "sparse")','matrix([3, 4; 5, 6], "sparse", "number")'],seealso:["bignumber","boolean","complex","index","number","string","unit","sparse"]},number:{name:"number",category:"Construction",syntax:["x","number(x)","number(unit, valuelessUnit)"],description:"Create a number or convert a string or boolean into a number.",examples:["2","2e3","4.05","number(2)",'number("7.2")',"number(true)","number([true, false, true, true])",'number(unit("52cm"), "m")'],seealso:["bignumber","boolean","complex","fraction","index","matrix","string","unit"]},sparse:{name:"sparse",category:"Construction",syntax:["sparse()","sparse([a1, b1, ...; a1, b2, ...])",'sparse([a1, b1, ...; a1, b2, ...], "number")'],description:"Create a sparse matrix.",examples:["sparse()","sparse([3, 4; 5, 6])",'sparse([3, 0; 5, 0], "number")'],seealso:["bignumber","boolean","complex","index","number","string","unit","matrix"]},splitUnit:{name:"splitUnit",category:"Construction",syntax:["splitUnit(unit: Unit, parts: Unit[])"],description:"Split a unit in an array of units whose sum is equal to the original unit.",examples:['splitUnit(1 m, ["feet", "inch"])'],seealso:["unit","createUnit"]},string:{name:"string",category:"Construction",syntax:['"text"',"string(x)"],description:"Create a string or convert a value to a string",examples:['"Hello World!"',"string(4.2)","string(3 + 2i)"],seealso:["bignumber","boolean","complex","index","matrix","number","unit"]},unit:{name:"unit",category:"Construction",syntax:["value unit","unit(value, unit)","unit(string)"],description:"Create a unit.",examples:["5.5 mm","3 inch",'unit(7.1, "kilogram")','unit("23 deg")'],seealso:["bignumber","boolean","complex","index","matrix","number","string"]},// constants
e:rA,E:rA,false:{name:"false",category:"Constants",syntax:["false"],description:"Boolean value false",examples:["false"],seealso:["true"]},i:{name:"i",category:"Constants",syntax:["i"],description:"Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",examples:["i","i * i","sqrt(-1)"],seealso:[]},Infinity:{name:"Infinity",category:"Constants",syntax:["Infinity"],description:"Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",examples:["Infinity","1 / 0"],seealso:[]},LN2:{name:"LN2",category:"Constants",syntax:["LN2"],description:"Returns the natural logarithm of 2, approximately equal to 0.693",examples:["LN2","log(2)"],seealso:[]},LN10:{name:"LN10",category:"Constants",syntax:["LN10"],description:"Returns the natural logarithm of 10, approximately equal to 2.302",examples:["LN10","log(10)"],seealso:[]},LOG2E:{name:"LOG2E",category:"Constants",syntax:["LOG2E"],description:"Returns the base-2 logarithm of E, approximately equal to 1.442",examples:["LOG2E","log(e, 2)"],seealso:[]},LOG10E:{name:"LOG10E",category:"Constants",syntax:["LOG10E"],description:"Returns the base-10 logarithm of E, approximately equal to 0.434",examples:["LOG10E","log(e, 10)"],seealso:[]},NaN:{name:"NaN",category:"Constants",syntax:["NaN"],description:"Not a number",examples:["NaN","0 / 0"],seealso:[]},null:{name:"null",category:"Constants",syntax:["null"],description:"Value null",examples:["null"],seealso:["true","false"]},pi:rS,PI:rS,phi:{name:"phi",category:"Constants",syntax:["phi"],description:"Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",examples:["phi"],seealso:[]},SQRT1_2:{name:"SQRT1_2",category:"Constants",syntax:["SQRT1_2"],description:"Returns the square root of 1/2, approximately equal to 0.707",examples:["SQRT1_2","sqrt(1/2)"],seealso:[]},SQRT2:{name:"SQRT2",category:"Constants",syntax:["SQRT2"],description:"Returns the square root of 2, approximately equal to 1.414",examples:["SQRT2","sqrt(2)"],seealso:[]},tau:{name:"tau",category:"Constants",syntax:["tau"],description:"Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",examples:["tau","2 * pi"],seealso:["pi"]},true:{name:"true",category:"Constants",syntax:["true"],description:"Boolean value true",examples:["true"],seealso:["false"]},version:{name:"version",category:"Constants",syntax:["version"],description:"A string with the version number of math.js",examples:["version"],seealso:[]},// physical constants
// TODO: more detailed docs for physical constants
speedOfLight:{description:"Speed of light in vacuum",examples:["speedOfLight"]},gravitationConstant:{description:"Newtonian constant of gravitation",examples:["gravitationConstant"]},planckConstant:{description:"Planck constant",examples:["planckConstant"]},reducedPlanckConstant:{description:"Reduced Planck constant",examples:["reducedPlanckConstant"]},magneticConstant:{description:"Magnetic constant (vacuum permeability)",examples:["magneticConstant"]},electricConstant:{description:"Electric constant (vacuum permeability)",examples:["electricConstant"]},vacuumImpedance:{description:"Characteristic impedance of vacuum",examples:["vacuumImpedance"]},coulomb:{description:"Coulomb's constant",examples:["coulomb"]},elementaryCharge:{description:"Elementary charge",examples:["elementaryCharge"]},bohrMagneton:{description:"Borh magneton",examples:["bohrMagneton"]},conductanceQuantum:{description:"Conductance quantum",examples:["conductanceQuantum"]},inverseConductanceQuantum:{description:"Inverse conductance quantum",examples:["inverseConductanceQuantum"]},// josephson: {description: 'Josephson constant', examples: ['josephson']},
magneticFluxQuantum:{description:"Magnetic flux quantum",examples:["magneticFluxQuantum"]},nuclearMagneton:{description:"Nuclear magneton",examples:["nuclearMagneton"]},klitzing:{description:"Von Klitzing constant",examples:["klitzing"]},bohrRadius:{description:"Borh radius",examples:["bohrRadius"]},classicalElectronRadius:{description:"Classical electron radius",examples:["classicalElectronRadius"]},electronMass:{description:"Electron mass",examples:["electronMass"]},fermiCoupling:{description:"Fermi coupling constant",examples:["fermiCoupling"]},fineStructure:{description:"Fine-structure constant",examples:["fineStructure"]},hartreeEnergy:{description:"Hartree energy",examples:["hartreeEnergy"]},protonMass:{description:"Proton mass",examples:["protonMass"]},deuteronMass:{description:"Deuteron Mass",examples:["deuteronMass"]},neutronMass:{description:"Neutron mass",examples:["neutronMass"]},quantumOfCirculation:{description:"Quantum of circulation",examples:["quantumOfCirculation"]},rydberg:{description:"Rydberg constant",examples:["rydberg"]},thomsonCrossSection:{description:"Thomson cross section",examples:["thomsonCrossSection"]},weakMixingAngle:{description:"Weak mixing angle",examples:["weakMixingAngle"]},efimovFactor:{description:"Efimov factor",examples:["efimovFactor"]},atomicMass:{description:"Atomic mass constant",examples:["atomicMass"]},avogadro:{description:"Avogadro's number",examples:["avogadro"]},boltzmann:{description:"Boltzmann constant",examples:["boltzmann"]},faraday:{description:"Faraday constant",examples:["faraday"]},firstRadiation:{description:"First radiation constant",examples:["firstRadiation"]},loschmidt:{description:"Loschmidt constant at T=273.15 K and p=101.325 kPa",examples:["loschmidt"]},gasConstant:{description:"Gas constant",examples:["gasConstant"]},molarPlanckConstant:{description:"Molar Planck constant",examples:["molarPlanckConstant"]},molarVolume:{description:"Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",examples:["molarVolume"]},sackurTetrode:{description:"Sackur-Tetrode constant at T=1 K and p=101.325 kPa",examples:["sackurTetrode"]},secondRadiation:{description:"Second radiation constant",examples:["secondRadiation"]},stefanBoltzmann:{description:"Stefan-Boltzmann constant",examples:["stefanBoltzmann"]},wienDisplacement:{description:"Wien displacement law constant",examples:["wienDisplacement"]},// spectralRadiance: {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']},
molarMass:{description:"Molar mass constant",examples:["molarMass"]},molarMassC12:{description:"Molar mass constant of carbon-12",examples:["molarMassC12"]},gravity:{description:"Standard acceleration of gravity (standard acceleration of free-fall on Earth)",examples:["gravity"]},planckLength:{description:"Planck length",examples:["planckLength"]},planckMass:{description:"Planck mass",examples:["planckMass"]},planckTime:{description:"Planck time",examples:["planckTime"]},planckCharge:{description:"Planck charge",examples:["planckCharge"]},planckTemperature:{description:"Planck temperature",examples:["planckTemperature"]},// functions - algebra
derivative:{name:"derivative",category:"Algebra",syntax:["derivative(expr, variable)","derivative(expr, variable, {simplify: boolean})"],description:"Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",examples:['derivative("2x^3", "x")','derivative("2x^3", "x", {simplify: false})','derivative("2x^2 + 3x + 4", "x")','derivative("sin(2x)", "x")','f = parse("x^2 + x")','x = parse("x")',"df = derivative(f, x)","df.evaluate({x: 3})"],seealso:["simplify","parse","evaluate"]},lsolve:{name:"lsolve",category:"Algebra",syntax:["x=lsolve(L, b)"],description:"Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",examples:["a = [-2, 3; 2, 1]","b = [11, 9]","x = lsolve(a, b)"],seealso:["lsolveAll","lup","lusolve","usolve","matrix","sparse"]},lsolveAll:{name:"lsolveAll",category:"Algebra",syntax:["x=lsolveAll(L, b)"],description:"Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",examples:["a = [-2, 3; 2, 1]","b = [11, 9]","x = lsolve(a, b)"],seealso:["lsolve","lup","lusolve","usolve","matrix","sparse"]},lup:{name:"lup",category:"Algebra",syntax:["lup(m)"],description:"Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",examples:["lup([[2, 1], [1, 4]])","lup(matrix([[2, 1], [1, 4]]))","lup(sparse([[2, 1], [1, 4]]))"],seealso:["lusolve","lsolve","usolve","matrix","sparse","slu","qr"]},lusolve:{name:"lusolve",category:"Algebra",syntax:["x=lusolve(A, b)","x=lusolve(lu, b)"],description:"Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",examples:["a = [-2, 3; 2, 1]","b = [11, 9]","x = lusolve(a, b)"],seealso:["lup","slu","lsolve","usolve","matrix","sparse"]},leafCount:{name:"leafCount",category:"Algebra",syntax:["leafCount(expr)"],description:"Computes the number of leaves in the parse tree of the given expression",examples:['leafCount("e^(i*pi)-1")','leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],seealso:["simplify"]},polynomialRoot:{name:"polynomialRoot",category:"Algebra",syntax:["x=polynomialRoot(-6, 3)","x=polynomialRoot(4, -4, 1)","x=polynomialRoot(-8, 12, -6, 1)"],description:"Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",examples:["a = polynomialRoot(-6, 11, -6, 1)"],seealso:["cbrt","sqrt"]},resolve:{name:"resolve",category:"Algebra",syntax:["resolve(node, scope)"],description:"Recursively substitute variables in an expression tree.",examples:['resolve(parse("1 + x"), { x: 7 })','resolve(parse("size(text)"), { text: "Hello World" })','resolve(parse("x + y"), { x: parse("3z") })','resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],seealso:["simplify","evaluate"],mayThrow:["ReferenceError"]},simplify:{name:"simplify",category:"Algebra",syntax:["simplify(expr)","simplify(expr, rules)"],description:"Simplify an expression tree.",examples:['simplify("3 + 2 / 4")','simplify("2x + x")','f = parse("x * (x + 2 + x)")',"simplified = simplify(f)","simplified.evaluate({x: 2})"],seealso:["simplifyCore","derivative","evaluate","parse","rationalize","resolve"]},simplifyConstant:{name:"simplifyConstant",category:"Algebra",syntax:["simplifyConstant(expr)","simplifyConstant(expr, options)"],description:"Replace constant subexpressions of node with their values.",examples:['simplifyConstant("(3-3)*x")','simplifyConstant(parse("z-cos(tau/8)"))'],seealso:["simplify","simplifyCore","evaluate"]},simplifyCore:{name:"simplifyCore",category:"Algebra",syntax:["simplifyCore(node)"],description:"Perform simple one-pass simplifications on an expression tree.",examples:['simplifyCore(parse("0*x"))','simplifyCore(parse("(x+0)*2"))'],seealso:["simplify","simplifyConstant","evaluate"]},symbolicEqual:{name:"symbolicEqual",category:"Algebra",syntax:["symbolicEqual(expr1, expr2)","symbolicEqual(expr1, expr2, options)"],description:"Returns true if the difference of the expressions simplifies to 0",examples:['symbolicEqual("x*y","y*x")','symbolicEqual("abs(x^2)", "x^2")','symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],seealso:["simplify","evaluate"]},rationalize:{name:"rationalize",category:"Algebra",syntax:["rationalize(expr)","rationalize(expr, scope)","rationalize(expr, scope, detailed)"],description:"Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",examples:['rationalize("2x/y - y/(x+1)")','rationalize("2x/y - y/(x+1)", true)'],seealso:["simplify"]},slu:{name:"slu",category:"Algebra",syntax:["slu(A, order, threshold)"],description:"Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",examples:["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],seealso:["lusolve","lsolve","usolve","matrix","sparse","lup","qr"]},usolve:{name:"usolve",category:"Algebra",syntax:["x=usolve(U, b)"],description:"Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",examples:["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],seealso:["usolveAll","lup","lusolve","lsolve","matrix","sparse"]},usolveAll:{name:"usolveAll",category:"Algebra",syntax:["x=usolve(U, b)"],description:"Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",examples:["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],seealso:["usolve","lup","lusolve","lsolve","matrix","sparse"]},qr:{name:"qr",category:"Algebra",syntax:["qr(A)"],description:"Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",examples:["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],seealso:["lup","slu","matrix"]},// functions - arithmetic
abs:{name:"abs",category:"Arithmetic",syntax:["abs(x)"],description:"Compute the absolute value.",examples:["abs(3.5)","abs(-4.2)"],seealso:["sign"]},add:{name:"add",category:"Operators",syntax:["x + y","add(x, y)"],description:"Add two values.",examples:["a = 2.1 + 3.6","a - 3.6","3 + 2i","3 cm + 2 inch",'"2.3" + "4"'],seealso:["subtract"]},cbrt:{name:"cbrt",category:"Arithmetic",syntax:["cbrt(x)","cbrt(x, allRoots)"],description:"Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",examples:["cbrt(64)","cube(4)","cbrt(-8)","cbrt(2 + 3i)","cbrt(8i)","cbrt(8i, true)","cbrt(27 m^3)"],seealso:["square","sqrt","cube","multiply"]},ceil:{name:"ceil",category:"Arithmetic",syntax:["ceil(x)"],description:"Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",examples:["ceil(3.2)","ceil(3.8)","ceil(-4.2)"],seealso:["floor","fix","round"]},cube:{name:"cube",category:"Arithmetic",syntax:["cube(x)"],description:"Compute the cube of a value. The cube of x is x * x * x.",examples:["cube(2)","2^3","2 * 2 * 2"],seealso:["multiply","square","pow"]},divide:{name:"divide",category:"Operators",syntax:["x / y","divide(x, y)"],description:"Divide two values.",examples:["a = 2 / 3","a * 3","4.5 / 2","3 + 4 / 2","(3 + 4) / 2","18 km / 4.5"],seealso:["multiply"]},dotDivide:{name:"dotDivide",category:"Operators",syntax:["x ./ y","dotDivide(x, y)"],description:"Divide two values element wise.",examples:["a = [1, 2, 3; 4, 5, 6]","b = [2, 1, 1; 3, 2, 5]","a ./ b"],seealso:["multiply","dotMultiply","divide"]},dotMultiply:{name:"dotMultiply",category:"Operators",syntax:["x .* y","dotMultiply(x, y)"],description:"Multiply two values element wise.",examples:["a = [1, 2, 3; 4, 5, 6]","b = [2, 1, 1; 3, 2, 5]","a .* b"],seealso:["multiply","divide","dotDivide"]},dotPow:{name:"dotPow",category:"Operators",syntax:["x .^ y","dotPow(x, y)"],description:"Calculates the power of x to y element wise.",examples:["a = [1, 2, 3; 4, 5, 6]","a .^ 2"],seealso:["pow"]},exp:{name:"exp",category:"Arithmetic",syntax:["exp(x)"],description:"Calculate the exponent of a value.",examples:["exp(1.3)","e ^ 1.3","log(exp(1.3))","x = 2.4","(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],seealso:["expm","expm1","pow","log"]},expm:{name:"expm",category:"Arithmetic",syntax:["exp(x)"],description:"Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",examples:["expm([[0,2],[0,0]])"],seealso:["exp"]},expm1:{name:"expm1",category:"Arithmetic",syntax:["expm1(x)"],description:"Calculate the value of subtracting 1 from the exponential value.",examples:["expm1(2)","pow(e, 2) - 1","log(expm1(2) + 1)"],seealso:["exp","pow","log"]},fix:{name:"fix",category:"Arithmetic",syntax:["fix(x)"],description:"Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",examples:["fix(3.2)","fix(3.8)","fix(-4.2)","fix(-4.8)"],seealso:["ceil","floor","round"]},floor:{name:"floor",category:"Arithmetic",syntax:["floor(x)"],description:"Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",examples:["floor(3.2)","floor(3.8)","floor(-4.2)"],seealso:["ceil","fix","round"]},gcd:{name:"gcd",category:"Arithmetic",syntax:["gcd(a, b)","gcd(a, b, c, ...)"],description:"Compute the greatest common divisor.",examples:["gcd(8, 12)","gcd(-4, 6)","gcd(25, 15, -10)"],seealso:["lcm","xgcd"]},hypot:{name:"hypot",category:"Arithmetic",syntax:["hypot(a, b, c, ...)","hypot([a, b, c, ...])"],description:"Calculate the hypotenusa of a list with values. ",examples:["hypot(3, 4)","sqrt(3^2 + 4^2)","hypot(-2)","hypot([3, 4, 5])"],seealso:["abs","norm"]},lcm:{name:"lcm",category:"Arithmetic",syntax:["lcm(x, y)"],description:"Compute the least common multiple.",examples:["lcm(4, 6)","lcm(6, 21)","lcm(6, 21, 5)"],seealso:["gcd"]},log:{name:"log",category:"Arithmetic",syntax:["log(x)","log(x, base)"],description:"Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",examples:["log(3.5)","a = log(2.4)","exp(a)","10 ^ 4","log(10000, 10)","log(10000) / log(10)","b = log(1024, 2)","2 ^ b"],seealso:["exp","log1p","log2","log10"]},log2:{name:"log2",category:"Arithmetic",syntax:["log2(x)"],description:"Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",examples:["log2(0.03125)","log2(16)","log2(16) / log2(2)","pow(2, 4)"],seealso:["exp","log1p","log","log10"]},log1p:{name:"log1p",category:"Arithmetic",syntax:["log1p(x)","log1p(x, base)"],description:"Calculate the logarithm of a `value+1`",examples:["log1p(2.5)","exp(log1p(1.4))","pow(10, 4)","log1p(9999, 10)","log1p(9999) / log(10)"],seealso:["exp","log","log2","log10"]},log10:{name:"log10",category:"Arithmetic",syntax:["log10(x)"],description:"Compute the 10-base logarithm of a value.",examples:["log10(0.00001)","log10(10000)","10 ^ 4","log(10000) / log(10)","log(10000, 10)"],seealso:["exp","log"]},mod:{name:"mod",category:"Operators",syntax:["x % y","x mod y","mod(x, y)"],description:"Calculates the modulus, the remainder of an integer division.",examples:["7 % 3","11 % 2","10 mod 4","isOdd(x) = x % 2","isOdd(2)","isOdd(3)"],seealso:["divide"]},multiply:{name:"multiply",category:"Operators",syntax:["x * y","multiply(x, y)"],description:"multiply two values.",examples:["a = 2.1 * 3.4","a / 3.4","2 * 3 + 4","2 * (3 + 4)","3 * 2.1 km"],seealso:["divide"]},norm:{name:"norm",category:"Arithmetic",syntax:["norm(x)","norm(x, p)"],description:"Calculate the norm of a number, vector or matrix.",examples:["abs(-3.5)","norm(-3.5)","norm(3 - 4i)","norm([1, 2, -3], Infinity)","norm([1, 2, -3], -Infinity)","norm([3, 4], 2)","norm([[1, 2], [3, 4]], 1)",'norm([[1, 2], [3, 4]], "inf")','norm([[1, 2], [3, 4]], "fro")']},nthRoot:{name:"nthRoot",category:"Arithmetic",syntax:["nthRoot(a)","nthRoot(a, root)"],description:'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',examples:["4 ^ 3","nthRoot(64, 3)","nthRoot(9, 2)","sqrt(9)"],seealso:["nthRoots","pow","sqrt"]},nthRoots:{name:"nthRoots",category:"Arithmetic",syntax:["nthRoots(A)","nthRoots(A, root)"],description:'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',examples:["nthRoots(1)","nthRoots(1, 3)"],seealso:["sqrt","pow","nthRoot"]},pow:{name:"pow",category:"Operators",syntax:["x ^ y","pow(x, y)"],description:"Calculates the power of x to y, x^y.",examples:["2^3","2*2*2","1 + e ^ (pi * i)","pow([[1, 2], [4, 3]], 2)","pow([[1, 2], [4, 3]], -1)"],seealso:["multiply","nthRoot","nthRoots","sqrt"]},round:{name:"round",category:"Arithmetic",syntax:["round(x)","round(x, n)","round(unit, valuelessUnit)","round(unit, n, valuelessUnit)"],description:"round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",examples:["round(3.2)","round(3.8)","round(-4.2)","round(-4.8)","round(pi, 3)","round(123.45678, 2)","round(3.241cm, 2, cm)","round([3.2, 3.8, -4.7])"],seealso:["ceil","floor","fix"]},sign:{name:"sign",category:"Arithmetic",syntax:["sign(x)"],description:"Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",examples:["sign(3.5)","sign(-4.2)","sign(0)"],seealso:["abs"]},sqrt:{name:"sqrt",category:"Arithmetic",syntax:["sqrt(x)"],description:"Compute the square root value. If x = y * y, then y is the square root of x.",examples:["sqrt(25)","5 * 5","sqrt(-1)"],seealso:["square","sqrtm","multiply","nthRoot","nthRoots","pow"]},sqrtm:{name:"sqrtm",category:"Arithmetic",syntax:["sqrtm(x)"],description:"Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",examples:["sqrtm([[33, 24], [48, 57]])"],seealso:["sqrt","abs","square","multiply"]},square:{name:"square",category:"Arithmetic",syntax:["square(x)"],description:"Compute the square of a value. The square of x is x * x.",examples:["square(3)","sqrt(9)","3^2","3 * 3"],seealso:["multiply","pow","sqrt","cube"]},subtract:{name:"subtract",category:"Operators",syntax:["x - y","subtract(x, y)"],description:"subtract two values.",examples:["a = 5.3 - 2","a + 2","2/3 - 1/6","2 * 3 - 3","2.1 km - 500m"],seealso:["add"]},unaryMinus:{name:"unaryMinus",category:"Operators",syntax:["-x","unaryMinus(x)"],description:"Inverse the sign of a value. Converts booleans and strings to numbers.",examples:["-4.5","-(-5.6)",'-"22"'],seealso:["add","subtract","unaryPlus"]},unaryPlus:{name:"unaryPlus",category:"Operators",syntax:["+x","unaryPlus(x)"],description:"Converts booleans and strings to numbers.",examples:["+true",'+"2"'],seealso:["add","subtract","unaryMinus"]},xgcd:{name:"xgcd",category:"Arithmetic",syntax:["xgcd(a, b)"],description:"Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",examples:["xgcd(8, 12)","gcd(8, 12)","xgcd(36163, 21199)"],seealso:["gcd","lcm"]},invmod:{name:"invmod",category:"Arithmetic",syntax:["invmod(a, b)"],description:"Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax ≣ 1 (mod b)",examples:["invmod(8, 12)","invmod(7, 13)","invmod(15151, 15122)"],seealso:["gcd","xgcd"]},// functions - bitwise
bitAnd:{name:"bitAnd",category:"Bitwise",syntax:["x & y","bitAnd(x, y)"],description:"Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",examples:["5 & 3","bitAnd(53, 131)","[1, 12, 31] & 42"],seealso:["bitNot","bitOr","bitXor","leftShift","rightArithShift","rightLogShift"]},bitNot:{name:"bitNot",category:"Bitwise",syntax:["~x","bitNot(x)"],description:"Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",examples:["~1","~2","bitNot([2, -3, 4])"],seealso:["bitAnd","bitOr","bitXor","leftShift","rightArithShift","rightLogShift"]},bitOr:{name:"bitOr",category:"Bitwise",syntax:["x | y","bitOr(x, y)"],description:"Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",examples:["5 | 3","bitOr([1, 2, 3], 4)"],seealso:["bitAnd","bitNot","bitXor","leftShift","rightArithShift","rightLogShift"]},bitXor:{name:"bitXor",category:"Bitwise",syntax:["bitXor(x, y)"],description:"Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",examples:["bitOr(1, 2)","bitXor([2, 3, 4], 4)"],seealso:["bitAnd","bitNot","bitOr","leftShift","rightArithShift","rightLogShift"]},leftShift:{name:"leftShift",category:"Bitwise",syntax:["x << y","leftShift(x, y)"],description:"Bitwise left logical shift of a value x by y number of bits.",examples:["4 << 1","8 >> 1"],seealso:["bitAnd","bitNot","bitOr","bitXor","rightArithShift","rightLogShift"]},rightArithShift:{name:"rightArithShift",category:"Bitwise",syntax:["x >> y","rightArithShift(x, y)"],description:"Bitwise right arithmetic shift of a value x by y number of bits.",examples:["8 >> 1","4 << 1","-12 >> 2"],seealso:["bitAnd","bitNot","bitOr","bitXor","leftShift","rightLogShift"]},rightLogShift:{name:"rightLogShift",category:"Bitwise",syntax:["x >>> y","rightLogShift(x, y)"],description:"Bitwise right logical shift of a value x by y number of bits.",examples:["8 >>> 1","4 << 1","-12 >>> 2"],seealso:["bitAnd","bitNot","bitOr","bitXor","leftShift","rightArithShift"]},// functions - combinatorics
bellNumbers:{name:"bellNumbers",category:"Combinatorics",syntax:["bellNumbers(n)"],description:"The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",examples:["bellNumbers(3)","bellNumbers(8)"],seealso:["stirlingS2"]},catalan:{name:"catalan",category:"Combinatorics",syntax:["catalan(n)"],description:"The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",examples:["catalan(3)","catalan(8)"],seealso:["bellNumbers"]},composition:{name:"composition",category:"Combinatorics",syntax:["composition(n, k)"],description:"The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",examples:["composition(5, 3)"],seealso:["combinations"]},stirlingS2:{name:"stirlingS2",category:"Combinatorics",syntax:["stirlingS2(n, k)"],description:"he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",examples:["stirlingS2(5, 3)"],seealso:["bellNumbers"]},// functions - core
config:{name:"config",category:"Core",syntax:["config()","config(options)"],description:"Get configuration or change configuration.",examples:["config()","1/3 + 1/4",'config({number: "Fraction"})',"1/3 + 1/4"],seealso:[]},import:{name:"import",category:"Core",syntax:["import(functions)","import(functions, options)"],description:"Import functions or constants from an object.",examples:["import({myFn: f(x)=x^2, myConstant: 32 })","myFn(2)","myConstant"],seealso:[]},typed:{name:"typed",category:"Core",syntax:["typed(signatures)","typed(name, signatures)"],description:"Create a typed function.",examples:['double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })',"double(2)",'double("hello")'],seealso:[]},// functions - complex
arg:{name:"arg",category:"Complex",syntax:["arg(x)"],description:"Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",examples:["arg(2 + 2i)","atan2(3, 2)","arg(2 + 3i)"],seealso:["re","im","conj","abs"]},conj:{name:"conj",category:"Complex",syntax:["conj(x)"],description:"Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",examples:["conj(2 + 3i)","conj(2 - 3i)","conj(-5.2i)"],seealso:["re","im","abs","arg"]},re:{name:"re",category:"Complex",syntax:["re(x)"],description:"Get the real part of a complex number.",examples:["re(2 + 3i)","im(2 + 3i)","re(-5.2i)","re(2.4)"],seealso:["im","conj","abs","arg"]},im:{name:"im",category:"Complex",syntax:["im(x)"],description:"Get the imaginary part of a complex number.",examples:["im(2 + 3i)","re(2 + 3i)","im(-5.2i)","im(2.4)"],seealso:["re","conj","abs","arg"]},// functions - expression
evaluate:{name:"evaluate",category:"Expression",syntax:["evaluate(expression)","evaluate(expression, scope)","evaluate([expr1, expr2, expr3, ...])","evaluate([expr1, expr2, expr3, ...], scope)"],description:"Evaluate an expression or an array with expressions.",examples:['evaluate("2 + 3")','evaluate("sqrt(16)")','evaluate("2 inch to cm")','evaluate("sin(x * pi)", { "x": 1/2 })','evaluate(["width=2", "height=4","width*height"])'],seealso:[]},help:{name:"help",category:"Expression",syntax:["help(object)","help(string)"],description:"Display documentation on a function or data type.",examples:["help(sqrt)",'help("complex")'],seealso:[]},// functions - geometry
distance:{name:"distance",category:"Geometry",syntax:["distance([x1, y1], [x2, y2])","distance([[x1, y1], [x2, y2]])"],description:"Calculates the Euclidean distance between two points.",examples:["distance([0,0], [4,4])","distance([[0,0], [4,4]])"],seealso:[]},intersect:{name:"intersect",category:"Geometry",syntax:["intersect(expr1, expr2, expr3, expr4)","intersect(expr1, expr2, expr3)"],description:"Computes the intersection point of lines and/or planes.",examples:["intersect([0, 0], [10, 10], [10, 0], [0, 10])","intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],seealso:[]},// functions - logical
and:{name:"and",category:"Logical",syntax:["x and y","and(x, y)"],description:"Logical and. Test whether two values are both defined with a nonzero/nonempty value.",examples:["true and false","true and true","2 and 4"],seealso:["not","or","xor"]},not:{name:"not",category:"Logical",syntax:["not x","not(x)"],description:"Logical not. Flips the boolean value of given argument.",examples:["not true","not false","not 2","not 0"],seealso:["and","or","xor"]},or:{name:"or",category:"Logical",syntax:["x or y","or(x, y)"],description:"Logical or. Test if at least one value is defined with a nonzero/nonempty value.",examples:["true or false","false or false","0 or 4"],seealso:["not","and","xor"]},xor:{name:"xor",category:"Logical",syntax:["x xor y","xor(x, y)"],description:"Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",examples:["true xor false","false xor false","true xor true","0 xor 4"],seealso:["not","and","or"]},// functions - matrix
concat:{name:"concat",category:"Matrix",syntax:["concat(A, B, C, ...)","concat(A, B, C, ..., dim)"],description:"Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",examples:["A = [1, 2; 5, 6]","B = [3, 4; 7, 8]","concat(A, B)","concat(A, B, 1)","concat(A, B, 2)"],seealso:["det","diag","identity","inv","ones","range","size","squeeze","subset","trace","transpose","zeros"]},count:{name:"count",category:"Matrix",syntax:["count(x)"],description:"Count the number of elements of a matrix, array or string.",examples:["a = [1, 2; 3, 4; 5, 6]","count(a)","size(a)",'count("hello world")'],seealso:["size"]},cross:{name:"cross",category:"Matrix",syntax:["cross(A, B)"],description:"Calculate the cross product for two vectors in three dimensional space.",examples:["cross([1, 1, 0],  [0, 1, 1])","cross([3, -3, 1], [4, 9, 2])","cross([2, 3, 4],  [5, 6, 7])"],seealso:["multiply","dot"]},column:{name:"column",category:"Matrix",syntax:["column(x, index)"],description:"Return a column from a matrix or array.",examples:["A = [[1, 2], [3, 4]]","column(A, 1)","column(A, 2)"],seealso:["row","matrixFromColumns"]},ctranspose:{name:"ctranspose",category:"Matrix",syntax:["x'","ctranspose(x)"],description:"Complex Conjugate and Transpose a matrix",examples:["a = [1, 2, 3; 4, 5, 6]","a'","ctranspose(a)"],seealso:["concat","det","diag","identity","inv","ones","range","size","squeeze","subset","trace","zeros"]},det:{name:"det",category:"Matrix",syntax:["det(x)"],description:"Calculate the determinant of a matrix",examples:["det([1, 2; 3, 4])","det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],seealso:["concat","diag","identity","inv","ones","range","size","squeeze","subset","trace","transpose","zeros"]},diag:{name:"diag",category:"Matrix",syntax:["diag(x)","diag(x, k)"],description:"Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",examples:["diag(1:3)","diag(1:3, 1)","a = [1, 2, 3; 4, 5, 6; 7, 8, 9]","diag(a)"],seealso:["concat","det","identity","inv","ones","range","size","squeeze","subset","trace","transpose","zeros"]},diff:{name:"diff",category:"Matrix",syntax:["diff(arr)","diff(arr, dim)"],description:["Create a new matrix or array with the difference of the passed matrix or array.","Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference","If no dimension parameter is passed it is assumed as dimension 0","Dimension is zero-based in javascript and one-based in the parser","Arrays must be 'rectangular' meaning arrays like [1, 2]","If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],examples:["A = [1, 2, 4, 7, 0]","diff(A)","diff(A, 1)","B = [[1, 2], [3, 4]]","diff(B)","diff(B, 1)","diff(B, 2)","diff(B, bignumber(2))","diff([[1, 2], matrix([3, 4])], 2)"],seealso:["subtract","partitionSelect"]},dot:{name:"dot",category:"Matrix",syntax:["dot(A, B)","A * B"],description:"Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",examples:["dot([2, 4, 1], [2, 2, 3])","[2, 4, 1] * [2, 2, 3]"],seealso:["multiply","cross"]},getMatrixDataType:{name:"getMatrixDataType",category:"Matrix",syntax:["getMatrixDataType(x)"],description:'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',examples:["getMatrixDataType([1, 2, 3])","getMatrixDataType([[5 cm], [2 inch]])",'getMatrixDataType([1, "text"])',"getMatrixDataType([1, bignumber(4)])"],seealso:["matrix","sparse","typeOf"]},identity:{name:"identity",category:"Matrix",syntax:["identity(n)","identity(m, n)","identity([m, n])"],description:"Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",examples:["identity(3)","identity(3, 5)","a = [1, 2, 3; 4, 5, 6]","identity(size(a))"],seealso:["concat","det","diag","inv","ones","range","size","squeeze","subset","trace","transpose","zeros"]},filter:{name:"filter",category:"Matrix",syntax:["filter(x, test)"],description:"Filter items in a matrix.",examples:["isPositive(x) = x > 0","filter([6, -2, -1, 4, 3], isPositive)","filter([6, -2, 0, 1, 0], x != 0)"],seealso:["sort","map","forEach"]},flatten:{name:"flatten",category:"Matrix",syntax:["flatten(x)"],description:"Flatten a multi dimensional matrix into a single dimensional matrix.",examples:["a = [1, 2, 3; 4, 5, 6]","size(a)","b = flatten(a)","size(b)"],seealso:["concat","resize","size","squeeze"]},forEach:{name:"forEach",category:"Matrix",syntax:["forEach(x, callback)"],description:"Iterates over all elements of a matrix/array, and executes the given callback function.",examples:["numberOfPets = {}","addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;",'forEach(["Dog","Cat","Cat"], addPet)',"numberOfPets"],seealso:["map","sort","filter"]},inv:{name:"inv",category:"Matrix",syntax:["inv(x)"],description:"Calculate the inverse of a matrix",examples:["inv([1, 2; 3, 4])","inv(4)","1 / 4"],seealso:["concat","det","diag","identity","ones","range","size","squeeze","subset","trace","transpose","zeros"]},pinv:{name:"pinv",category:"Matrix",syntax:["pinv(x)"],description:"Calculate the Moore–Penrose inverse of a matrix",examples:["pinv([1, 2; 3, 4])","pinv([[1, 0], [0, 1], [0, 1]])","pinv(4)"],seealso:["inv"]},eigs:{name:"eigs",category:"Matrix",syntax:["eigs(x)"],description:"Calculate the eigenvalues and optionally eigenvectors of a square matrix",examples:["eigs([[5, 2.3], [2.3, 1]])","eigs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], { precision: 1e-6, eigenvectors: false }"],seealso:["inv"]},kron:{name:"kron",category:"Matrix",syntax:["kron(x, y)"],description:"Calculates the kronecker product of 2 matrices or vectors.",examples:["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])","kron([1,1], [2,3,4])"],seealso:["multiply","dot","cross"]},matrixFromFunction:{name:"matrixFromFunction",category:"Matrix",syntax:["matrixFromFunction(size, fn)","matrixFromFunction(size, fn, format)","matrixFromFunction(size, fn, format, datatype)","matrixFromFunction(size, format, fn)","matrixFromFunction(size, format, datatype, fn)"],description:"Create a matrix by evaluating a generating function at each index.",examples:["f(I) = I[1] - I[2]","matrixFromFunction([3,3], f)","g(I) = I[1] - I[2] == 1 ? 4 : 0",'matrixFromFunction([100, 100], "sparse", g)',"matrixFromFunction([5], random)"],seealso:["matrix","matrixFromRows","matrixFromColumns","zeros"]},matrixFromRows:{name:"matrixFromRows",category:"Matrix",syntax:["matrixFromRows(...arr)","matrixFromRows(row1, row2)","matrixFromRows(row1, row2, row3)"],description:"Create a dense matrix from vectors as individual rows.",examples:["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],seealso:["matrix","matrixFromColumns","matrixFromFunction","zeros"]},matrixFromColumns:{name:"matrixFromColumns",category:"Matrix",syntax:["matrixFromColumns(...arr)","matrixFromColumns(row1, row2)","matrixFromColumns(row1, row2, row3)"],description:"Create a dense matrix from vectors as individual columns.",examples:["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],seealso:["matrix","matrixFromRows","matrixFromFunction","zeros"]},map:{name:"map",category:"Matrix",syntax:["map(x, callback)"],description:"Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",examples:["map([1, 2, 3], square)"],seealso:["filter","forEach"]},ones:{name:"ones",category:"Matrix",syntax:["ones(m)","ones(m, n)","ones(m, n, p, ...)","ones([m])","ones([m, n])","ones([m, n, p, ...])"],description:"Create a matrix containing ones.",examples:["ones(3)","ones(3, 5)","ones([2,3]) * 4.5","a = [1, 2, 3; 4, 5, 6]","ones(size(a))"],seealso:["concat","det","diag","identity","inv","range","size","squeeze","subset","trace","transpose","zeros"]},partitionSelect:{name:"partitionSelect",category:"Matrix",syntax:["partitionSelect(x, k)","partitionSelect(x, k, compare)"],description:"Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",examples:["partitionSelect([5, 10, 1], 2)",'partitionSelect(["C", "B", "A", "D"], 1, compareText)',"arr = [5, 2, 1]","partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]","arr","partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]","arr"],seealso:["sort"]},range:{name:"range",category:"Type",syntax:["start:end","start:step:end","range(start, end)","range(start, end, step)","range(string)"],description:"Create a range. Lower bound of the range is included, upper bound is excluded.",examples:["1:5","3:-1:-3","range(3, 7)","range(0, 12, 2)",'range("4:10")',"range(1m, 1m, 3m)","a = [1, 2, 3, 4; 5, 6, 7, 8]","a[1:2, 1:2]"],seealso:["concat","det","diag","identity","inv","ones","size","squeeze","subset","trace","transpose","zeros"]},resize:{name:"resize",category:"Matrix",syntax:["resize(x, size)","resize(x, size, defaultValue)"],description:"Resize a matrix.",examples:["resize([1,2,3,4,5], [3])","resize([1,2,3], [5])","resize([1,2,3], [5], -1)","resize(2, [2, 3])",'resize("hello", [8], "!")'],seealso:["size","subset","squeeze","reshape"]},reshape:{name:"reshape",category:"Matrix",syntax:["reshape(x, sizes)"],description:"Reshape a multi dimensional array to fit the specified dimensions.",examples:["reshape([1, 2, 3, 4, 5, 6], [2, 3])","reshape([[1, 2], [3, 4]], [1, 4])","reshape([[1, 2], [3, 4]], [4])","reshape([1, 2, 3, 4], [-1, 2])"],seealso:["size","squeeze","resize"]},rotate:{name:"rotate",category:"Matrix",syntax:["rotate(w, theta)","rotate(w, theta, v)"],description:"Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",examples:["rotate([1, 0], pi / 2)",'rotate(matrix([1, 0]), unit("35deg"))','rotate([1, 0, 0], unit("90deg"), [0, 0, 1])','rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],seealso:["matrix","rotationMatrix"]},rotationMatrix:{name:"rotationMatrix",category:"Matrix",syntax:["rotationMatrix(theta)","rotationMatrix(theta, v)","rotationMatrix(theta, v, format)"],description:"Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",examples:["rotationMatrix(pi / 2)",'rotationMatrix(unit("45deg"), [0, 0, 1])','rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],seealso:["cos","sin"]},row:{name:"row",category:"Matrix",syntax:["row(x, index)"],description:"Return a row from a matrix or array.",examples:["A = [[1, 2], [3, 4]]","row(A, 1)","row(A, 2)"],seealso:["column","matrixFromRows"]},size:{name:"size",category:"Matrix",syntax:["size(x)"],description:"Calculate the size of a matrix.",examples:["size(2.3)",'size("hello world")',"a = [1, 2; 3, 4; 5, 6]","size(a)","size(1:6)"],seealso:["concat","count","det","diag","identity","inv","ones","range","squeeze","subset","trace","transpose","zeros"]},sort:{name:"sort",category:"Matrix",syntax:["sort(x)","sort(x, compare)"],description:'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',examples:["sort([5, 10, 1])",'sort(["C", "B", "A", "D"], "natural")',"sortByLength(a, b) = size(a)[1] - size(b)[1]",'sort(["Langdon", "Tom", "Sara"], sortByLength)','sort(["10", "1", "2"], "natural")'],seealso:["map","filter","forEach"]},squeeze:{name:"squeeze",category:"Matrix",syntax:["squeeze(x)"],description:"Remove inner and outer singleton dimensions from a matrix.",examples:["a = zeros(3,2,1)","size(squeeze(a))","b = zeros(1,1,3)","size(squeeze(b))"],seealso:["concat","det","diag","identity","inv","ones","range","size","subset","trace","transpose","zeros"]},subset:{name:"subset",category:"Matrix",syntax:["value(index)","value(index) = replacement","subset(value, [index])","subset(value, [index], replacement)"],description:"Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",examples:["d = [1, 2; 3, 4]","e = []","e[1, 1:2] = [5, 6]","e[2, :] = [7, 8]","f = d * e","f[2, 1]","f[:, 1]","f[[1,2], [1,3]] = [9, 10; 11, 12]","f"],seealso:["concat","det","diag","identity","inv","ones","range","size","squeeze","trace","transpose","zeros"]},trace:{name:"trace",category:"Matrix",syntax:["trace(A)"],description:"Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",examples:["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]","trace(A)"],seealso:["concat","det","diag","identity","inv","ones","range","size","squeeze","subset","transpose","zeros"]},transpose:{name:"transpose",category:"Matrix",syntax:["x'","transpose(x)"],description:"Transpose a matrix",examples:["a = [1, 2, 3; 4, 5, 6]","a'","transpose(a)"],seealso:["concat","det","diag","identity","inv","ones","range","size","squeeze","subset","trace","zeros"]},zeros:{name:"zeros",category:"Matrix",syntax:["zeros(m)","zeros(m, n)","zeros(m, n, p, ...)","zeros([m])","zeros([m, n])","zeros([m, n, p, ...])"],description:"Create a matrix containing zeros.",examples:["zeros(3)","zeros(3, 5)","a = [1, 2, 3; 4, 5, 6]","zeros(size(a))"],seealso:["concat","det","diag","identity","inv","ones","range","size","squeeze","subset","trace","transpose"]},fft:{name:"fft",category:"Matrix",syntax:["fft(x)"],description:"Calculate N-dimensional fourier transform",examples:["fft([[1, 0], [1, 0]])"],seealso:["ifft"]},ifft:{name:"ifft",category:"Matrix",syntax:["ifft(x)"],description:"Calculate N-dimensional inverse fourier transform",examples:["ifft([[2, 2], [0, 0]])"],seealso:["fft"]},sylvester:{name:"sylvester",category:"Algebra",syntax:["sylvester(A,B,C)"],description:"Solves the real-valued Sylvester equation AX+XB=C for X",examples:["sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])","A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]","sylvester(A, B, C)"],seealso:["schur","lyap"]},schur:{name:"schur",category:"Algebra",syntax:["schur(A)"],description:"Performs a real Schur decomposition of the real matrix A = UTU'",examples:["schur([[1, 0], [-4, 3]])","A = [[1, 0], [-4, 3]]","schur(A)"],seealso:["lyap","sylvester"]},lyap:{name:"lyap",category:"Algebra",syntax:["lyap(A,Q)"],description:"Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",examples:["lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])","A = [[-2, 0], [1, -4]]","Q = [[3, 1], [1, 3]]","lyap(A,Q)"],seealso:["schur","sylvester"]},// functions - numeric
solveODE:{name:"solveODE",category:"Numeric",syntax:["solveODE(func, tspan, y0)","solveODE(func, tspan, y0, options)"],description:"Numerical Integration of Ordinary Differential Equations.",examples:["f(t,y) = y","tspan = [0, 4]","solveODE(f, tspan, 1)","solveODE(f, tspan, [1, 2])",'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'],seealso:["derivative","simplifyCore"]},// functions - probability
combinations:{name:"combinations",category:"Probability",syntax:["combinations(n, k)"],description:"Compute the number of combinations of n items taken k at a time",examples:["combinations(7, 5)"],seealso:["combinationsWithRep","permutations","factorial"]},combinationsWithRep:{name:"combinationsWithRep",category:"Probability",syntax:["combinationsWithRep(n, k)"],description:"Compute the number of combinations of n items taken k at a time with replacements.",examples:["combinationsWithRep(7, 5)"],seealso:["combinations","permutations","factorial"]},// distribution: distributionDocs,
factorial:{name:"factorial",category:"Probability",syntax:["n!","factorial(n)"],description:"Compute the factorial of a value",examples:["5!","5 * 4 * 3 * 2 * 1","3!"],seealso:["combinations","combinationsWithRep","permutations","gamma"]},gamma:{name:"gamma",category:"Probability",syntax:["gamma(n)"],description:"Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",examples:["gamma(4)","3!","gamma(1/2)","sqrt(pi)"],seealso:["factorial"]},kldivergence:{name:"kldivergence",category:"Probability",syntax:["kldivergence(x, y)"],description:"Calculate the Kullback-Leibler (KL) divergence  between two distributions.",examples:["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],seealso:[]},lgamma:{name:"lgamma",category:"Probability",syntax:["lgamma(n)"],description:"Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",examples:["lgamma(4)","lgamma(1/2)","lgamma(i)","lgamma(complex(1.1, 2))"],seealso:["gamma"]},multinomial:{name:"multinomial",category:"Probability",syntax:["multinomial(A)"],description:"Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",examples:["multinomial([1, 2, 1])"],seealso:["combinations","factorial"]},permutations:{name:"permutations",category:"Probability",syntax:["permutations(n)","permutations(n, k)"],description:"Compute the number of permutations of n items taken k at a time",examples:["permutations(5)","permutations(5, 3)"],seealso:["combinations","combinationsWithRep","factorial"]},pickRandom:{name:"pickRandom",category:"Probability",syntax:["pickRandom(array)","pickRandom(array, number)","pickRandom(array, weights)","pickRandom(array, number, weights)","pickRandom(array, weights, number)"],description:"Pick a random entry from a given array.",examples:["pickRandom(0:10)","pickRandom([1, 3, 1, 6])","pickRandom([1, 3, 1, 6], 2)","pickRandom([1, 3, 1, 6], [2, 3, 2, 1])","pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])","pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],seealso:["random","randomInt"]},random:{name:"random",category:"Probability",syntax:["random()","random(max)","random(min, max)","random(size)","random(size, max)","random(size, min, max)"],description:"Return a random number.",examples:["random()","random(10, 20)","random([2, 3])"],seealso:["pickRandom","randomInt"]},randomInt:{name:"randomInt",category:"Probability",syntax:["randomInt(max)","randomInt(min, max)","randomInt(size)","randomInt(size, max)","randomInt(size, min, max)"],description:"Return a random integer number",examples:["randomInt(10, 20)","randomInt([2, 3], 10)"],seealso:["pickRandom","random"]},// functions - relational
compare:{name:"compare",category:"Relational",syntax:["compare(x, y)"],description:"Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",examples:["compare(2, 3)","compare(3, 2)","compare(2, 2)","compare(5cm, 40mm)","compare(2, [1, 2, 3])"],seealso:["equal","unequal","smaller","smallerEq","largerEq","compareNatural","compareText"]},compareNatural:{name:"compareNatural",category:"Relational",syntax:["compareNatural(x, y)"],description:"Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",examples:["compareNatural(2, 3)","compareNatural(3, 2)","compareNatural(2, 2)","compareNatural(5cm, 40mm)",'compareNatural("2", "10")',"compareNatural(2 + 3i, 2 + 4i)","compareNatural([1, 2, 4], [1, 2, 3])","compareNatural([1, 5], [1, 2, 3])","compareNatural([1, 2], [1, 2])","compareNatural({a: 2}, {a: 4})"],seealso:["equal","unequal","smaller","smallerEq","largerEq","compare","compareText"]},compareText:{name:"compareText",category:"Relational",syntax:["compareText(x, y)"],description:"Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",examples:['compareText("B", "A")','compareText("A", "B")','compareText("A", "A")','compareText("2", "10")','compare("2", "10")',"compare(2, 10)",'compareNatural("2", "10")','compareText("B", ["A", "B", "C"])'],seealso:["compare","compareNatural"]},deepEqual:{name:"deepEqual",category:"Relational",syntax:["deepEqual(x, y)"],description:"Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",examples:["deepEqual([1,3,4], [1,3,4])","deepEqual([1,3,4], [1,3])"],seealso:["equal","unequal","smaller","larger","smallerEq","largerEq","compare"]},equal:{name:"equal",category:"Relational",syntax:["x == y","equal(x, y)"],description:"Check equality of two values. Returns true if the values are equal, and false if not.",examples:["2+2 == 3","2+2 == 4","a = 3.2","b = 6-2.8","a == b","50cm == 0.5m"],seealso:["unequal","smaller","larger","smallerEq","largerEq","compare","deepEqual","equalText"]},equalText:{name:"equalText",category:"Relational",syntax:["equalText(x, y)"],description:"Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",examples:['equalText("Hello", "Hello")','equalText("a", "A")','equal("2e3", "2000")','equalText("2e3", "2000")','equalText("B", ["A", "B", "C"])'],seealso:["compare","compareNatural","compareText","equal"]},larger:{name:"larger",category:"Relational",syntax:["x > y","larger(x, y)"],description:"Check if value x is larger than y. Returns true if x is larger than y, and false if not.",examples:["2 > 3","5 > 2*2","a = 3.3","b = 6-2.8","(a > b)","(b < a)","5 cm > 2 inch"],seealso:["equal","unequal","smaller","smallerEq","largerEq","compare"]},largerEq:{name:"largerEq",category:"Relational",syntax:["x >= y","largerEq(x, y)"],description:"Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",examples:["2 >= 1+1","2 > 1+1","a = 3.2","b = 6-2.8","(a >= b)"],seealso:["equal","unequal","smallerEq","smaller","compare"]},smaller:{name:"smaller",category:"Relational",syntax:["x < y","smaller(x, y)"],description:"Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",examples:["2 < 3","5 < 2*2","a = 3.3","b = 6-2.8","(a < b)","5 cm < 2 inch"],seealso:["equal","unequal","larger","smallerEq","largerEq","compare"]},smallerEq:{name:"smallerEq",category:"Relational",syntax:["x <= y","smallerEq(x, y)"],description:"Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",examples:["2 <= 1+1","2 < 1+1","a = 3.2","b = 6-2.8","(a <= b)"],seealso:["equal","unequal","larger","smaller","largerEq","compare"]},unequal:{name:"unequal",category:"Relational",syntax:["x != y","unequal(x, y)"],description:"Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",examples:["2+2 != 3","2+2 != 4","a = 3.2","b = 6-2.8","a != b","50cm != 0.5m","5 cm != 2 inch"],seealso:["equal","smaller","larger","smallerEq","largerEq","compare","deepEqual"]},// functions - set
setCartesian:{name:"setCartesian",category:"Set",syntax:["setCartesian(set1, set2)"],description:"Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",examples:["setCartesian([1, 2], [3, 4])"],seealso:["setUnion","setIntersect","setDifference","setPowerset"]},setDifference:{name:"setDifference",category:"Set",syntax:["setDifference(set1, set2)"],description:"Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",examples:["setDifference([1, 2, 3, 4], [3, 4, 5, 6])","setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],seealso:["setUnion","setIntersect","setSymDifference"]},setDistinct:{name:"setDistinct",category:"Set",syntax:["setDistinct(set)"],description:"Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",examples:["setDistinct([1, 1, 1, 2, 2, 3])"],seealso:["setMultiplicity"]},setIntersect:{name:"setIntersect",category:"Set",syntax:["setIntersect(set1, set2)"],description:"Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",examples:["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])","setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],seealso:["setUnion","setDifference"]},setIsSubset:{name:"setIsSubset",category:"Set",syntax:["setIsSubset(set1, set2)"],description:"Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",examples:["setIsSubset([1, 2], [3, 4, 5, 6])","setIsSubset([3, 4], [3, 4, 5, 6])"],seealso:["setUnion","setIntersect","setDifference"]},setMultiplicity:{name:"setMultiplicity",category:"Set",syntax:["setMultiplicity(element, set)"],description:"Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",examples:["setMultiplicity(1, [1, 2, 2, 4])","setMultiplicity(2, [1, 2, 2, 4])"],seealso:["setDistinct","setSize"]},setPowerset:{name:"setPowerset",category:"Set",syntax:["setPowerset(set)"],description:"Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",examples:["setPowerset([1, 2, 3])"],seealso:["setCartesian"]},setSize:{name:"setSize",category:"Set",syntax:["setSize(set)","setSize(set, unique)"],description:'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',examples:["setSize([1, 2, 2, 4])","setSize([1, 2, 2, 4], true)"],seealso:["setUnion","setIntersect","setDifference"]},setSymDifference:{name:"setSymDifference",category:"Set",syntax:["setSymDifference(set1, set2)"],description:"Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",examples:["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])","setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],seealso:["setUnion","setIntersect","setDifference"]},setUnion:{name:"setUnion",category:"Set",syntax:["setUnion(set1, set2)"],description:"Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",examples:["setUnion([1, 2, 3, 4], [3, 4, 5, 6])","setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],seealso:["setIntersect","setDifference"]},// functions - signal
zpk2tf:{name:"zpk2tf",category:"Signal",syntax:["zpk2tf(z, p, k)"],description:"Compute the transfer function of a zero-pole-gain model.",examples:["zpk2tf([1, 2], [-1, -2], 1)","zpk2tf([1, 2], [-1, -2])","zpk2tf([1 - 3i, 2 + 2i], [-1, -2])"],seealso:[]},freqz:{name:"freqz",category:"Signal",syntax:["freqz(b, a)","freqz(b, a, w)"],description:"Calculates the frequency response of a filter given its numerator and denominator coefficients.",examples:["freqz([1, 2], [1, 2, 3])","freqz([1, 2], [1, 2, 3], [0, 1])","freqz([1, 2], [1, 2, 3], 512)"],seealso:[]},// functions - special
erf:{name:"erf",category:"Special",syntax:["erf(x)"],description:"Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",examples:["erf(0.2)","erf(-0.5)","erf(4)"],seealso:[]},zeta:{name:"zeta",category:"Special",syntax:["zeta(s)"],description:"Compute the Riemann Zeta Function using an infinite series and Riemanns Functional Equation for the entire complex plane",examples:["zeta(0.2)","zeta(-0.5)","zeta(4)"],seealso:[]},// functions - statistics
cumsum:{name:"cumsum",category:"Statistics",syntax:["cumsum(a, b, c, ...)","cumsum(A)"],description:"Compute the cumulative sum of all values.",examples:["cumsum(2, 3, 4, 1)","cumsum([2, 3, 4, 1])","cumsum([1, 2; 3, 4])","cumsum([1, 2; 3, 4], 1)","cumsum([1, 2; 3, 4], 2)"],seealso:["max","mean","median","min","prod","std","sum","variance"]},mad:{name:"mad",category:"Statistics",syntax:["mad(a, b, c, ...)","mad(A)"],description:"Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",examples:["mad(10, 20, 30)","mad([1, 2, 3])"],seealso:["mean","median","std","abs"]},max:{name:"max",category:"Statistics",syntax:["max(a, b, c, ...)","max(A)","max(A, dimension)"],description:"Compute the maximum value of a list of values.",examples:["max(2, 3, 4, 1)","max([2, 3, 4, 1])","max([2, 5; 4, 3])","max([2, 5; 4, 3], 1)","max([2, 5; 4, 3], 2)","max(2.7, 7.1, -4.5, 2.0, 4.1)","min(2.7, 7.1, -4.5, 2.0, 4.1)"],seealso:["mean","median","min","prod","std","sum","variance"]},mean:{name:"mean",category:"Statistics",syntax:["mean(a, b, c, ...)","mean(A)","mean(A, dimension)"],description:"Compute the arithmetic mean of a list of values.",examples:["mean(2, 3, 4, 1)","mean([2, 3, 4, 1])","mean([2, 5; 4, 3])","mean([2, 5; 4, 3], 1)","mean([2, 5; 4, 3], 2)","mean([1.0, 2.7, 3.2, 4.0])"],seealso:["max","median","min","prod","std","sum","variance"]},median:{name:"median",category:"Statistics",syntax:["median(a, b, c, ...)","median(A)"],description:"Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",examples:["median(5, 2, 7)","median([3, -1, 5, 7])"],seealso:["max","mean","min","prod","std","sum","variance","quantileSeq"]},min:{name:"min",category:"Statistics",syntax:["min(a, b, c, ...)","min(A)","min(A, dimension)"],description:"Compute the minimum value of a list of values.",examples:["min(2, 3, 4, 1)","min([2, 3, 4, 1])","min([2, 5; 4, 3])","min([2, 5; 4, 3], 1)","min([2, 5; 4, 3], 2)","min(2.7, 7.1, -4.5, 2.0, 4.1)","max(2.7, 7.1, -4.5, 2.0, 4.1)"],seealso:["max","mean","median","prod","std","sum","variance"]},mode:{name:"mode",category:"Statistics",syntax:["mode(a, b, c, ...)","mode(A)","mode(A, a, b, B, c, ...)"],description:"Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",examples:["mode(2, 1, 4, 3, 1)","mode([1, 2.7, 3.2, 4, 2.7])","mode(1, 4, 6, 1, 6)"],seealso:["max","mean","min","median","prod","std","sum","variance"]},prod:{name:"prod",category:"Statistics",syntax:["prod(a, b, c, ...)","prod(A)"],description:"Compute the product of all values.",examples:["prod(2, 3, 4)","prod([2, 3, 4])","prod([2, 5; 4, 3])"],seealso:["max","mean","min","median","min","std","sum","variance"]},quantileSeq:{name:"quantileSeq",category:"Statistics",syntax:["quantileSeq(A, prob[, sorted])","quantileSeq(A, [prob1, prob2, ...][, sorted])","quantileSeq(A, N[, sorted])"],description:"Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",examples:["quantileSeq([3, -1, 5, 7], 0.5)","quantileSeq([3, -1, 5, 7], [1/3, 2/3])","quantileSeq([3, -1, 5, 7], 2)","quantileSeq([-1, 3, 5, 7], 0.5, true)"],seealso:["mean","median","min","max","prod","std","sum","variance"]},std:{name:"std",category:"Statistics",syntax:["std(a, b, c, ...)","std(A)","std(A, dimension)","std(A, normalization)","std(A, dimension, normalization)"],description:'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',examples:["std(2, 4, 6)","std([2, 4, 6, 8])",'std([2, 4, 6, 8], "uncorrected")','std([2, 4, 6, 8], "biased")',"std([1, 2, 3; 4, 5, 6])"],seealso:["max","mean","min","median","prod","sum","variance"]},sum:{name:"sum",category:"Statistics",syntax:["sum(a, b, c, ...)","sum(A)","sum(A, dimension)"],description:"Compute the sum of all values.",examples:["sum(2, 3, 4, 1)","sum([2, 3, 4, 1])","sum([2, 5; 4, 3])"],seealso:["max","mean","median","min","prod","std","sum","variance"]},variance:{name:"variance",category:"Statistics",syntax:["variance(a, b, c, ...)","variance(A)","variance(A, dimension)","variance(A, normalization)","variance(A, dimension, normalization)"],description:'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',examples:["variance(2, 4, 6)","variance([2, 4, 6, 8])",'variance([2, 4, 6, 8], "uncorrected")','variance([2, 4, 6, 8], "biased")',"variance([1, 2, 3; 4, 5, 6])"],seealso:["max","mean","min","median","min","prod","std","sum"]},corr:{name:"corr",category:"Statistics",syntax:["corr(A,B)"],description:"Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.",examples:["corr([2, 4, 6, 8],[1, 2, 3, 6])","corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))"],seealso:["max","mean","min","median","min","prod","std","sum"]},// functions - trigonometry
acos:{name:"acos",category:"Trigonometry",syntax:["acos(x)"],description:"Compute the inverse cosine of a value in radians.",examples:["acos(0.5)","acos(cos(2.3))"],seealso:["cos","atan","asin"]},acosh:{name:"acosh",category:"Trigonometry",syntax:["acosh(x)"],description:"Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",examples:["acosh(1.5)"],seealso:["cosh","asinh","atanh"]},acot:{name:"acot",category:"Trigonometry",syntax:["acot(x)"],description:"Calculate the inverse cotangent of a value.",examples:["acot(0.5)","acot(cot(0.5))","acot(2)"],seealso:["cot","atan"]},acoth:{name:"acoth",category:"Trigonometry",syntax:["acoth(x)"],description:"Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",examples:["acoth(2)","acoth(0.5)"],seealso:["acsch","asech"]},acsc:{name:"acsc",category:"Trigonometry",syntax:["acsc(x)"],description:"Calculate the inverse cotangent of a value.",examples:["acsc(2)","acsc(csc(0.5))","acsc(0.5)"],seealso:["csc","asin","asec"]},acsch:{name:"acsch",category:"Trigonometry",syntax:["acsch(x)"],description:"Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",examples:["acsch(0.5)"],seealso:["asech","acoth"]},asec:{name:"asec",category:"Trigonometry",syntax:["asec(x)"],description:"Calculate the inverse secant of a value.",examples:["asec(0.5)","asec(sec(0.5))","asec(2)"],seealso:["acos","acot","acsc"]},asech:{name:"asech",category:"Trigonometry",syntax:["asech(x)"],description:"Calculate the inverse secant of a value.",examples:["asech(0.5)"],seealso:["acsch","acoth"]},asin:{name:"asin",category:"Trigonometry",syntax:["asin(x)"],description:"Compute the inverse sine of a value in radians.",examples:["asin(0.5)","asin(sin(0.5))"],seealso:["sin","acos","atan"]},asinh:{name:"asinh",category:"Trigonometry",syntax:["asinh(x)"],description:"Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",examples:["asinh(0.5)"],seealso:["acosh","atanh"]},atan:{name:"atan",category:"Trigonometry",syntax:["atan(x)"],description:"Compute the inverse tangent of a value in radians.",examples:["atan(0.5)","atan(tan(0.5))"],seealso:["tan","acos","asin"]},atanh:{name:"atanh",category:"Trigonometry",syntax:["atanh(x)"],description:"Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",examples:["atanh(0.5)"],seealso:["acosh","asinh"]},atan2:{name:"atan2",category:"Trigonometry",syntax:["atan2(y, x)"],description:"Computes the principal value of the arc tangent of y/x in radians.",examples:["atan2(2, 2) / pi","angle = 60 deg in rad","x = cos(angle)","y = sin(angle)","atan2(y, x)"],seealso:["sin","cos","tan"]},cos:{name:"cos",category:"Trigonometry",syntax:["cos(x)"],description:"Compute the cosine of x in radians.",examples:["cos(2)","cos(pi / 4) ^ 2","cos(180 deg)","cos(60 deg)","sin(0.2)^2 + cos(0.2)^2"],seealso:["acos","sin","tan"]},cosh:{name:"cosh",category:"Trigonometry",syntax:["cosh(x)"],description:"Compute the hyperbolic cosine of x in radians.",examples:["cosh(0.5)"],seealso:["sinh","tanh","coth"]},cot:{name:"cot",category:"Trigonometry",syntax:["cot(x)"],description:"Compute the cotangent of x in radians. Defined as 1/tan(x)",examples:["cot(2)","1 / tan(2)"],seealso:["sec","csc","tan"]},coth:{name:"coth",category:"Trigonometry",syntax:["coth(x)"],description:"Compute the hyperbolic cotangent of x in radians.",examples:["coth(2)","1 / tanh(2)"],seealso:["sech","csch","tanh"]},csc:{name:"csc",category:"Trigonometry",syntax:["csc(x)"],description:"Compute the cosecant of x in radians. Defined as 1/sin(x)",examples:["csc(2)","1 / sin(2)"],seealso:["sec","cot","sin"]},csch:{name:"csch",category:"Trigonometry",syntax:["csch(x)"],description:"Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",examples:["csch(2)","1 / sinh(2)"],seealso:["sech","coth","sinh"]},sec:{name:"sec",category:"Trigonometry",syntax:["sec(x)"],description:"Compute the secant of x in radians. Defined as 1/cos(x)",examples:["sec(2)","1 / cos(2)"],seealso:["cot","csc","cos"]},sech:{name:"sech",category:"Trigonometry",syntax:["sech(x)"],description:"Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",examples:["sech(2)","1 / cosh(2)"],seealso:["coth","csch","cosh"]},sin:{name:"sin",category:"Trigonometry",syntax:["sin(x)"],description:"Compute the sine of x in radians.",examples:["sin(2)","sin(pi / 4) ^ 2","sin(90 deg)","sin(30 deg)","sin(0.2)^2 + cos(0.2)^2"],seealso:["asin","cos","tan"]},sinh:{name:"sinh",category:"Trigonometry",syntax:["sinh(x)"],description:"Compute the hyperbolic sine of x in radians.",examples:["sinh(0.5)"],seealso:["cosh","tanh"]},tan:{name:"tan",category:"Trigonometry",syntax:["tan(x)"],description:"Compute the tangent of x in radians.",examples:["tan(0.5)","sin(0.5) / cos(0.5)","tan(pi / 4)","tan(45 deg)"],seealso:["atan","sin","cos"]},tanh:{name:"tanh",category:"Trigonometry",syntax:["tanh(x)"],description:"Compute the hyperbolic tangent of x in radians.",examples:["tanh(0.5)","sinh(0.5) / cosh(0.5)"],seealso:["sinh","cosh"]},// functions - units
to:{name:"to",category:"Units",syntax:["x to unit","to(x, unit)"],description:"Change the unit of a value.",examples:["5 inch to cm","3.2kg to g","16 bytes in bits"],seealso:[]},// functions - utils
clone:{name:"clone",category:"Utils",syntax:["clone(x)"],description:"Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",examples:["clone(3.5)","clone(2 - 4i)","clone(45 deg)","clone([1, 2; 3, 4])",'clone("hello world")'],seealso:[]},format:{name:"format",category:"Utils",syntax:["format(value)","format(value, precision)"],description:"Format a value of any type as string.",examples:["format(2.3)","format(3 - 4i)","format([])","format(pi, 3)"],seealso:["print"]},bin:{name:"bin",category:"Utils",syntax:["bin(value)"],description:"Format a number as binary",examples:["bin(2)"],seealso:["oct","hex"]},oct:{name:"oct",category:"Utils",syntax:["oct(value)"],description:"Format a number as octal",examples:["oct(56)"],seealso:["bin","hex"]},hex:{name:"hex",category:"Utils",syntax:["hex(value)"],description:"Format a number as hexadecimal",examples:["hex(240)"],seealso:["bin","oct"]},isNaN:{name:"isNaN",category:"Utils",syntax:["isNaN(x)"],description:"Test whether a value is NaN (not a number)",examples:["isNaN(2)","isNaN(0 / 0)","isNaN(NaN)","isNaN(Infinity)"],seealso:["isNegative","isNumeric","isPositive","isZero"]},isInteger:{name:"isInteger",category:"Utils",syntax:["isInteger(x)"],description:"Test whether a value is an integer number.",examples:["isInteger(2)","isInteger(3.5)","isInteger([3, 0.5, -2])"],seealso:["isNegative","isNumeric","isPositive","isZero"]},isNegative:{name:"isNegative",category:"Utils",syntax:["isNegative(x)"],description:"Test whether a value is negative: smaller than zero.",examples:["isNegative(2)","isNegative(0)","isNegative(-4)","isNegative([3, 0.5, -2])"],seealso:["isInteger","isNumeric","isPositive","isZero"]},isNumeric:{name:"isNumeric",category:"Utils",syntax:["isNumeric(x)"],description:"Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",examples:["isNumeric(2)",'isNumeric("2")','hasNumericValue("2")',"isNumeric(0)","isNumeric(bignumber(500))","isNumeric(fraction(0.125))","isNumeric(2 + 3i)",'isNumeric([2.3, "foo", false])'],seealso:["isInteger","isZero","isNegative","isPositive","isNaN","hasNumericValue"]},hasNumericValue:{name:"hasNumericValue",category:"Utils",syntax:["hasNumericValue(x)"],description:"Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",examples:["hasNumericValue(2)",'hasNumericValue("2")','isNumeric("2")',"hasNumericValue(0)","hasNumericValue(bignumber(500))","hasNumericValue(fraction(0.125))","hasNumericValue(2 + 3i)",'hasNumericValue([2.3, "foo", false])'],seealso:["isInteger","isZero","isNegative","isPositive","isNaN","isNumeric"]},isPositive:{name:"isPositive",category:"Utils",syntax:["isPositive(x)"],description:"Test whether a value is positive: larger than zero.",examples:["isPositive(2)","isPositive(0)","isPositive(-4)","isPositive([3, 0.5, -2])"],seealso:["isInteger","isNumeric","isNegative","isZero"]},isPrime:{name:"isPrime",category:"Utils",syntax:["isPrime(x)"],description:"Test whether a value is prime: has no divisors other than itself and one.",examples:["isPrime(3)","isPrime(-2)","isPrime([2, 17, 100])"],seealso:["isInteger","isNumeric","isNegative","isZero"]},isZero:{name:"isZero",category:"Utils",syntax:["isZero(x)"],description:"Test whether a value is zero.",examples:["isZero(2)","isZero(0)","isZero(-4)","isZero([3, 0, -2, 0])"],seealso:["isInteger","isNumeric","isNegative","isPositive"]},print:{name:"print",category:"Utils",syntax:["print(template, values)","print(template, values, precision)"],description:"Interpolate values into a string template.",examples:['print("Lucy is $age years old", {age: 5})','print("The value of pi is $pi", {pi: pi}, 3)','print("Hello, $user.name!", {user: {name: "John"}})','print("Values: $1, $2, $3", [6, 9, 4])'],seealso:["format"]},typeOf:{name:"typeOf",category:"Utils",syntax:["typeOf(x)"],description:"Get the type of a variable.",examples:["typeOf(3.5)","typeOf(2 - 4i)","typeOf(45 deg)",'typeOf("hello world")'],seealso:["getMatrixDataType"]},numeric:{name:"numeric",category:"Utils",syntax:["numeric(x)"],description:"Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",examples:['numeric("4")','numeric("4", "number")','numeric("4", "BigNumber")','numeric("4", "Fraction")','numeric(4, "Fraction")','numeric(fraction(2, 5), "number")'],seealso:["number","fraction","bignumber","string","format"]}},rM="help",rF=ta(rM,["typed","mathWithTransform","Help"],e=>{var{typed:t,mathWithTransform:r,Help:n}=e;/**
   * Retrieve help on a function or data type.
   * Help files are retrieved from the embedded documentation in math.docs.
   *
   * Syntax:
   *
   *    math.help(search)
   *
   * Examples:
   *
   *    console.log(math.help('sin').toString())
   *    console.log(math.help(math.add).toString())
   *    console.log(math.help(math.add).toJSON())
   *
   * @param {Function | string | Object} search   A function or function name
   *                                              for which to get help
   * @return {Help} A help object
   */return t(rM,{any:function(e){var t,i=e;if("string"!=typeof e){for(t in r)if(K(r,t)&&e===r[t]){i=t;break}}var a=eu(rC,i);if(!a)throw Error('No documentation found on "'+("function"==typeof i?i.name:i)+'"');return new n(a)}})}),rB=ta("Help",["parse"],e=>{var{parse:t}=e;/**
   * Documentation object
   * @param {Object} doc  Object containing properties:
   *                      {string} name
   *                      {string} category
   *                      {string} description
   *                      {string[]} syntax
   *                      {string[]} examples
   *                      {string[]} seealso
   * @constructor
   */function r(e){if(!(this instanceof r))throw SyntaxError("Constructor must be called with the new operator");if(!e)throw Error('Argument "doc" missing');this.doc=e}return(/**
   * Attach type information
   */r.prototype.type="Help",r.prototype.isHelp=!0,/**
   * Generate a string representation of the Help object
   * @return {string} Returns a string
   * @private
   */r.prototype.toString=function(){var e=this.doc||{},r="\n";if(e.name&&(r+="Name: "+e.name+"\n\n"),e.category&&(r+="Category: "+e.category+"\n\n"),e.description&&(r+="Description:\n    "+e.description+"\n\n"),e.syntax&&(r+="Syntax:\n    "+e.syntax.join("\n    ")+"\n\n"),e.examples){r+="Examples:\n";for(var n={},i=0;i<e.examples.length;i++){var a=e.examples[i];r+="    "+a+"\n";var o=void 0;try{// note: res can be undefined when `expr` is an empty string
o=t(a).compile().evaluate(n)}catch(e){o=e}void 0===o||E(o)||(r+="        "+eP(o,{precision:14})+"\n")}r+="\n"}return e.mayThrow&&e.mayThrow.length&&(r+="Throws: "+e.mayThrow.join(", ")+"\n\n"),e.seealso&&e.seealso.length&&(r+="See also: "+e.seealso.join(", ")+"\n"),r},/**
   * Export the help object to JSON
   */r.prototype.toJSON=function(){var e=J(this.doc);return e.mathjs="Help",e},/**
   * Instantiate a Help object from a JSON object
   * @param {Object} json
   * @returns {Help} Returns a new Help object
   */r.fromJSON=function(e){var t={};return Object.keys(e).filter(e=>"mathjs"!==e).forEach(r=>{t[r]=e[r]}),new r(t)},/**
   * Returns a string representation of the Help object
   */r.prototype.valueOf=r.prototype.toString,r)},{isClass:!0}),rT="IndexNode",rO=ta(rT,["Node","size"],t=>{var{Node:Node,size:r}=t;class n extends Node{/**
     * @constructor IndexNode
     * @extends Node
     *
     * Describes a subset of a matrix or an object property.
     * Cannot be used on its own, needs to be used within an AccessorNode or
     * AssignmentNode.
     *
     * @param {Node[]} dimensions
     * @param {boolean} [dotNotation=false]
     *     Optional property describing whether this index was written using dot
     *     notation like `a.b`, or using bracket notation like `a["b"]`
     *     (which is the default). This property is used for string conversion.
     */constructor(e,t){// validate input
if(super(),this.dimensions=e,this.dotNotation=t||!1,!Array.isArray(e)||!e.every(U))throw TypeError('Array containing Nodes expected for parameter "dimensions"');if(this.dotNotation&&!this.isObjectProperty())throw Error("dotNotation only applicable for object properties")}get type(){return rT}get isIndexNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){// TODO: implement support for bignumber (currently bignumbers are silently
//       reduced to numbers when changing the value to zero-based)
// TODO: Optimization: when the range values are ConstantNodes,
//       we can beforehand resolve the zero-based value
// optimization for a simple object property
var n=e4(this.dimensions,function(n,i){if(!(n.filter(e=>e.isSymbolNode&&"end"===e.name).length>0))return n._compile(e,t);// SymbolNode 'end' is used inside the index,
// like in `A[end]` or `A[end - 2]`
var a=Object.create(t);a.end=!0;var o=n._compile(e,a);return function(e,t,n){if(!g(n)&&!h(n)&&!d(n))throw TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is '+Y(n));var a=r(n).valueOf(),s=Object.create(t);return s.end=a[i],o(e,s,n)}}),i=eu(e,"index");return function(e,t,r){return i(...e4(n,function(n){return n(e,t,r)}))}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){for(var t=0;t<this.dimensions.length;t++)e(this.dimensions[t],"dimensions["+t+"]",this)}/**
     * Create a new IndexNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {IndexNode} Returns a transformed copy of the node
     */map(e){for(var t=[],r=0;r<this.dimensions.length;r++)t[r]=this._ifNode(e(this.dimensions[r],"dimensions["+r+"]",this));return new n(t,this.dotNotation)}/**
     * Create a clone of this node, a shallow copy
     * @return {IndexNode}
     */clone(){return new n(this.dimensions.slice(0),this.dotNotation)}/**
     * Test whether this IndexNode contains a single property name
     * @return {boolean}
     */isObjectProperty(){return 1===this.dimensions.length&&k(this.dimensions[0])&&"string"==typeof this.dimensions[0].value}/**
     * Returns the property name if IndexNode contains a property.
     * If not, returns null.
     * @return {string | null}
     */getObjectProperty(){return this.isObjectProperty()?this.dimensions[0].value:null}/**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */_toString(e){// format the parameters like "[1, 0:5]"
return this.dotNotation?"."+this.getObjectProperty():"["+this.dimensions.join(", ")+"]"}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:rT,dimensions:this.dimensions,dotNotation:this.dotNotation}}/**
     * Instantiate an IndexNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "IndexNode", dimensions: [...], dotNotation: false}`,
     *     where mathjs is optional
     * @returns {IndexNode}
     */static fromJSON(e){return new n(e.dimensions,e.dotNotation)}/**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */toHTML(e){for(var t=[],r=0;r<this.dimensions.length;r++)t[r]=this.dimensions[r].toHTML();return this.dotNotation?'<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">'+eL(this.getObjectProperty())+"</span>":'<span class="math-parenthesis math-square-parenthesis">[</span>'+t.join('<span class="math-separator">,</span>')+'<span class="math-parenthesis math-square-parenthesis">]</span>'}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */_toTex(e){var t=this.dimensions.map(function(t){return t.toTex(e)});return this.dotNotation?"."+this.getObjectProperty():"_{"+t.join(",")+"}"}}return /*@__PURE__*/e(et)(n,"name",rT),n},{isClass:!0,isNode:!0}),r_=ta("index",["Index","getMatrixDataType"],e=>{var{Index:t,getMatrixDataType:r}=e;/**
   * Attach a transform function to math.index
   * Adds a property transform containing the transform function.
   *
   * This transform creates a one-based index instead of a zero-based index
   */return function(){for(var e=[],n=0,i=arguments.length;n<i;n++){var a=arguments[n];// change from one-based to zero based, convert BigNumber to number and leave Array of Booleans as is
if(b(a))a.start--,a.end-=a.step>0?0:2;else if(a&&!0===a.isSet)a=a.map(function(e){return e-1});else if(h(a)||g(a))"boolean"!==r(a)&&(a=a.map(function(e){return e-1}));else if(l(a))a--;else if(c(a))a=a.toNumber()-1;else if("string"==typeof a);else throw TypeError("Dimension must be an Array, Matrix, number, string, or Range");e[n]=a}var o=new t;return t.apply(o,e),o}},{isTransformFunction:!0}),rz="leafCount",rq=ta(rz,["parse","typed"],e=>{var{parse:t,typed:r}=e;/**
   * Gives the number of "leaf nodes" in the parse tree of the given expression
   * A leaf node is one that has no subexpressions, essentially either a
   * symbol or a constant. Note that `5!` has just one leaf, the '5'; the
   * unary factorial operator does not add a leaf. On the other hand,
   * function symbols do add leaves, so `sin(x)/cos(x)` has four leaves.
   *
   * The `simplify()` function should generally not increase the `leafCount()`
   * of an expression, although currently there is no guarantee that it never
   * does so. In many cases, `simplify()` reduces the leaf count.
   *
   * Syntax:
   *
   *     math.leafCount(expr)
   *
   * Examples:
   *
   *     math.leafCount('x') // 1
   *     math.leafCount(math.parse('a*d-b*c')) // 4
   *     math.leafCount('[a,b;c,d][0,1]') // 6
   *
   * See also:
   *
   *     simplify
   *
   * @param {Node|string} expr    The expression to count the leaves of
   *
   * @return {number}  The number of leaves of `expr`
   *
   */return r(rz,{Node:function(e){return(// This does the real work, but we don't have to recurse through
// a typed call if we separate it out
function e(t){var r=0;return t.forEach(t=>{r+=e(t)}),r||1}(e))}})}),rk=ta("map",["typed"],e=>{var{typed:t}=e;/**
   * Attach a transform function to math.map
   * Adds a property transform containing the transform function.
   *
   * This transform creates a one-based index instead of a zero-based index
   */function r(e,t,r){var i,a;return e[0]&&(i=e[0].compile().evaluate(r)),e[1]&&(a=V(e[1])||R(e[1])?e[1].compile().evaluate(r):rg(e[1],t,r)),n(i,a)}r.rawArgs=!0;// one-based version of map function
var n=t("map",{"Array, function":function(e,t){return rI(e,t,e)},"Matrix, function":function(e,t){return e.create(rI(e.valueOf(),t,e))}});return r},{isTransformFunction:!0});/**
 * Map for a multidimensional array. One-based indexes
 * @param {Array} array
 * @param {function} callback
 * @param {Array} orig
 * @return {Array}
 * @private
 */function rI(e,t,r){return function e(n,i){return Array.isArray(n)?e4(n,function(t,r){// we create a copy of the index array and append the new index value
return e(t,i.concat(r+1));// one based index, hence i + 1
}):rd(t,n,i,r,"map")}(e,[])}var rR=ta("max",["typed","config","numeric","larger"],e=>{var{typed:t,config:r,numeric:n,larger:i}=e;/**
   * Compute the maximum value of a matrix or a  list with values.
   * In case of a multidimensional array, the maximum of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.max(a, b, c, ...)
   *     math.max(A)
   *     math.max(A, dimension)
   *
   * Examples:
   *
   *     math.max(2, 1, 4, 3)                  // returns 4
   *     math.max([2, 1, 4, 3])                // returns 4
   *
   *     // maximum over a specified dimension (zero-based)
   *     math.max([[2, 5], [4, 3], [1, 7]], 0) // returns [4, 7]
   *     math.max([[2, 5], [4, 3], [1, 7]], 1) // returns [5, 4, 7]
   *
   *     math.max(2.7, 7.1, -4.5, 2.0, 4.1)    // returns 7.1
   *     math.min(2.7, 7.1, -4.5, 2.0, 4.1)    // returns -4.5
   *
   * See also:
   *
   *    mean, median, min, prod, std, sum, variance
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The maximum value
   */return t("max",{// max([a, b, c, d, ...])
"Array | Matrix":o,// max([a, b, c, d, ...], dim)
"Array | Matrix, number | BigNumber":function(e,t){return tk(e,t.valueOf(),a)},// max(a, b, c, d, ...)
"...":function(e){if(t_(e))throw TypeError("Scalar values expected in function max");return o(e)}});/**
   * Return the largest of two values
   * @param {*} x
   * @param {*} y
   * @returns {*} Returns x when x is largest, or y when y is largest
   * @private
   */function a(e,t){try{return i(e,t)?e:t}catch(e){throw t4(e,"max",t)}}/**
   * Recursively calculate the maximum value in an n-dimensional array
   * @param {Array} array
   * @return {number} max
   * @private
   */function o(e){var t;if(tz(e,function(e){try{isNaN(e)&&"number"==typeof e?t=NaN:(void 0===t||i(e,t))&&(t=e)}catch(t){throw t4(t,"max",e)}}),void 0===t)throw Error("Cannot calculate max of an empty array");return"string"==typeof t&&(t=n(t,r.number)),t}}),rP=ta("max",["typed","config","numeric","larger"],e=>{var{typed:t,config:r,numeric:n,larger:i}=e,a=rR({typed:t,config:r,numeric:n,larger:i});/**
   * Attach a transform function to math.max
   * Adds a property transform containing the transform function.
   *
   * This transform changed the last `dim` parameter of function max
   * from one-based to zero based
   */return t("max",{"...any":function(e){e=rn(e);try{return a.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0}),rj="mean",rU=ta(rj,["typed","add","divide"],e=>{var{typed:t,add:r,divide:n}=e;/**
   * Compute the mean value of matrix or a list with values.
   * In case of a multidimensional array, the mean of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.mean(a, b, c, ...)
   *     math.mean(A)
   *     math.mean(A, dimension)
   *
   * Examples:
   *
   *     math.mean(2, 1, 4, 3)                     // returns 2.5
   *     math.mean([1, 2.7, 3.2, 4])               // returns 2.725
   *
   *     math.mean([[2, 5], [6, 3], [1, 7]], 0)    // returns [3, 5]
   *     math.mean([[2, 5], [6, 3], [1, 7]], 1)    // returns [3.5, 4.5, 4]
   *
   * See also:
   *
   *     median, min, max, sum, prod, std, variance
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The mean of all values
   */return t(rj,{// mean([a, b, c, d, ...])
"Array | Matrix":i,// mean([a, b, c, d, ...], dim)
"Array | Matrix, number | BigNumber":/**
   * Calculate the mean value in an n-dimensional array, returning a
   * n-1 dimensional array
   * @param {Array} array
   * @param {number} dim
   * @return {number} mean
   * @private
   */function(e,t){try{var i=tk(e,t,r),a=Array.isArray(e)?eG(e):e.size();return n(i,a[t])}catch(e){throw t4(e,"mean")}},// mean(a, b, c, d, ...)
"...":function(e){if(t_(e))throw TypeError("Scalar values expected in function mean");return i(e)}});/**
   * Recursively calculate the mean value in an n-dimensional array
   * @param {Array} array
   * @return {number} mean
   * @private
   */function i(e){var t,i=0;if(tz(e,function(e){try{t=void 0===t?e:r(t,e),i++}catch(t){throw t4(t,"mean",e)}}),0===i)throw Error("Cannot calculate the mean of an empty array");return n(t,i)}}),rL=ta("mean",["typed","add","divide"],e=>{var{typed:t,add:r,divide:n}=e,i=rU({typed:t,add:r,divide:n});/**
   * Attach a transform function to math.mean
   * Adds a property transform containing the transform function.
   *
   * This transform changed the last `dim` parameter of function mean
   * from one-based to zero based
   */return t("mean",{"...any":function(e){e=rn(e);try{return i.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0}),r$=ta("min",["typed","config","numeric","smaller"],e=>{var{typed:t,config:r,numeric:n,smaller:i}=e;/**
   * Compute the minimum value of a matrix or a  list of values.
   * In case of a multidimensional array, the minimum of the flattened array
   * will be calculated. When `dim` is provided, the minimum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.min(a, b, c, ...)
   *     math.min(A)
   *     math.min(A, dimension)
   *
   * Examples:
   *
   *     math.min(2, 1, 4, 3)                  // returns 1
   *     math.min([2, 1, 4, 3])                // returns 1
   *
   *     // minimum over a specified dimension (zero-based)
   *     math.min([[2, 5], [4, 3], [1, 7]], 0) // returns [1, 3]
   *     math.min([[2, 5], [4, 3], [1, 7]], 1) // returns [2, 3, 1]
   *
   *     math.max(2.7, 7.1, -4.5, 2.0, 4.1)    // returns 7.1
   *     math.min(2.7, 7.1, -4.5, 2.0, 4.1)    // returns -4.5
   *
   * See also:
   *
   *    mean, median, max, prod, std, sum, variance
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The minimum value
   */return t("min",{// min([a, b, c, d, ...])
"Array | Matrix":o,// min([a, b, c, d, ...], dim)
"Array | Matrix, number | BigNumber":function(e,t){return tk(e,t.valueOf(),a)},// min(a, b, c, d, ...)
"...":function(e){if(t_(e))throw TypeError("Scalar values expected in function min");return o(e)}});/**
   * Return the smallest of two values
   * @param {*} x
   * @param {*} y
   * @returns {*} Returns x when x is smallest, or y when y is smallest
   * @private
   */function a(e,t){try{return i(e,t)?e:t}catch(e){throw t4(e,"min",t)}}/**
   * Recursively calculate the minimum value in an n-dimensional array
   * @param {Array} array
   * @return {number} min
   * @private
   */function o(e){var t;if(tz(e,function(e){try{isNaN(e)&&"number"==typeof e?t=NaN:(void 0===t||i(e,t))&&(t=e)}catch(t){throw t4(t,"min",e)}}),void 0===t)throw Error("Cannot calculate min of an empty array");return"string"==typeof t&&(t=n(t,r.number)),t}}),rH=ta("min",["typed","config","numeric","smaller"],e=>{var{typed:t,config:r,numeric:n,smaller:i}=e,a=r$({typed:t,config:r,numeric:n,smaller:i});/**
   * Attach a transform function to math.min
   * Adds a property transform containing the transform function.
   *
   * This transform changed the last `dim` parameter of function min
   * from one-based to zero based
   */return t("min",{"...any":function(e){e=rn(e);try{return a.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0}),rZ=ta("Node",["mathWithTransform"],e=>{var{mathWithTransform:t}=e;return class{get type(){return"Node"}get isNode(){return!0}/**
     * Evaluate the node
     * @param {Object} [scope]  Scope to read/write variables
     * @return {*}              Returns the result
     */evaluate(e){return this.compile().evaluate(e)}/**
     * Compile the node into an optimized, evauatable JavaScript function
     * @return {{evaluate: function([Object])}} object
     *                Returns an object with a function 'evaluate',
     *                which can be invoked as expr.evaluate([scope: Object]),
     *                where scope is an optional object with
     *                variables.
     */compile(){var e=this._compile(t,{}),r={};return{evaluate:function(t){var n=ru(t);return!/**
   * Validate the symbol names of a scope.
   * Throws an error when the scope contains an illegal symbol.
   * @param {Object} scope
   */function(e){for(var t of[...rb])if(e.has(t))throw Error('Scope contains an illegal symbol, "'+t+'" is a reserved keyword')}(n),e(n,r,null)}}}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){throw Error("Method _compile must be implemented by type "+this.type)}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){// must be implemented by each of the Node implementations
throw Error("Cannot run forEach on a Node interface")}/**
     * Create a new Node whose children are the results of calling the
     * provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */map(e){// must be implemented by each of the Node implementations
throw Error("Cannot run map on a Node interface")}/**
     * Validate whether an object is a Node, for use with map
     * @param {Node} node
     * @returns {Node} Returns the input if it's a node, else throws an Error
     * @protected
     */_ifNode(e){if(!U(e))throw TypeError("Callback function must return a Node");return e}/**
     * Recursively traverse all nodes in a node tree. Executes given callback for
     * this node and each of its child nodes.
     * @param {function(node: Node, path: string, parent: Node)} callback
     *          A callback called for every node in the node tree.
     */traverse(e){// execute callback for itself
// eslint-disable-next-line
e(this,null,null),// recursively traverse over all children of a node
function e(t,r){t.forEach(function(t,n,i){r(t,n,i),e(t,r)})}(this,e)}/**
     * Recursively transform a node tree via a transform function.
     *
     * For example, to replace all nodes of type SymbolNode having name 'x' with
     * a ConstantNode with value 2:
     *
     *     const res = Node.transform(function (node, path, parent) {
     *       if (node && node.isSymbolNode) && (node.name === 'x')) {
     *         return new ConstantNode(2)
     *       }
     *       else {
     *         return node
     *       }
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *          A mapping function accepting a node, and returning
     *          a replacement for the node or the original node. The "signature"
     *          of the callback must be:
     *          callback(node: Node, index: string, parent: Node) : Node
     * @return {Node} Returns the original node or its replacement
     */transform(e){return function t(r,n,i){var a=e(r,n,i);return a!==r?a:r.map(t)}(this,null,null)}/**
     * Find any node in the node tree matching given filter function. For
     * example, to find all nodes of type SymbolNode having name 'x':
     *
     *     const results = Node.filter(function (node) {
     *       return (node && node.isSymbolNode) && (node.name === 'x')
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *            A test function returning true when a node matches, and false
     *            otherwise. Function signature:
     *            callback(node: Node, index: string, parent: Node) : boolean
     * @return {Node[]} nodes
     *            An array with nodes matching given filter criteria
     */filter(e){var t=[];return this.traverse(function(r,n,i){e(r,n,i)&&t.push(r)}),t}/**
     * Create a shallow clone of this node
     * @return {Node}
     */clone(){// must be implemented by each of the Node implementations
throw Error("Cannot clone a Node interface")}/**
     * Create a deep clone of this node
     * @return {Node}
     */cloneDeep(){return this.map(function(e){return e.cloneDeep()})}/**
     * Deep compare this node with another node.
     * @param {Node} other
     * @return {boolean} Returns true when both nodes are of the same type and
     *                   contain the same values (as do their childs)
     */equals(e){return!!e&&this.type===e.type&&Q(this,e)}/**
     * Get string representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */toString(e){var t=this._getCustomString(e);return void 0!==t?t:this._toString(e)}/**
     * Get a JSON representation of the node
     * Both .toJSON() and the static .fromJSON(json) should be implemented by all
     * implementations of Node
     * @returns {Object}
     */toJSON(){throw Error("Cannot serialize object: toJSON not implemented by "+this.type)}/**
     * Get HTML representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)" or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */toHTML(e){var t=this._getCustomString(e);return void 0!==t?t:this.toHTML(e)}/**
     * Internal function to generate the string output.
     * This has to be implemented by every Node
     *
     * @throws {Error}
     */_toString(){// must be implemented by each of the Node implementations
throw Error("_toString not implemented for "+this.type)}/**
     * Get LaTeX representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */toTex(e){var t=this._getCustomString(e);return void 0!==t?t:this._toTex(e)}/**
     * Internal function to generate the LaTeX output.
     * This has to be implemented by every Node
     *
     * @param {Object} [options]
     * @throws {Error}
     */_toTex(e){// must be implemented by each of the Node implementations
throw Error("_toTex not implemented for "+this.type)}/**
     * Helper used by `to...` functions.
     */_getCustomString(e){if(e&&"object"==typeof e)switch(typeof e.handler){case"object":case"undefined":return;case"function":return e.handler(this,e);default:throw TypeError("Object or function expected as callback")}}/**
     * Get identifier.
     * @return {string}
     */getIdentifier(){return this.type}/**
     * Get the content of the current Node.
     * @return {Node} node
     **/getContent(){return this}}},{isClass:!0,isNode:!0}),rG="ObjectNode",rV=ta(rG,["Node"],t=>{var{Node:Node}=t;class r extends Node{/**
     * @constructor ObjectNode
     * @extends {Node}
     * Holds an object with keys/values
     * @param {Object.<string, Node>} [properties]   object with key/value pairs
     */constructor(e){// validate input
if(super(),this.properties=e||{},e&&("object"!=typeof e||!Object.keys(e).every(function(t){return U(e[t])})))throw TypeError("Object containing Nodes expected")}get type(){return rG}get isObjectNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){var r={};for(var n in this.properties)if(K(this.properties,n)){var i=JSON.parse(ej(n)),a=eu(this.properties,n);r[i]=a._compile(e,t)}return function(e,t,n){var i={};for(var a in r)K(r,a)&&(i[a]=r[a](e,t,n));return i}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){for(var t in this.properties)K(this.properties,t)&&e(this.properties[t],"properties["+ej(t)+"]",this)}/**
     * Create a new ObjectNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ObjectNode} Returns a transformed copy of the node
     */map(e){var t={};for(var n in this.properties)K(this.properties,n)&&(t[n]=this._ifNode(e(this.properties[n],"properties["+ej(n)+"]",this)));return new r(t)}/**
     * Create a clone of this node, a shallow copy
     * @return {ObjectNode}
     */clone(){var e={};for(var t in this.properties)K(this.properties,t)&&(e[t]=this.properties[t]);return new r(e)}/**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */_toString(e){var t=[];for(var r in this.properties)K(this.properties,r)&&t.push(ej(r)+": "+this.properties[r].toString(e));return"{"+t.join(", ")+"}"}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:rG,properties:this.properties}}/**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ObjectNode", "properties": {...}}`,
     *                       where mathjs is optional
     * @returns {ObjectNode}
     */static fromJSON(e){return new r(e.properties)}/**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */toHTML(e){var t=[];for(var r in this.properties)K(this.properties,r)&&t.push('<span class="math-symbol math-property">'+eL(r)+'</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>'+this.properties[r].toHTML(e));return'<span class="math-parenthesis math-curly-parenthesis">{</span>'+t.join('<span class="math-separator">,</span>')+'<span class="math-parenthesis math-curly-parenthesis">}</span>'}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */_toTex(e){var t=[];for(var r in this.properties)K(this.properties,r)&&t.push("\\mathbf{"+r+":} & "+this.properties[r].toTex(e)+"\\\\");return"\\left\\{\\begin{array}{ll}"+t.join("\n")+"\\end{array}\\right\\}"}}return /*@__PURE__*/e(et)(r,"name",rG),r},{isClass:!0,isNode:!0}),rW="OperatorNode",rY=ta(rW,["Node"],t=>{var{Node:Node}=t;/**
   * Calculate which parentheses are necessary. Gets an OperatorNode
   * (which is the root of the tree) and an Array of Nodes
   * (this.args) and returns an array where 'true' means that an argument
   * has to be enclosed in parentheses whereas 'false' means the opposite.
   *
   * @param {OperatorNode} root
   * @param {string} parenthesis
   * @param {Node[]} args
   * @param {boolean} latex
   * @return {boolean[]}
   * @private
   */function r(e,t,r,n,i){// precedence of the root OperatorNode
var a=tx(e,t,r),o=tb(e,t);if("all"===t||n.length>2&&"OperatorNode:add"!==e.getIdentifier()&&"OperatorNode:multiply"!==e.getIdentifier())return n.map(function(e){switch(e.getContent().type){// Nodes that don't need extra parentheses
case"ArrayNode":case"ConstantNode":case"SymbolNode":case"ParenthesisNode":return!1;default:return!0}});switch(n.length){case 0:s=[];break;case 1:// precedence of the operand
var s,u,l,c=tx(n[0],t,r,e);// handle special cases for LaTeX, where some of the parentheses aren't needed
if(i&&null!==c&&("keep"===t?(u=n[0].getIdentifier(),l=e.getIdentifier()):(// Ignore Parenthesis Nodes when not in 'keep' mode
u=n[0].getContent().getIdentifier(),l=e.getContent().getIdentifier()),!1===ty[a][l].latexLeftParens||!1===ty[c][u].latexParens)||null===c){s=[!1];break}if(c<=a){// if the operands precedence is lower, parens are needed
s=[!0];break}// otherwise, no parens needed
s=[!1];break;case 2:// precedence of the left hand side
var f,p,m,d,h,g=tx(n[0],t,r,e),y=tN(e,n[0],t);// FunctionNode for example
f=null!==g&&(g===a&&"right"===o&&!y||g<a);// precedence of the right hand side
var v=tx(n[1],t,r,e),x=tN(e,n[1],t);// FunctionNode for example
p=null!==v&&(v===a&&"left"===o&&!x||v<a),i&&("keep"===t?(m=e.getIdentifier(),d=e.args[0].getIdentifier(),h=e.args[1].getIdentifier()):(// Ignore ParenthesisNodes when not in 'keep' mode
m=e.getContent().getIdentifier(),d=e.args[0].getContent().getIdentifier(),h=e.args[1].getContent().getIdentifier()),null!==g&&(!1===ty[a][m].latexLeftParens&&(f=!1),!1===ty[g][d].latexParens&&(f=!1)),null!==v&&(!1===ty[a][m].latexRightParens&&(p=!1),!1===ty[v][h].latexParens&&(p=!1))),s=[f,p];break;default:("OperatorNode:add"===e.getIdentifier()||"OperatorNode:multiply"===e.getIdentifier())&&(s=n.map(function(n){var i=tx(n,t,r,e),s=tN(e,n,t),u=tb(n,t);if(null===i);else if(a===i&&o===u&&!s)return!0;else if(i<a)return!0;return!1}))}// Handles an edge case of parentheses with implicit multiplication
// of ConstantNode.
// In that case, parenthesize ConstantNodes that follow an unparenthesized
// expression, even though they normally wouldn't be printed.
if(n.length>=2&&"OperatorNode:multiply"===e.getIdentifier()&&e.implicit&&"all"!==t&&"hide"===r)for(var b=1;b<s.length;++b)!/**
   * Returns true if the expression starts with a constant, under
   * the current parenthesization:
   * @param {Node} expression
   * @param {string} parenthesis
   * @return {boolean}
   */function e(t,r){var n=t;if("auto"===r)for(;H(n);)n=n.content;return!!k(n)||!!$(n)&&e(n.args[0],r)}(n[b],t)||s[b-1]||"keep"===t&&H(n[b-1])||(s[b]=!0);return s}class n extends Node{/**
     * @constructor OperatorNode
     * @extends {Node}
     * An operator with two arguments, like 2+3
     *
     * @param {string} op           Operator name, for example '+'
     * @param {string} fn           Function name, for example 'add'
     * @param {Node[]} args         Operator arguments
     * @param {boolean} [implicit]  Is this an implicit multiplication?
     * @param {boolean} [isPercentage] Is this an percentage Operation?
     */constructor(e,t,r,n,i){// validate input
if(super(),"string"!=typeof e)throw TypeError('string expected for parameter "op"');if("string"!=typeof t)throw TypeError('string expected for parameter "fn"');if(!Array.isArray(r)||!r.every(U))throw TypeError('Array containing Nodes expected for parameter "args"');this.implicit=!0===n,this.isPercentage=!0===i,this.op=e,this.fn=t,this.args=r||[]}get type(){return rW}get isOperatorNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){// validate fn
if("string"!=typeof this.fn||!ef(e,this.fn)){if(e[this.fn])throw Error('No access to function "'+this.fn+'"');throw Error("Function "+this.fn+' missing in provided namespace "math"')}var r=eu(e,this.fn),n=e4(this.args,function(r){return r._compile(e,t)});if(1===n.length){var i=n[0];return function(e,t,n){return r(i(e,t,n))}}if(2!==n.length)return function(e,t,i){return r.apply(null,e4(n,function(r){return r(e,t,i)}))};var a=n[0],o=n[1];return function(e,t,n){return r(a(e,t,n),o(e,t,n))}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){for(var t=0;t<this.args.length;t++)e(this.args[t],"args["+t+"]",this)}/**
     * Create a new OperatorNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */map(e){for(var t=[],r=0;r<this.args.length;r++)t[r]=this._ifNode(e(this.args[r],"args["+r+"]",this));return new n(this.op,this.fn,t,this.implicit,this.isPercentage)}/**
     * Create a clone of this node, a shallow copy
     * @return {OperatorNode}
     */clone(){return new n(this.op,this.fn,this.args.slice(0),this.implicit,this.isPercentage)}/**
     * Check whether this is an unary OperatorNode:
     * has exactly one argument, like `-a`.
     * @return {boolean}
     *     Returns true when an unary operator node, false otherwise.
     */isUnary(){return 1===this.args.length}/**
     * Check whether this is a binary OperatorNode:
     * has exactly two arguments, like `a + b`.
     * @return {boolean}
     *     Returns true when a binary operator node, false otherwise.
     */isBinary(){return 2===this.args.length}/**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */_toString(e){var t=e&&e.parenthesis?e.parenthesis:"keep",n=e&&e.implicit?e.implicit:"hide",i=this.args,a=r(this,t,n,i,!1);if(1===i.length){// unary operators
var o=tb(this,t),s=i[0].toString(e);a[0]&&(s="("+s+")");// for example for "not", we want a space between operand and argument
var u=/[a-zA-Z]+/.test(this.op);return"right"===o?this.op+(u?" ":"")+s:"left"===o?s+(u?" ":"")+this.op:s+this.op}if(2===i.length){var l=i[0].toString(e),c=i[1].toString(e);// left hand side
return(a[0]&&(l="("+l+")"),a[1]&&(c="("+c+")"),this.implicit&&"OperatorNode:multiply"===this.getIdentifier()&&"hide"===n)?l+" "+c:l+" "+this.op+" "+c}if(!(i.length>2)||"OperatorNode:add"!==this.getIdentifier()&&"OperatorNode:multiply"!==this.getIdentifier())return this.fn+"("+this.args.join(", ")+")";var f=i.map(function(t,r){return t=t.toString(e),a[r]&&(t="("+t+")"),t});return this.implicit&&"OperatorNode:multiply"===this.getIdentifier()&&"hide"===n?f.join(" "):f.join(" "+this.op+" ")}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:rW,op:this.op,fn:this.fn,args:this.args,implicit:this.implicit,isPercentage:this.isPercentage}}/**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "OperatorNode",
     *      "op": "+", "fn": "add", "args": [...],
     *      "implicit": false,
     *      "isPercentage":false}
     *     ```
     *     where mathjs is optional
     * @returns {OperatorNode}
     */static fromJSON(e){return new n(e.op,e.fn,e.args,e.implicit,e.isPercentage)}/**
     * Get HTML representation.
     * @param {Object} options
     * @return {string} str
     */toHTML(e){var t=e&&e.parenthesis?e.parenthesis:"keep",n=e&&e.implicit?e.implicit:"hide",i=this.args,a=r(this,t,n,i,!1);if(1===i.length){// unary operators
var o=tb(this,t),s=i[0].toHTML(e);return(a[0]&&(s='<span class="math-parenthesis math-round-parenthesis">(</span>'+s+'<span class="math-parenthesis math-round-parenthesis">)</span>'),"right"===o)?'<span class="math-operator math-unary-operator math-lefthand-unary-operator">'+eL(this.op)+"</span>"+s:s+'<span class="math-operator math-unary-operator math-righthand-unary-operator">'+eL(this.op)+"</span>"}if(2===i.length){// binary operatoes
var u=i[0].toHTML(e),l=i[1].toHTML(e);// left hand side
return(a[0]&&(u='<span class="math-parenthesis math-round-parenthesis">(</span>'+u+'<span class="math-parenthesis math-round-parenthesis">)</span>'),a[1]&&(l='<span class="math-parenthesis math-round-parenthesis">(</span>'+l+'<span class="math-parenthesis math-round-parenthesis">)</span>'),this.implicit&&"OperatorNode:multiply"===this.getIdentifier()&&"hide"===n)?u+'<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>'+l:u+'<span class="math-operator math-binary-operator math-explicit-binary-operator">'+eL(this.op)+"</span>"+l}var c=i.map(function(t,r){return t=t.toHTML(e),a[r]&&(t='<span class="math-parenthesis math-round-parenthesis">(</span>'+t+'<span class="math-parenthesis math-round-parenthesis">)</span>'),t});return i.length>2&&("OperatorNode:add"===this.getIdentifier()||"OperatorNode:multiply"===this.getIdentifier())?this.implicit&&"OperatorNode:multiply"===this.getIdentifier()&&"hide"===n?c.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>'):c.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">'+eL(this.op)+"</span>"):'<span class="math-function">'+eL(this.fn)+'</span><span class="math-paranthesis math-round-parenthesis">(</span>'+c.join('<span class="math-separator">,</span>')+'<span class="math-paranthesis math-round-parenthesis">)</span>'}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */_toTex(e){var t=e&&e.parenthesis?e.parenthesis:"keep",n=e&&e.implicit?e.implicit:"hide",i=this.args,a=r(this,t,n,i,!0),o=tX[this.fn];if(o=void 0===o?this.op:o,1===i.length){// unary operators
var s=tb(this,t),u=i[0].toTex(e);return(a[0]&&(u="\\left(".concat(u,"\\right)")),"right"===s)?o+u:u+o}if(2===i.length){// binary operators
var l,c=i[0],f=c.toTex(e);// left hand side
a[0]&&(f="\\left(".concat(f,"\\right)"));var p=i[1].toTex(e);switch(a[1]&&(p="\\left(".concat(p,"\\right)")),l="keep"===t?c.getIdentifier():c.getContent().getIdentifier(),this.getIdentifier()){case"OperatorNode:divide":// op contains '\\frac' at this point
return o+"{"+f+"}{"+p+"}";case"OperatorNode:pow":switch(f="{"+f+"}",p="{"+p+"}",l){case"ConditionalNode":case"OperatorNode:divide":f="\\left(".concat(f,"\\right)")}break;case"OperatorNode:multiply":if(this.implicit&&"hide"===n)return f+"~"+p}return f+o+p}if(!(i.length>2)||"OperatorNode:add"!==this.getIdentifier()&&"OperatorNode:multiply"!==this.getIdentifier())// as this is a fallback, it doesn't use
// fancy function names
return"\\mathrm{"+this.fn+"}\\left("+i.map(function(t){return t.toTex(e)}).join(",")+"\\right)";var m=i.map(function(t,r){return t=t.toTex(e),a[r]&&(t="\\left(".concat(t,"\\right)")),t});return"OperatorNode:multiply"===this.getIdentifier()&&this.implicit&&"hide"===n?m.join("~"):m.join(o)}/**
     * Get identifier.
     * @return {string}
     */getIdentifier(){return this.type+":"+this.fn}}return /*@__PURE__*/e(et)(n,"name",rW),n},{isClass:!0,isNode:!0}),rJ="ParenthesisNode",rX=ta(rJ,["Node"],t=>{var{Node:Node}=t;class r extends Node{/**
     * @constructor ParenthesisNode
     * @extends {Node}
     * A parenthesis node describes manual parenthesis from the user input
     * @param {Node} content
     * @extends {Node}
     */constructor(e){// validate input
if(super(),!U(e))throw TypeError('Node expected for parameter "content"');this.content=e}get type(){return rJ}get isParenthesisNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){return this.content._compile(e,t)}/**
     * Get the content of the current Node.
     * @return {Node} content
     * @override
     **/getContent(){return this.content.getContent()}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){e(this.content,"content",this)}/**
     * Create a new ParenthesisNode whose child is the result of calling
     * the provided callback function on the child of this node.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ParenthesisNode} Returns a clone of the node
     */map(e){return new r(e(this.content,"content",this))}/**
     * Create a clone of this node, a shallow copy
     * @return {ParenthesisNode}
     */clone(){return new r(this.content)}/**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */_toString(e){return!e||e&&!e.parenthesis||e&&"keep"===e.parenthesis?"("+this.content.toString(e)+")":this.content.toString(e)}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:rJ,content:this.content}}/**
     * Instantiate an ParenthesisNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ParenthesisNode", "content": ...}`,
     *                       where mathjs is optional
     * @returns {ParenthesisNode}
     */static fromJSON(e){return new r(e.content)}/**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */toHTML(e){return!e||e&&!e.parenthesis||e&&"keep"===e.parenthesis?'<span class="math-parenthesis math-round-parenthesis">(</span>'+this.content.toHTML(e)+'<span class="math-parenthesis math-round-parenthesis">)</span>':this.content.toHTML(e)}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */_toTex(e){return!e||e&&!e.parenthesis||e&&"keep"===e.parenthesis?"\\left(".concat(this.content.toTex(e),"\\right)"):this.content.toTex(e)}}return /*@__PURE__*/e(et)(r,"name",rJ),r},{isClass:!0,isNode:!0}),rQ="parse",rK=ta(rQ,["typed","numeric","config","AccessorNode","ArrayNode","AssignmentNode","BlockNode","ConditionalNode","ConstantNode","FunctionAssignmentNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","RangeNode","RelationalNode","SymbolNode"],t=>{var{typed:r,numeric:n,config:i,AccessorNode:a,ArrayNode:s,AssignmentNode:u,BlockNode:l,ConditionalNode:c,ConstantNode:f,FunctionAssignmentNode:p,FunctionNode:m,IndexNode:d,ObjectNode:h,OperatorNode:g,ParenthesisNode:y,RangeNode:v,RelationalNode:x,SymbolNode:b}=t,N=r(rQ,{string:function(e){return L(e,{})},"Array | Matrix":function(e){return w(e,{})},"string, Object":function(e,t){return L(e,void 0!==t.nodes?t.nodes:{})},"Array | Matrix, Object":w});function w(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=void 0!==t.nodes?t.nodes:{};// parse an array or matrix with expressions
return tq(e,function(e){if("string"!=typeof e)throw TypeError("String expected");return L(e,r)})}// token types enumeration
var D={NULL:0,DELIMITER:1,NUMBER:2,SYMBOL:3,UNKNOWN:4},E={",":!0,"(":!0,")":!0,"[":!0,"]":!0,"{":!0,"}":!0,'"':!0,"'":!0,";":!0,"+":!0,"-":!0,"*":!0,".*":!0,"/":!0,"./":!0,"%":!0,"^":!0,".^":!0,"~":!0,"!":!0,"&":!0,"|":!0,"^|":!0,"=":!0,":":!0,"?":!0,"==":!0,"!=":!0,"<":!0,">":!0,"<=":!0,">=":!0,"<<":!0,">>":!0,">>>":!0},A={mod:!0,to:!0,in:!0,and:!0,xor:!0,or:!0,not:!0},S={true:!0,false:!1,null:null,undefined:void 0},C=["NaN","Infinity"],M={'"':'"',"'":"'","\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"	"};/**
   * View upto `length` characters of the expression starting at the current character.
   *
   * @param {Object} state
   * @param {number} [length=1] Number of characters to view
   * @returns {string}
   * @private
   */function F(e,t){return e.expression.substr(e.index,t)}/**
   * View the current character. Returns '' if end of expression is reached.
   *
   * @param {Object} state
   * @returns {string}
   * @private
   */function B(e){return F(e,1)}/**
   * Get the next character from the expression.
   * The character is stored into the char c. If the end of the expression is
   * reached, the function puts an empty string in c.
   * @private
   */function O(e){e.index++}/**
   * Preview the previous character from the expression.
   * @return {string} cNext
   * @private
   */function _(e){return e.expression.charAt(e.index-1)}/**
   * Preview the next character from the expression.
   * @return {string} cNext
   * @private
   */function z(e){return e.expression.charAt(e.index+1)}/**
   * Get next token in the current string expr.
   * The token and token type are available as token and tokenType
   * @private
   */function q(e){// skip over ignored characters:
for(e.tokenType=D.NULL,e.token="",e.comment="";;){// comments:
if("#"===B(e))for(;"\n"!==B(e)&&""!==B(e);)e.comment+=B(e),O(e);// whitespace: space, tab, and newline when inside parameters
if(N.isWhitespace(B(e),e.nestingLevel))O(e);else break}// check for end of expression
if(""===B(e)){// token is still empty
e.tokenType=D.DELIMITER;return}// check for new line character
if("\n"===B(e)&&!e.nestingLevel){e.tokenType=D.DELIMITER,e.token=B(e),O(e);return}var t=B(e),r=F(e,2),n=F(e,3);if(3===n.length&&E[n]){e.tokenType=D.DELIMITER,e.token=n,O(e),O(e),O(e);return}// check for delimiters consisting of 2 characters
if(2===r.length&&E[r]){e.tokenType=D.DELIMITER,e.token=r,O(e),O(e);return}// check for delimiters consisting of 1 character
if(E[t]){e.tokenType=D.DELIMITER,e.token=t,O(e);return}// check for a number
if(N.isDigitDot(t)){e.tokenType=D.NUMBER;// check for binary, octal, or hex
var i=F(e,2);if("0b"===i||"0o"===i||"0x"===i){for(e.token+=B(e),O(e),e.token+=B(e),O(e);N.isHexDigit(B(e));)e.token+=B(e),O(e);if("."===B(e))// get the digits after the radix
for(// this number has a radix point
e.token+=".",O(e);N.isHexDigit(B(e));)e.token+=B(e),O(e);else if("i"===B(e))// get the word size
for(// this number has a word size suffix
e.token+="i",O(e);N.isDigit(B(e));)e.token+=B(e),O(e);return}// get number, can have a single dot
if("."===B(e)){if(e.token+=B(e),O(e),!N.isDigit(B(e))){// this is no number, it is just a dot (can be dot notation)
e.tokenType=D.DELIMITER;return}}else{for(;N.isDigit(B(e));)e.token+=B(e),O(e);N.isDecimalMark(B(e),z(e))&&(e.token+=B(e),O(e))}for(;N.isDigit(B(e));)e.token+=B(e),O(e);// check for exponential notation like "2.3e-4", "1.23e50" or "2e+4"
if("E"===B(e)||"e"===B(e)){if(N.isDigit(z(e))||"-"===z(e)||"+"===z(e)){// Scientific notation MUST be followed by an exponent
if(e.token+=B(e),O(e),("+"===B(e)||"-"===B(e))&&(e.token+=B(e),O(e)),!N.isDigit(B(e)))throw ep(e,'Digit expected, got "'+B(e)+'"');for(;N.isDigit(B(e));)e.token+=B(e),O(e);if(N.isDecimalMark(B(e),z(e)))throw ep(e,'Digit expected, got "'+B(e)+'"')}else if("."===z(e))throw O(e),ep(e,'Digit expected, got "'+B(e)+'"')}return}// check for variables, functions, named operators
if(N.isAlpha(B(e),_(e),z(e))){for(;N.isAlpha(B(e),_(e),z(e))||N.isDigit(B(e));)e.token+=B(e),O(e);K(A,e.token)?e.tokenType=D.DELIMITER:e.tokenType=D.SYMBOL;return}for(// something unknown is found, wrong characters -> a syntax error
e.tokenType=D.UNKNOWN;""!==B(e);)e.token+=B(e),O(e);throw ep(e,'Syntax error in part "'+e.token+'"')}/**
   * Get next token and skip newline tokens
   */function R(e){do q(e);while("\n"===e.token)// eslint-disable-line no-unmodified-loop-condition
}/**
   * Open parameters.
   * New line characters will be ignored until closeParams(state) is called
   */function j(e){e.nestingLevel++}/**
   * Close parameters.
   * New line characters will no longer be ignored
   */function U(e){e.nestingLevel--}/**
   * Start of the parse levels below, in order of precedence
   * @return {Node} node
   * @private
   */function L(t,r){var n={extraNodes:{},// current extra nodes, must be careful not to mutate
expression:"",// current expression
comment:"",// last parsed comment
index:0,// current index in expr
token:"",// current token
tokenType:D.NULL,// type of the token
nestingLevel:0,// level of nesting inside parameters, used to ignore newline characters
conditionalLevel:null// when a conditional is being parsed, the level of the conditional is stored here
};/*@__PURE__*/e(o)(n,{expression:t,extraNodes:r}),q(n);var i=/**
   * Parse a block with expressions. Expressions can be separated by a newline
   * character '\n', or by a semicolon ';'. In case of a semicolon, no output
   * of the preceding line is returned.
   * @return {Node} node
   * @private
   */function(e){var t,r,n=[];// TODO: simplify this loop
for(""!==e.token&&"\n"!==e.token&&";"!==e.token&&(t=H(e),e.comment&&(t.comment=e.comment));"\n"===e.token||";"===e.token;)0===n.length&&t&&(r=";"!==e.token,n.push({node:t,visible:r})),q(e),"\n"!==e.token&&";"!==e.token&&""!==e.token&&(t=H(e),e.comment&&(t.comment=e.comment),r=";"!==e.token,n.push({node:t,visible:r}));return n.length>0?new l(n):(!t&&(t=new f(void 0),e.comment&&(t.comment=e.comment)),t)}(n);// check for garbage at the end of the expression
// an expression ends with a empty character '' and tokenType DELIMITER
if(""!==n.token){if(n.tokenType===D.DELIMITER)// TODO: give hints for aliases, for example with "<>" give as hint " did you mean !== ?"
throw em(n,"Unexpected operator "+n.token);throw ep(n,'Unexpected part "'+n.token+'"')}return i}/**
   * Assignment of a function or variable,
   * - can be a variable like 'a=2.3'
   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'
   * - defining a function like 'f(x) = x^2'
   * @return {Node} node
   * @private
   */function H(e){var t,r,n,i,a=/**
   * conditional operation
   *
   *     condition ? truePart : falsePart
   *
   * Note: conditional operator is right-associative
   *
   * @return {Node} node
   * @private
   */function(e){for(var t=/**
   * logical or, 'x or y'
   * @return {Node} node
   * @private
   */function(e){for(var t=Z(e);"or"===e.token;)// eslint-disable-line no-unmodified-loop-condition
R(e),t=new g("or","or",[t,Z(e)]);return t}(e);"?"===e.token;){// eslint-disable-line no-unmodified-loop-condition
// set a conditional level, the range operator will be ignored as long
// as conditionalLevel === state.nestingLevel.
var r=e.conditionalLevel;e.conditionalLevel=e.nestingLevel,R(e);var n=t,i=H(e);if(":"!==e.token)throw ep(e,"False part of conditional expression expected");e.conditionalLevel=null,R(e),t=new c(n,i,H(e)),// restore the previous conditional level
e.conditionalLevel=r}return t}(e);if("="===e.token){if(V(a))return(// parse a variable assignment like 'a = 2/3'
t=a.name,R(e),n=H(e),new u(new b(t),n));if(T(a))return(// parse a matrix subset assignment like 'A[1,2] = 4'
R(e),n=H(e),new u(a.object,a.index,n));if(P(a)&&V(a.fn)&&(// parse function assignment like 'f(x) = x^2'
i=!0,r=[],t=a.name,a.args.forEach(function(e,t){V(e)?r[t]=e.name:i=!1}),i))return R(e),new p(t,r,n=H(e));throw ep(e,"Invalid left hand side of assignment operator =")}return a}/**
   * logical exclusive or, 'x xor y'
   * @return {Node} node
   * @private
   */function Z(e){for(var t=G(e);"xor"===e.token;)// eslint-disable-line no-unmodified-loop-condition
R(e),t=new g("xor","xor",[t,G(e)]);return t}/**
   * logical and, 'x and y'
   * @return {Node} node
   * @private
   */function G(e){for(var t=W(e);"and"===e.token;)// eslint-disable-line no-unmodified-loop-condition
R(e),t=new g("and","and",[t,W(e)]);return t}/**
   * bitwise or, 'x | y'
   * @return {Node} node
   * @private
   */function W(e){for(var t=Y(e);"|"===e.token;)// eslint-disable-line no-unmodified-loop-condition
R(e),t=new g("|","bitOr",[t,Y(e)]);return t}/**
   * bitwise exclusive or (xor), 'x ^| y'
   * @return {Node} node
   * @private
   */function Y(e){for(var t=J(e);"^|"===e.token;)// eslint-disable-line no-unmodified-loop-condition
R(e),t=new g("^|","bitXor",[t,J(e)]);return t}/**
   * bitwise and, 'x & y'
   * @return {Node} node
   * @private
   */function J(e){for(var t=X(e);"&"===e.token;)// eslint-disable-line no-unmodified-loop-condition
R(e),t=new g("&","bitAnd",[t,X(e)]);return t}/**
   * Parse a chained conditional, like 'a > b >= c'
   * @return {Node} node
   */function X(e){for(var t=[Q(e)],r=[],n={"==":"equal","!=":"unequal","<":"smaller",">":"larger","<=":"smallerEq",">=":"largerEq"};K(n,e.token);){// eslint-disable-line no-unmodified-loop-condition
var i={name:e.token,fn:n[e.token]};r.push(i),R(e),t.push(Q(e))}return 1===t.length?t[0]:2===t.length?new g(r[0].name,r[0].fn,t):new x(r.map(e=>e.fn),t)}/**
   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
   * @return {Node} node
   * @private
   */function Q(e){t=ee(e);for(var t,r,n,i={"<<":"leftShift",">>":"rightArithShift",">>>":"rightLogShift"};K(i,e.token);)n=i[r=e.token],R(e),t=new g(r,n,[t,ee(e)]);return t}/**
   * conversion operators 'to' and 'in'
   * @return {Node} node
   * @private
   */function ee(e){t=et(e);for(var t,r,n,i={to:"to",in:"to"// alias of 'to'
};K(i,e.token);)n=i[r=e.token],R(e),t="in"===r&&""===e.token?new g("*","multiply",[t,new b("in")],!0):new g(r,n,[t,et(e)]);return t}/**
   * parse range, "start:end", "start:step:end", ":", "start:", ":end", etc
   * @return {Node} node
   * @private
   */function et(e){var t,r=[];if(t=":"===e.token?new f(1):er(e),":"===e.token&&e.conditionalLevel!==e.nestingLevel){// parse step and end
for(// we ignore the range operator when a conditional operator is being processed on the same level
r.push(t);":"===e.token&&r.length<3;)// eslint-disable-line no-unmodified-loop-condition
R(e),")"===e.token||"]"===e.token||","===e.token||""===e.token?r.push(new b("end")):r.push(er(e));t=3===r.length?new v(r[0],r[2],r[1]):new v(r[0],r[1])}return t}/**
   * add or subtract
   * @return {Node} node
   * @private
   */function er(e){t=en(e);for(var t,r,n,i,a={"+":"add","-":"subtract"};K(a,e.token);){n=a[r=e.token],R(e);var o=en(e);i=o.isPercentage?[t,new g("*","multiply",[t,o])]:[t,o],t=new g(r,n,i)}return t}/**
   * multiply, divide, modulus
   * @return {Node} node
   * @private
   */function en(e){t=ei(e);for(var t,r,n,i={"*":"multiply",".*":"dotMultiply","/":"divide","./":"dotDivide"};;)if(K(i,e.token))n=i[// explicit operators
r=e.token],R(e),t=new g(r,n,[t,ei(e)]);else break;return t}/**
   * implicit multiplication
   * @return {Node} node
   * @private
   */function ei(e){var t,r;for(r=t=ea(e);;)if(e.tokenType===D.SYMBOL||"in"===e.token&&k(t)||e.tokenType===D.NUMBER&&!k(r)&&(!$(r)||"!"===r.op)||"("===e.token)t=new g("*","multiply",[t,// parse implicit multiplication
//
// symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'
// number:      implicit multiplication like '(2+3)2'
// parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'
r=ea(e)],!0);else break;return t}/**
   * Infamous "rule 2" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370
   * And as amended in https://github.com/josdejong/mathjs/issues/2370#issuecomment-1054052164
   * Explicit division gets higher precedence than implicit multiplication
   * when the division matches this pattern:
   *   [unaryPrefixOp]?[number] / [number] [symbol]
   * @return {Node} node
   * @private
   */function ea(t){for(var r=eo(t),n=r,i=[];;)// Match the "number /" part of the pattern "number / number symbol"
if("/"===t.token&&I(n)){// Match the "number / number" part of the pattern
if(// Look ahead to see if the next token is a number
i.push(/*@__PURE__*/e(o)({},t)),R(t),t.tokenType===D.NUMBER){// Match the "symbol" part of the pattern, or a left parenthesis
if(// Look ahead again
i.push(/*@__PURE__*/e(o)({},t)),R(t),t.tokenType===D.SYMBOL||"("===t.token)/*@__PURE__*/e(o)(t,i.pop()),i.pop(),r=new g("/","divide",[r,n=eo(t)]);else{// Not a match, so rewind
i.pop(),/*@__PURE__*/e(o)(t,i.pop());break}}else{/*@__PURE__*/e(o)(t,i.pop());break}}else break;return r}/**
   * percentage or mod
   * @return {Node} node
   * @private
   */function eo(e){t=es(e);for(var t,r,n,i={"%":"mod",mod:"mod"};K(i,e.token);)n=i[r=e.token],R(e),t="%"===r&&e.tokenType===D.DELIMITER&&"("!==e.token?new g("/","divide",[t,new f(100)],!1,!0):new g(r,n,[t,es(e)]);return t}/**
   * Unary plus and minus, and logical and bitwise not
   * @return {Node} node
   * @private
   */function es(e){var t,r,a,o,u={"-":"unaryMinus","+":"unaryPlus","~":"bitNot",not:"not"};return K(u,e.token)?(o=u[e.token],a=e.token,R(e),new g(a,o,[es(e)])):(t=/**
   * Left hand operators: factorial x!, ctranspose x'
   * @return {Node} node
   * @private
   */function(e){t=/**
   * Parse a custom node handler. A node handler can be used to process
   * nodes in a custom way, for example for handling a plot.
   *
   * A handler must be passed as second argument of the parse function.
   * - must extend math.Node
   * - must contain a function _compile(defs: Object) : string
   * - must contain a function find(filter: Object) : Node[]
   * - must contain a function toString() : string
   * - the constructor is called with a single argument containing all parameters
   *
   * For example:
   *
   *     nodes = {
   *       'plot': PlotHandler
   *     }
   *
   * The constructor of the handler is called as:
   *
   *     node = new PlotHandler(params)
   *
   * The handler will be invoked when evaluating an expression like:
   *
   *     node = math.parse('plot(sin(x), x)', nodes)
   *
   * @return {Node} node
   * @private
   */function(e){var t,r,a=[];if(e.tokenType===D.SYMBOL&&K(e.extraNodes,e.token)){var o=e.extraNodes[e.token];// parse parameters
if(q(e),"("===e.token){if(a=[],j(e),q(e),")"!==e.token)// parse a list with parameters
for(a.push(H(e));","===e.token;)// eslint-disable-line no-unmodified-loop-condition
q(e),a.push(H(e));if(")"!==e.token)throw ep(e,"Parenthesis ) expected");U(e),q(e)}// create a new custom node
// noinspection JSValidateTypes
return new o(a)}return e.tokenType===D.SYMBOL||e.tokenType===D.DELIMITER&&e.token in A?(t=e.token,q(e),eu(e,K(S,t)?new f(S[t]):-1!==C.indexOf(t)?new f(n(t,"number")):new b(t))):'"'===e.token||"'"===e.token?(// create constant
r=new f(el(e,e.token)),// parse index parameters
r=eu(e,r)):/**
   * parse the matrix
   * @return {Node} node
   * @private
   */function(e){var t,r,a,o;if("["===e.token){if(// matrix [...]
j(e),q(e),"]"!==e.token){// this is a non-empty matrix
var u=ec(e);if(";"===e.token){// the rows of the matrix are separated by dot-comma's
for(// 2 dimensional array
a=1,r=[u];";"===e.token;)// eslint-disable-line no-unmodified-loop-condition
q(e),r[a]=ec(e),a++;if("]"!==e.token)throw ep(e,"End of matrix ] expected");U(e),q(e),// check if the number of columns matches in all rows
o=r[0].items.length;for(var l=1;l<a;l++)if(r[l].items.length!==o)throw em(e,"Column dimensions mismatch ("+r[l].items.length+" !== "+o+")");t=new s(r)}else{// 1 dimensional vector
if("]"!==e.token)throw ep(e,"End of matrix ] expected");U(e),q(e),t=u}}else // this is an empty matrix "[ ]"
U(e),q(e),t=new s([]);return eu(e,t)}return(/**
   * parse an object, enclosed in angle brackets{...}, for example {value: 2}
   * @return {Node} node
   * @private
   */function(e){if("{"===e.token){j(e);var t,r,a={};do if(q(e),"}"!==e.token){// parse key
if('"'===e.token||"'"===e.token)r=el(e,e.token);else if(e.tokenType===D.SYMBOL||e.tokenType===D.DELIMITER&&e.token in A)r=e.token,q(e);else throw ep(e,"Symbol or string expected as object key");// parse key/value separator
if(":"!==e.token)throw ep(e,"Colon : expected after object key");q(e),// parse key
a[r]=H(e)}while(","===e.token)// eslint-disable-line no-unmodified-loop-condition
if("}"!==e.token)throw ep(e,"Comma , or bracket } expected after object value");return U(e),q(e),eu(e,new h(a))}return e.tokenType===D.NUMBER?(// this is a number
t=e.token,q(e),new f(n(t,i.number))):/**
   * parentheses
   * @return {Node} node
   * @private
   */function(e){var t;// check if it is a parenthesized expression
if("("===e.token){if(// parentheses (...)
j(e),q(e),t=H(e),")"!==e.token)throw ep(e,"Parenthesis ) expected");return U(e),q(e),t=eu(e,t=new y(t))}return(/**
   * Evaluated when the expression is not yet ended but expected to end
   * @return {Node} res
   * @private
   */function(e){if(""===e.token)throw ep(e,"Unexpected end of expression");throw ep(e,"Value expected")}(e))}(e)}(e))}(e)}(e);for(var t,r,a,o={"!":"factorial","'":"ctranspose"};K(o,e.token);)a=o[r=e.token],q(e),t=eu(e,t=new g(r,a,[t]));return t}(e),("^"===e.token||".^"===e.token)&&(r=e.token,R(e),t=new g(r,"^"===r?"pow":"dotPow",[t,es(e)])),t)}/**
   * parse accessors:
   * - function invocation in round brackets (...), for example sqrt(2)
   * - index enclosed in square brackets [...], for example A[2,3]
   * - dot notation for properties, like foo.bar
   * @param {Object} state
   * @param {Node} node    Node on which to apply the parameters. If there
   *                       are no parameters in the expression, the node
   *                       itself is returned
   * @param {string[]} [types]  Filter the types of notations
   *                            can be ['(', '[', '.']
   * @return {Node} node
   * @private
   */function eu(e,t,r){for(var n;("("===e.token||"["===e.token||"."===e.token)&&(!r||-1!==r.indexOf(e.token));)if(// eslint-disable-line no-unmodified-loop-condition
n=[],"("===e.token){if(V(t)||T(t)){if(// function invocation like fn(2, 3) or obj.fn(2, 3)
j(e),q(e),")"!==e.token)// parse a list with parameters
for(n.push(H(e));","===e.token;)// eslint-disable-line no-unmodified-loop-condition
q(e),n.push(H(e));if(")"!==e.token)throw ep(e,"Parenthesis ) expected");U(e),q(e),t=new m(t,n)}else break}else if("["===e.token){if(// index notation like variable[2, 3]
j(e),q(e),"]"!==e.token)// parse a list with parameters
for(n.push(H(e));","===e.token;)// eslint-disable-line no-unmodified-loop-condition
q(e),n.push(H(e));if("]"!==e.token)throw ep(e,"Parenthesis ] expected");U(e),q(e),t=new a(t,new d(n))}else{if(// dot notation like variable.prop
q(e),!(e.tokenType===D.SYMBOL||e.tokenType===D.DELIMITER&&e.token in A))throw ep(e,"Property name expected after dot");n.push(new f(e.token)),q(e),t=new a(t,new d(n,!0))}return t}/**
   * Parse a string surrounded by single or double quotes
   * @param {Object} state
   * @param {"'" | "\""} quote
   * @return {string}
   */function el(e,t){for(var r="";""!==B(e)&&B(e)!==t;)if("\\"===B(e)){O(e);var n=B(e),i=M[n];if(void 0!==i)// an escaped control character like \" or \n
r+=i,e.index+=1;else if("u"===n){// escaped unicode character
var a=e.expression.slice(e.index+1,e.index+5);if(/^[0-9A-Fa-f]{4}$/.test(a))// test whether the string holds four hexadecimal values
r+=String.fromCharCode(parseInt(a,16)),e.index+=5;else throw ep(e,"Invalid unicode character \\u".concat(a))}else throw ep(e,"Bad escape character \\".concat(n))}else // any regular character
r+=B(e),O(e);if(q(e),e.token!==t)throw ep(e,"End of string ".concat(t," expected"));return q(e),r}/**
   * Parse a single comma-separated row from a matrix, like 'a, b, c'
   * @return {ArrayNode} node
   */function ec(e){for(var t=[H(e)],r=1;","===e.token;)// eslint-disable-line no-unmodified-loop-condition
q(e),// parse expression
t[r]=H(e),r++;return new s(t)}/**
   * Shortcut for getting the current row value (one based)
   * Returns the line of the currently handled expression
   * @private
   *//* TODO: implement keeping track on the row number
  function row () {
    return null
  }
  *//**
   * Shortcut for getting the current col value (one based)
   * Returns the column (position) where the last state.token starts
   * @private
   */function ef(e){return e.index-e.token.length+1}/**
   * Create an error
   * @param {Object} state
   * @param {string} message
   * @return {SyntaxError} instantiated error
   * @private
   */function ep(e,t){var r=ef(e),n=SyntaxError(t+" (char "+r+")");return n.char=r,n}/**
   * Create an error
   * @param {Object} state
   * @param {string} message
   * @return {Error} instantiated error
   * @private
   */function em(e,t){var r=ef(e),n=SyntaxError(t+" (char "+r+")");return n.char=r,n}return(/**
   * Checks whether the current character `c` is a valid alpha character:
   *
   * - A latin letter (upper or lower case) Ascii: a-z, A-Z
   * - An underscore                        Ascii: _
   * - A dollar sign                        Ascii: $
   * - A latin letter with accents          Unicode: \u00C0 - \u02AF
   * - A greek letter                       Unicode: \u0370 - \u03FF
   * - A mathematical alphanumeric symbol   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
   *
   * The previous and next characters are needed to determine whether
   * this character is part of a unicode surrogate pair.
   *
   * @param {string} c      Current character in the expression
   * @param {string} cPrev  Previous character
   * @param {string} cNext  Next character
   * @return {boolean}
   */N.isAlpha=function(e,t,r){return N.isValidLatinOrGreek(e)||N.isValidMathSymbol(e,r)||N.isValidMathSymbol(t,e)},/**
   * Test whether a character is a valid latin, greek, or letter-like character
   * @param {string} c
   * @return {boolean}
   */N.isValidLatinOrGreek=function(e){return/^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(e)},/**
   * Test whether two given 16 bit characters form a surrogate pair of a
   * unicode math symbol.
   *
   * https://unicode-table.com/en/
   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode
   *
   * Note: In ES6 will be unicode aware:
   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes
   * https://mathiasbynens.be/notes/es6-unicode-regex
   *
   * @param {string} high
   * @param {string} low
   * @return {boolean}
   */N.isValidMathSymbol=function(e,t){return/^[\uD835]$/.test(e)&&/^[\uDC00-\uDFFF]$/.test(t)&&/^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(t)},/**
   * Check whether given character c is a white space character: space, tab, or enter
   * @param {string} c
   * @param {number} nestingLevel
   * @return {boolean}
   */N.isWhitespace=function(e,t){// TODO: also take '\r' carriage return as newline? Or does that give problems on mac?
return" "===e||"	"===e||"\n"===e&&t>0},/**
   * Test whether the character c is a decimal mark (dot).
   * This is the case when it's not the start of a delimiter '.*', './', or '.^'
   * @param {string} c
   * @param {string} cNext
   * @return {boolean}
   */N.isDecimalMark=function(e,t){return"."===e&&"/"!==t&&"*"!==t&&"^"!==t},/**
   * checks if the given char c is a digit or dot
   * @param {string} c   a string with one character
   * @return {boolean}
   */N.isDigitDot=function(e){return e>="0"&&e<="9"||"."===e},/**
   * checks if the given char c is a digit
   * @param {string} c   a string with one character
   * @return {boolean}
   */N.isDigit=function(e){return e>="0"&&e<="9"},/**
   * checks if the given char c is a hex digit
   * @param {string} c   a string with one character
   * @return {boolean}
   */N.isHexDigit=function(e){return e>="0"&&e<="9"||e>="a"&&e<="f"||e>="A"&&e<="F"},// Now that we can parse, automatically convert strings to Nodes by parsing
r.addConversion({from:"string",to:"Node",convert:N}),N)}),r0="parser",r1=ta(r0,["typed","Parser"],e=>{var{typed:t,Parser:r}=e;/**
   * Create a parser. The function creates a new `math.Parser` object.
   *
   * Syntax:
   *
   *    math.parser()
   *
   * Examples:
   *
   *     const parser = new math.parser()
   *
   *     // evaluate expressions
   *     const a = parser.evaluate('sqrt(3^2 + 4^2)') // 5
   *     const b = parser.evaluate('sqrt(-4)')        // 2i
   *     const c = parser.evaluate('2 inch in cm')    // 5.08 cm
   *     const d = parser.evaluate('cos(45 deg)')     // 0.7071067811865476
   *
   *     // define variables and functions
   *     parser.evaluate('x = 7 / 2')             // 3.5
   *     parser.evaluate('x + 3')                 // 6.5
   *     parser.evaluate('f(x, y) = x^y')         // f(x, y)
   *     parser.evaluate('f(2, 3)')               // 8
   *
   *     // get and set variables and functions
   *     const x = parser.get('x')                // 3.5
   *     const f = parser.get('f')                // function
   *     const g = f(3, 2)                        // 9
   *     parser.set('h', 500)
   *     const i = parser.evaluate('h / 2')       // 250
   *     parser.set('hello', function (name) {
   *       return 'hello, ' + name + '!'
   *     })
   *     parser.evaluate('hello("user")')         // "hello, user!"
   *
   *     // clear defined functions and variables
   *     parser.clear()
   *
   * See also:
   *
   *    evaluate, compile, parse
   *
   * @return {Parser} Parser
   */return t(r0,{"":function(){return new r}})}),r2=ta("Parser",["evaluate"],e=>{var{evaluate:t}=e;/**
   * @constructor Parser
   * Parser contains methods to evaluate or parse expressions, and has a number
   * of convenience methods to get, set, and remove variables from memory. Parser
   * keeps a scope containing variables in memory, which is used for all
   * evaluations.
   *
   * Methods:
   *    const result = parser.evaluate(expr)  // evaluate an expression
   *    const value = parser.get(name)        // retrieve a variable from the parser
   *    const values = parser.getAll()        // retrieve all defined variables
   *    parser.set(name, value)               // set a variable in the parser
   *    parser.remove(name)                   // clear a variable from the
   *                                          // parsers scope
   *    parser.clear()                        // clear the parsers scope
   *
   * Example usage:
   *    const parser = new Parser()
   *    // Note: there is a convenience method which can be used instead:
   *    // const parser = new math.parser()
   *
   *    // evaluate expressions
   *    parser.evaluate('sqrt(3^2 + 4^2)')        // 5
   *    parser.evaluate('sqrt(-4)')               // 2i
   *    parser.evaluate('2 inch in cm')           // 5.08 cm
   *    parser.evaluate('cos(45 deg)')            // 0.7071067811865476
   *
   *    // define variables and functions
   *    parser.evaluate('x = 7 / 2')              // 3.5
   *    parser.evaluate('x + 3')                  // 6.5
   *    parser.evaluate('f(x, y) = x^y')          // f(x, y)
   *    parser.evaluate('f(2, 3)')                // 8
   *
   *    // get and set variables and functions
   *    const x = parser.get('x')                 // 3.5
   *    const f = parser.get('f')                 // function
   *    const g = f(3, 2)                         // 9
   *    parser.set('h', 500)
   *    const i = parser.evaluate('h / 2')        // 250
   *    parser.set('hello', function (name) {
   *        return 'hello, ' + name + '!'
   *    })
   *    parser.evaluate('hello("user")')          // "hello, user!"
   *
   *    // clear defined functions and variables
   *    parser.clear()
   *
   */function r(){if(!(this instanceof r))throw SyntaxError("Constructor must be called with the new operator");Object.defineProperty(this,"scope",{value:rs(),writable:!1})}return(/**
   * Attach type information
   */r.prototype.type="Parser",r.prototype.isParser=!0,/**
   * Parse and evaluate the given expression
   * @param {string | string[]} expr   A string containing an expression,
   *                                   for example "2+3", or a list with expressions
   * @return {*} result     The result, or undefined when the expression was empty
   * @throws {Error}
   */r.prototype.evaluate=function(e){// TODO: validate arguments
return t(e,this.scope)},/**
   * Get a variable (a function or variable) by name from the parsers scope.
   * Returns undefined when not found
   * @param {string} name
   * @return {* | undefined} value
   */r.prototype.get=function(e){// TODO: validate arguments
if(this.scope.has(e))return this.scope.get(e)},/**
   * Get a map with all defined variables
   * @return {Object} values
   */r.prototype.getAll=function(){return function(e){if(e instanceof ro)return e.wrappedObject;var t={};for(var r of e.keys()){var n=e.get(r);el(t,r,n)}return t}(this.scope)},/**
   * Get a map with all defined variables
   * @return {Map} values
   */r.prototype.getAllAsMap=function(){return this.scope},/**
   * Set a symbol (a function or variable) by name from the parsers scope.
   * @param {string} name
   * @param {* | undefined} value
   */r.prototype.set=function(e,t){return this.scope.set(e,t),t},/**
   * Remove a variable from the parsers scope
   * @param {string} name
   */r.prototype.remove=function(e){this.scope.delete(e)},/**
   * Clear the scope with variables and functions
   */r.prototype.clear=function(){this.scope.clear()},r)},{isClass:!0}),r3=/\$([\w.]+)/g,r4="print",r5=ta(r4,["typed"],e=>{var{typed:t}=e;/**
   * Interpolate values into a string template.
   *
   * Syntax:
   *
   *     math.print(template, values)
   *     math.print(template, values, precision)
   *     math.print(template, values, options)
   *
   * Example usage:
   *
   *     // the following outputs: 'Lucy is 5 years old'
   *     math.print('Lucy is $age years old', {age: 5})
   *
   *     // the following outputs: 'The value of pi is 3.141592654'
   *     math.print('The value of pi is $pi', {pi: math.pi}, 10)
   *
   *     // the following outputs: 'hello Mary! The date is 2013-03-23'
   *     math.print('Hello $user.name! The date is $date', {
   *       user: {
   *         name: 'Mary',
   *       },
   *       date: new Date(2013, 2, 23).toISOString().substring(0, 10)
   *     })
   *
   *     // the following outputs: 'My favorite fruits are apples and bananas !'
   *     math.print('My favorite fruits are $0 and $1 !', [
   *       'apples',
   *       'bananas'
   *     ])
   *
   * See also:
   *
   *     format
   *
   * @param {string} template           A string containing variable placeholders.
   * @param {Object | Array | Matrix}   values An object or array containing variables
   *                                    which will be filled in in the template.
   * @param {number | Object} [options] Formatting options,
   *                                    or the number of digits to format numbers.
   *                                    See function math.format for a description
   *                                    of all options.
   * @return {string} Interpolated string
   */return t(r4,{// note: Matrix will be converted automatically to an Array
"string, Object | Array":r8,"string, Object | Array, number | Object":r8})});/**
 * Interpolate values into a string template.
 * @param {string} template
 * @param {Object} values
 * @param {number | Object} [options]
 * @returns {string} Interpolated string
 * @private
 */function r8(e,t,r){return e.replace(r3,function(e,n){var i=n.split("."),a=t[i.shift()];for(void 0!==a&&a.isMatrix&&(a=a.toArray());i.length&&void 0!==a;){var o=i.shift();a=o?a[o]:a+"."}return void 0!==a?d(a)?a:eP(a,r):e})}var r6="print",r7=ta(r6,["typed","matrix","zeros","add"],e=>{var{typed:t,matrix:r,zeros:n,add:i}=e,a=r5({typed:t,matrix:r,zeros:n,add:i});return t(r6,{"string, Object | Array":function(e,t){return a(o(e),t)},"string, Object | Array, number | Object":function(e,t,r){return a(o(e),t,r)}});function o(e){return e.replace(r3,e=>"$"+e.slice(1).split(".").map(function(e){return!isNaN(e)&&e.length>0?parseInt(e)-1:e}).join("."))}},{isTransformFunction:!0}),r9="quantileSeq",ne=ta(r9,["typed","?bignumber","add","subtract","divide","multiply","partitionSelect","compare","isInteger","smaller","smallerEq","larger"],e=>{var{typed:t,bignumber:r,add:n,subtract:i,divide:a,multiply:o,partitionSelect:s,compare:u,isInteger:c,smaller:f,smallerEq:p,larger:m}=e,d=tp({typed:t,isInteger:c});/**
   * Compute the prob order quantile of a matrix or a list with values.
   * The sequence is sorted and the middle value is returned.
   * Supported types of sequence values are: Number, BigNumber, Unit
   * Supported types of probability are: Number, BigNumber
   *
   * In case of a multidimensional array or matrix, the prob order quantile
   * of all elements will be calculated.
   *
   * Syntax:
   *
   *     math.quantileSeq(A, prob[, sorted])
   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])
   *     math.quantileSeq(A, N[, sorted])
   *
   * Examples:
   *
   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4
   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]
   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]
   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4
   *
   * See also:
   *
   *     median, mean, min, max, sum, prod, std, variance
   *
   * @param {Array, Matrix} data                A single matrix or Array
   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is
   *                                            the amount of evenly distributed steps of
   *                                            probabilities; only one of these options can
   *                                            be provided
   * @param {Boolean} sorted=false              is data sorted in ascending order
   * @return {Number, BigNumber, Unit, Array}   Quantile(s)
   */return t(r9,{"Array | Matrix, number | BigNumber":(e,t)=>g(e,t,!1),"Array | Matrix, number | BigNumber, number":(e,t,r)=>h(e,t,!1,r,g),"Array | Matrix, number | BigNumber, boolean":g,"Array | Matrix, number | BigNumber, boolean, number":(e,t,r,n)=>h(e,t,r,n,g),"Array | Matrix, Array | Matrix":(e,t)=>y(e,t,!1),"Array | Matrix, Array | Matrix, number":(e,t,r)=>h(e,t,!1,r,y),"Array | Matrix, Array | Matrix, boolean":y,"Array | Matrix, Array | Matrix, boolean, number":(e,t,r,n)=>h(e,t,r,n,y)});function h(e,t,r,n,i){return d(e,n,e=>i(e,t,r))}function g(e,t,i){var o,s=e.valueOf();if(f(t,0))throw Error("N/prob must be non-negative");if(p(t,1))return l(t)?v(s,t,i):r(v(s,t,i));if(m(t,1)){// quantileSeq([a, b, c, d, ...], N[,sorted])
if(!c(t))throw Error("N must be a positive integer");// largest possible Array length is 2^32-1
// 2^32 < 10^15, thus safe conversion guaranteed
if(m(t,4294967295))throw Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");var u=n(t,1);o=[];for(var d=0;f(d,t);d++){var h=a(d+1,u);o.push(v(s,h,i))}return l(t)?o:r(o)}}/**
   * Calculate the prob order quantile of an n-dimensional array.
   *
   * @param {Array, Matrix} array
   * @param {Array, Matrix} prob
   * @param {Boolean} sorted
   * @return {Number, BigNumber, Unit} prob order quantile
   * @private
   */function y(e,t,r){for(var n=e.valueOf(),i=t.valueOf(),a=[],o=0;o<i.length;++o)a.push(v(n,i[o],r));return a}/**
   * Calculate the prob order quantile of an n-dimensional array.
   *
   * @param {Array} array
   * @param {Number, BigNumber} prob
   * @param {Boolean} sorted
   * @return {Number, BigNumber, Unit} prob order quantile
   * @private
   */function v(e,t,r){var a,f,p=e3(e),m=p.length;if(0===m)throw Error("Cannot calculate quantile of an empty sequence");var d=l(t)?t*(m-1):t.times(m-1),h=l(t)?Math.floor(d):d.floor().toNumber(),g=l(t)?d%1:d.minus(h);if(c(d))return r?p[d]:s(p,l(t)?d:d.valueOf());if(r)a=p[h],f=p[h+1];else{f=s(p,h+1),// max of partition is kth largest
a=p[h];for(var y=0;y<h;++y)u(p[y],a)>0&&(a=p[y])}// Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]
return n(o(a,i(1,g)),o(f,g))}}),nt=ta("quantileSeq",["typed","bignumber","add","subtract","divide","multiply","partitionSelect","compare","isInteger","smaller","smallerEq","larger"],e=>{var{typed:t,bignumber:r,add:n,subtract:i,divide:a,multiply:o,partitionSelect:s,compare:u,isInteger:l,smaller:c,smallerEq:f,larger:p}=e,m=ne({typed:t,bignumber:r,add:n,subtract:i,divide:a,multiply:o,partitionSelect:s,compare:u,isInteger:l,smaller:c,smallerEq:f,larger:p});return t("quantileSeq",{"Array | Matrix, number | BigNumber":m,"Array | Matrix, number | BigNumber, number":(e,t,r)=>m(e,t,d(r)),"Array | Matrix, number | BigNumber, boolean":m,"Array | Matrix, number | BigNumber, boolean, number":(e,t,r,n)=>m(e,t,r,d(n)),"Array | Matrix, Array | Matrix":m,"Array | Matrix, Array | Matrix, number":(e,t,r)=>m(e,t,d(r)),"Array | Matrix, Array | Matrix, boolean":m,"Array | Matrix, Array | Matrix, boolean, number":(e,t,r,n)=>m(e,t,r,d(n))});function d(e){// TODO: find a better way, maybe lastDimToZeroBase could apply to more cases.
return rn([[],e])[1]}},{isTransformFunction:!0}),nr="RangeNode",nn=ta(nr,["Node"],t=>{var{Node:Node}=t;/**
   * Calculate the necessary parentheses
   * @param {Node} node
   * @param {string} parenthesis
   * @param {string} implicit
   * @return {Object} parentheses
   * @private
   */function r(e,t,r){var n=tx(e,t,r),i={},a=tx(e.start,t,r);if(i.start=null!==a&&a<=n||"all"===t,e.step){var o=tx(e.step,t,r);i.step=null!==o&&o<=n||"all"===t}var s=tx(e.end,t,r);return i.end=null!==s&&s<=n||"all"===t,i}class n extends Node{/**
     * @constructor RangeNode
     * @extends {Node}
     * create a range
     * @param {Node} start  included lower-bound
     * @param {Node} end    included upper-bound
     * @param {Node} [step] optional step
     */constructor(e,t,r){// validate inputs
if(super(),!U(e)||!U(t)||r&&!U(r))throw TypeError("Node expected");if(arguments.length>3)throw Error("Too many arguments");this.start=e,this.end=t,this.step=r||null}get type(){return nr}get isRangeNode(){return!0}/**
     * Check whether the RangeNode needs the `end` symbol to be defined.
     * This end is the size of the Matrix in current dimension.
     * @return {boolean}
     */needsEnd(){return this.filter(function(e){return V(e)&&"end"===e.name}).length>0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){var r=e.range,n=this.start._compile(e,t),i=this.end._compile(e,t);if(!this.step)return function(e,t,a){return r(n(e,t,a),i(e,t,a))};var a=this.step._compile(e,t);return function(e,t,o){return r(n(e,t,o),i(e,t,o),a(e,t,o))}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){e(this.start,"start",this),e(this.end,"end",this),this.step&&e(this.step,"step",this)}/**
     * Create a new RangeNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RangeNode} Returns a transformed copy of the node
     */map(e){return new n(this._ifNode(e(this.start,"start",this)),this._ifNode(e(this.end,"end",this)),this.step&&this._ifNode(e(this.step,"step",this)))}/**
     * Create a clone of this node, a shallow copy
     * @return {RangeNode}
     */clone(){return new n(this.start,this.end,this.step&&this.step)}/**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */_toString(e){var t,n=r(this,e&&e.parenthesis?e.parenthesis:"keep",e&&e.implicit),i=this.start.toString(e);if(n.start&&(i="("+i+")"),t=i,this.step){var a=this.step.toString(e);n.step&&(a="("+a+")"),t+=":"+a}var o=this.end.toString(e);return n.end&&(o="("+o+")"),t+=":"+o}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:nr,start:this.start,end:this.end,step:this.step}}/**
     * Instantiate an RangeNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "RangeNode", "start": ..., "end": ..., "step": ...}`,
     *     where mathjs is optional
     * @returns {RangeNode}
     */static fromJSON(e){return new n(e.start,e.end,e.step)}/**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */toHTML(e){var t,n=r(this,e&&e.parenthesis?e.parenthesis:"keep",e&&e.implicit),i=this.start.toHTML(e);if(n.start&&(i='<span class="math-parenthesis math-round-parenthesis">(</span>'+i+'<span class="math-parenthesis math-round-parenthesis">)</span>'),t=i,this.step){var a=this.step.toHTML(e);n.step&&(a='<span class="math-parenthesis math-round-parenthesis">(</span>'+a+'<span class="math-parenthesis math-round-parenthesis">)</span>'),t+='<span class="math-operator math-range-operator">:</span>'+a}var o=this.end.toHTML(e);return n.end&&(o='<span class="math-parenthesis math-round-parenthesis">(</span>'+o+'<span class="math-parenthesis math-round-parenthesis">)</span>'),t+='<span class="math-operator math-range-operator">:</span>'+o}/**
     * Get LaTeX representation
     * @params {Object} options
     * @return {string} str
     */_toTex(e){var t=r(this,e&&e.parenthesis?e.parenthesis:"keep",e&&e.implicit),n=this.start.toTex(e);if(t.start&&(n="\\left(".concat(n,"\\right)")),this.step){var i=this.step.toTex(e);t.step&&(i="\\left(".concat(i,"\\right)")),n+=":"+i}var a=this.end.toTex(e);return t.end&&(a="\\left(".concat(a,"\\right)")),n+=":"+a}}return /*@__PURE__*/e(et)(n,"name",nr),n},{isClass:!0,isNode:!0});function ni(){throw Error('No "bignumber" implementation available')}function na(){throw Error('No "fraction" implementation available')}function no(){throw Error('No "matrix" implementation available')}var ns="range",nu=ta(ns,["typed","config","?matrix","?bignumber","smaller","smallerEq","larger","largerEq","add","isPositive"],e=>{var{typed:t,config:r,matrix:n,bignumber:i,smaller:a,smallerEq:o,larger:s,largerEq:u,add:l,isPositive:c}=e;/**
   * Create an array from a range.
   * By default, the range end is excluded. This can be customized by providing
   * an extra parameter `includeEnd`.
   *
   * Syntax:
   *
   *     math.range(str [, includeEnd])               // Create a range from a string,
   *                                                  // where the string contains the
   *                                                  // start, optional step, and end,
   *                                                  // separated by a colon.
   *     math.range(start, end [, includeEnd])        // Create a range with start and
   *                                                  // end and a step size of 1.
   *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,
   *                                                  // and end.
   *
   * Where:
   *
   * - `str: string`
   *   A string 'start:end' or 'start:step:end'
   * - `start: {number | BigNumber | Unit}`
   *   Start of the range
   * - `end: number | BigNumber | Unit`
   *   End of the range, excluded by default, included when parameter includeEnd=true
   * - `step: number | BigNumber | Unit`
   *   Step size. Default value is 1.
   * - `includeEnd: boolean`
   *   Option to specify whether to include the end or not. False by default.
   *
   * Examples:
   *
   *     math.range(2, 6)        // [2, 3, 4, 5]
   *     math.range(2, -3, -1)   // [2, 1, 0, -1, -2]
   *     math.range('2:1:6')     // [2, 3, 4, 5]
   *     math.range(2, 6, true)  // [2, 3, 4, 5, 6]
   *     math.range(math.unit(2, 'm'), math.unit(-3, 'm'), math.unit(-1, 'm')) // [2 m, 1 m, 0 m , -1 m, -2 m]
   *
   * See also:
   *
   *     ones, zeros, size, subset
   *
   * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.
   * @return {Array | Matrix} range
   */return t(ns,{// TODO: simplify signatures when typed-function supports default values and optional arguments
// TODO: a number or boolean should not be converted to string here
string:p,"string, boolean":p,"number, number":function(e,t){return f(m(e,t,1,!1))},"number, number, number":function(e,t,r){return f(m(e,t,r,!1))},"number, number, boolean":function(e,t,r){return f(m(e,t,1,r))},"number, number, number, boolean":function(e,t,r,n){return f(m(e,t,r,n))},"BigNumber, BigNumber":function(e,t){var r=e.constructor;return f(m(e,t,new r(1),!1))},"BigNumber, BigNumber, BigNumber":function(e,t,r){return f(m(e,t,r,!1))},"BigNumber, BigNumber, boolean":function(e,t,r){var n=e.constructor;return f(m(e,t,new n(1),r))},"BigNumber, BigNumber, BigNumber, boolean":function(e,t,r,n){return f(m(e,t,r,n))},"Unit, Unit, Unit":function(e,t,r){return f(m(e,t,r,!1))},"Unit, Unit, Unit, boolean":function(e,t,r,n){return f(m(e,t,r,n))}});function f(e){return"Matrix"===r.matrix?n?n(e):no():e}function p(e,t){var n=/**
   * Parse a string into a range,
   * The string contains the start, optional step, and end, separated by a colon.
   * If the string does not contain a valid range, null is returned.
   * For example str='0:2:11'.
   * @param {string} str
   * @return {{start: number, end: number, step: number} | null} range Object containing properties start, end, step
   * @private
   */function(e){// number
var t=e.split(":").map(function(e){// use Number and not parseFloat as Number returns NaN on invalid garbage in the string
return Number(e)});if(t.some(function(e){return isNaN(e)}))return null;switch(t.length){case 2:return{start:t[0],end:t[1],step:1};case 3:return{start:t[0],end:t[2],step:t[1]};default:return null}}(e);if(!n)throw SyntaxError('String "'+e+'" is no valid range');return"BigNumber"===r.number?(void 0===i&&ni(),f(m(i(n.start),i(n.end),i(n.step)),t)):f(m(n.start,n.end,n.step,t))}/**
   * Create a range with numbers or BigNumbers
   * @param {number | BigNumber | Unit} start
   * @param {number | BigNumber | Unit} end
   * @param {number | BigNumber | Unit} step
   * @param {boolean} includeEnd
   * @returns {Array} range
   * @private
   */function m(e,t,r,n){for(var i=[],f=c(r)?n?o:a:n?u:s,p=e;f(p,t);)i.push(p),p=l(p,r);return i}}),nl=ta("range",["typed","config","?matrix","?bignumber","smaller","smallerEq","larger","largerEq","add","isPositive"],e=>{var{typed:t,config:r,matrix:n,bignumber:i,smaller:a,smallerEq:o,larger:s,largerEq:u,add:l,isPositive:c}=e,f=nu({typed:t,config:r,matrix:n,bignumber:i,smaller:a,smallerEq:o,larger:s,largerEq:u,add:l,isPositive:c});/**
   * Attach a transform function to math.range
   * Adds a property transform containing the transform function.
   *
   * This transform creates a range which includes the end value
   */return t("range",{"...any":function(e){var t=e.length-1;return"boolean"!=typeof e[t]&&e.push(!0),f.apply(null,e)}})},{isTransformFunction:!0}),nc="rationalize",nf=ta(nc,["config","typed","equal","isZero","add","subtract","multiply","divide","pow","parse","simplifyConstant","simplifyCore","simplify","?bignumber","?fraction","mathWithTransform","matrix","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","SymbolNode","ParenthesisNode"],e=>{var{config:t,typed:r,equal:n,isZero:i,add:a,subtract:o,multiply:s,divide:u,pow:l,parse:c,simplifyConstant:f,simplifyCore:p,simplify:m,fraction:d,bignumber:h,mathWithTransform:g,matrix:y,AccessorNode:v,ArrayNode:x,ConstantNode:b,FunctionNode:N,IndexNode:w,ObjectNode:D,OperatorNode:E,SymbolNode:A,ParenthesisNode:S}=e;/**
   * Transform a rationalizable expression in a rational fraction.
   * If rational fraction is one variable polynomial then converts
   * the numerator and denominator in canonical form, with decreasing
   * exponents, returning the coefficients of numerator.
   *
   * Syntax:
   *
   *     math.rationalize(expr)
   *     math.rationalize(expr, detailed)
   *     math.rationalize(expr, scope)
   *     math.rationalize(expr, scope, detailed)
   *
   * Examples:
   *
   *     math.rationalize('sin(x)+y')
   *                   //  Error: There is an unsolved function call
   *     math.rationalize('2x/y - y/(x+1)')
   *                   // (2*x^2-y^2+2*x)/(x*y+y)
   *     math.rationalize('(2x+1)^6')
   *                   // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1
   *     math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')
   *                   // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)
   *     math.rationalize('x/(1-x)/(x-2)/(x-3)/(x-4) + 2x/ ( (1-2x)/(2-3x) )/ ((3-4x)/(4-5x) )') =
   *                   // (-30*x^7+344*x^6-1506*x^5+3200*x^4-3472*x^3+1846*x^2-381*x)/
   *                   //     (-8*x^6+90*x^5-383*x^4+780*x^3-797*x^2+390*x-72)
   *
   *     math.rationalize('x+x+x+y',{y:1}) // 3*x+1
   *     math.rationalize('x+x+x+y',{})    // 3*x+y
   *
   *     const ret = math.rationalize('x+x+x+y',{},true)
   *                   // ret.expression=3*x+y, ret.variables = ["x","y"]
   *     const ret = math.rationalize('-2+5x^2',{},true)
   *                   // ret.expression=5*x^2-2, ret.variables = ["x"], ret.coefficients=[-2,0,5]
   *
   * See also:
   *
   *     simplify
   *
   * @param  {Node|string} expr    The expression to check if is a polynomial expression
   * @param  {Object|boolean}      optional scope of expression or true for already evaluated rational expression at input
   * @param  {Boolean}  detailed   optional True if return an object, false if return expression node (default)
   *
   * @return {Object | Node}    The rational polynomial of `expr` or an object
   *            `{expression, numerator, denominator, variables, coefficients}`, where
   *              `expression` is a `Node` with the node simplified expression,
   *              `numerator` is a `Node` with the simplified numerator of expression,
   *              `denominator` is a `Node` or `boolean` with the simplified denominator or `false` (if there is no denominator),
   *              `variables` is an array with variable names,
   *              and `coefficients` is an array with coefficients of numerator sorted by increased exponent
   *           {Expression Node}  node simplified expression
   *
   */function C(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=(u=[p,// sCore
{l:"n+n",r:"2*n"},{l:"n+-n",r:"0"},f,// sConstant
{l:"n*(n1^-1)",r:"n/n1"},{l:"n*n1^-n2",r:"n/n1^n2"},{l:"n1^-1",r:"1/n1"},{l:"n*(n1/n2)",r:"(n*n1)/n2"},{l:"1*n",r:"n"}],l=[{l:"(-n1)/(-n2)",r:"n1/n2"},// Unary division
{l:"(-n1)*(-n2)",r:"n1*n2"},// Unary multiplication
{l:"n1--n2",r:"n1+n2"},// '--' elimination
{l:"n1-n2",r:"n1+(-n2)"},// Subtraction turn into add with un�ry minus
{l:"(n1+n2)*n3",r:"(n1*n3 + n2*n3)"},// Distributive 1
{l:"n1*(n2+n3)",r:"(n1*n2+n1*n3)"},// Distributive 2
{l:"c1*n + c2*n",r:"(c1+c2)*n"},// Joining constants
{l:"c1*n + n",r:"(c1+1)*n"},// Joining constants
{l:"c1*n - c2*n",r:"(c1-c2)*n"},// Joining constants
{l:"c1*n - n",r:"(c1-1)*n"},// Joining constants
{l:"v/c",r:"(1/c)*v"},// variable/constant (new!)
{l:"v/-c",r:"-(1/c)*v"},// variable/constant (new!)
{l:"-v*-c",r:"c*v"},// Inversion constant and variable 1
{l:"-v*c",r:"-c*v"},// Inversion constant and variable 2
{l:"v*-c",r:"-c*v"},// Inversion constant and variable 3
{l:"v*c",r:"c*v"},// Inversion constant and variable 4
{l:"-(-n1*n2)",r:"(n1*n2)"},// Unary propagation
{l:"-(n1*n2)",r:"(-n1*n2)"},// Unary propagation
{l:"-(-n1+n2)",r:"(n1-n2)"},// Unary propagation
{l:"-(n1+n2)",r:"(-n1-n2)"},// Unary propagation
{l:"(n1^n2)^n3",r:"(n1^(n2*n3))"},// Power to Power
{l:"-(-n1/n2)",r:"(n1/n2)"},// Division and Unary
{l:"-(n1/n2)",r:"(-n1/n2)"}],c=[{l:"(n1/(n2/n3))",r:"((n1*n3)/n2)"},// Division simplification
{l:"(n1/n2/n3)",r:"(n1/(n2*n3))"}],// All rules => infinite loop
// setRules.allRules =oldRules.concat(rulesFirst,rulesDistrDiv,rulesSucDiv)
(d={}).firstRules=u.concat(l,c),d.distrDivRules=[{l:"(n1/n2 + n3/n4)",r:"((n1*n4 + n3*n2)/(n2*n4))"},// Sum of fractions
{l:"(n1/n2 + n3)",r:"((n1 + n3*n2)/n2)"},// Sum fraction with number 1
{l:"(n1 + n2/n3)",r:"((n1*n3 + n2)/n3)"}],d.sucDivRules=c,d.firstRulesAgain=u.concat(l),// Division simplification
// Second rule set.
// There is no aggregate expression with parentesis, but the only variable can be scattered.
d.finalRules=[p,// simplify.rules[0]
{l:"n*-n",r:"-n^2"},// Joining multiply with power 1
{l:"n*n",r:"n^2"},// Joining multiply with power 2
f,// simplify.rules[14] old 3rd index in oldRules
{l:"n*-n^n1",r:"-n^(n1+1)"},// Joining multiply with power 3
{l:"n*n^n1",r:"n^(n1+1)"},// Joining multiply with power 4
{l:"n^n1*-n^n2",r:"-n^(n1+n2)"},// Joining multiply with power 5
{l:"n^n1*n^n2",r:"n^(n1+n2)"},// Joining multiply with power 6
{l:"n^n1*-n",r:"-n^(n1+1)"},// Joining multiply with power 7
{l:"n^n1*n",r:"n^(n1+1)"},// Joining multiply with power 8
{l:"n^n1/-n",r:"-n^(n1-1)"},// Joining multiply with power 8
{l:"n^n1/n",r:"n^(n1-1)"},// Joining division with power 1
{l:"n/-n^n1",r:"-n^(1-n1)"},// Joining division with power 2
{l:"n/n^n1",r:"n^(1-n1)"},// Joining division with power 3
{l:"n^n1/-n^n2",r:"n^(n1-n2)"},// Joining division with power 4
{l:"n^n1/n^n2",r:"n^(n1-n2)"},// Joining division with power 5
{l:"n1+(-n2*n3)",r:"n1-n2*n3"},// Solving useless parenthesis 1
{l:"v*(-c)",r:"-c*v"},// Solving useless unary 2
{l:"n1+-n2",r:"n1-n2"},// Solving +- together (new!)
{l:"v*c",r:"c*v"},// inversion constant with variable
{l:"(n1^n2)^n3",r:"(n1^(n2*n3))"}// Power to Power
],d),i=(h=e,g=!0,y=n.firstRules,v=[],x=m(h,y,t,{exactFractions:!1}),N="+-*"+((g=!!g)?"/":""),!// -------------------------------------------------------------------------------------------------------
/**
     *  Function to simplify an expression using an optional scope and
     *  return it if the expression is a polynomial expression, i.e.
     *  an expression with one or more variables and the operators
     *  +, -, *, and ^, where the exponent can only be a positive integer.
     *
     * Syntax:
     *
     *     recPoly(node)
     *
     *
     * @param  {Node} node               The current sub tree expression in recursion
     *
     * @return                           nothing, throw an exception if error
     */function e(t){var r=t.type;// node type
if("FunctionNode"===r)throw Error("There is an unsolved function call");if("OperatorNode"===r){if("^"===t.op){// TODO: handle negative exponents like in '1/x^(-2)'
if("ConstantNode"===t.args[1].type&&eh(parseFloat(t.args[1].value)))e(t.args[0]);else throw Error("There is a non-integer exponent")}else{if(-1===N.indexOf(t.op))throw Error("Operator "+t.op+" invalid in polynomial expression");for(var n=0;n<t.args.length;n++)e(t.args[n])}// type of operator
}else if("SymbolNode"===r){var i=t.name;// variable name
-1===v.indexOf(i)&&v.push(i)}else if("ParenthesisNode"===r)e(t.content);else if("ConstantNode"!==r)throw Error("type "+r+" is not allowed in polynomial expression")}// end of recPoly
(x),(w={}).expression=x,w.variables=v,w),a=i.variables.length,o={exactFractions:!1},s={exactFractions:!0};if(e=i.expression,a>=1){// If expression in not a constant
e=// ---------------------------------------------------------------------------------------
/**
   *  Expand recursively a tree node for handling with expressions with exponents
   *  (it's not for constants, symbols or functions with exponents)
   *  PS: The other parameters are internal for recursion
   *
   * Syntax:
   *
   *     expandPower(node)
   *
   * @param  {Node} node         Current expression node
   * @param  {node} parent       Parent current node inside the recursion
   * @param  (int}               Parent number of chid inside the rercursion
   *
   * @return {node}        node expression with all powers expanded.
   */function e(t,r,n){var i=t.type,a=arguments.length>1;if("OperatorNode"===i&&t.isBinary()){var o,s=!1;if("^"===t.op&&("ParenthesisNode"===t.args[0].type||"OperatorNode"===t.args[0].type)&&"ConstantNode"===t.args[1].type&&(s=// Second operator: Constant
(o=parseFloat(t.args[1].value))>=2&&eh(o)),s){// Exponent >= 2
// Before:
//            operator A --> Subtree
// parent pow
//            constant
//
if(o>2){// Exponent > 2,
// AFTER:  (exponent > 2)
//             operator A --> Subtree
// parent  *
//                 deep clone (operator A --> Subtree
//             pow
//                 constant - 1
//
var u=t.args[0],l=new E("^","pow",[t.args[0].cloneDeep(),new b(o-1)]);t=new E("*","multiply",[u,l])}else // AFTER:  (exponent =  2)
//             operator A --> Subtree
// parent   oper
//            deep clone (operator A --> Subtree)
//
t=new E("*","multiply",[t.args[0],t.args[0].cloneDeep()]);a&&("content"===n?r.content=t:r.args[n]=t)}// does
}// binary OperatorNode
if("ParenthesisNode"===i)e(t.content,t,"content");else if("ConstantNode"!==i&&"SymbolNode"!==i)for(var c=0;c<t.args.length;c++)e(t.args[c],t,c);if(!a)return t}// End expandPower
(e);var u,l,c,d,h,g,y,v,x,N,w,D,A,S=!0,C=!1;for(// Apply the initial rules, including succ div rules:
e=m(e,n.firstRules,{},o);e=m(e,S?n.distrDivRules:n.sucDivRules,{},s),S=!S,(A=e.toString())!==D;)C=!0,D=A;C&&(e=m(e,n.firstRulesAgain,{},o)),// Apply final rules:
e=m(e,n.finalRules,{},o)}// NVars >= 1
var F=[],B={};return(// nVars
("OperatorNode"===e.type&&e.isBinary()&&"/"===e.op?(1===a&&(e.args[0]=M(e.args[0],F),e.args[1]=M(e.args[1])),r&&(B.numerator=e.args[0],B.denominator=e.args[1])):(1===a&&(e=M(e,F)),r&&(B.numerator=e,B.denominator=null)),r)?(B.coefficients=F,B.variables=i.variables,B.expression=e,B):e)}return r(nc,{Node:C,"Node, boolean":(e,t)=>C(e,{},t),"Node, Object":C,"Node, Object, boolean":C});// end of typed rationalize
// ---------------------------------------------------------------------------------------
/**
   * Auxilary function for rationalize
   * Convert near canonical polynomial in one variable in a canonical polynomial
   * with one term for each exponent in decreasing order
   *
   * Syntax:
   *
   *     polyToCanonical(node [, coefficients])
   *
   * @param  {Node | string} expr       The near canonical polynomial expression to convert in a a canonical polynomial expression
   *
   *        The string or tree expression needs to be at below syntax, with free spaces:
   *         (  (^(-)? | [+-]? )cte (*)? var (^expo)?  | cte )+
   *       Where 'var' is one variable with any valid name
   *             'cte' are real numeric constants with any value. It can be omitted if equal than 1
   *             'expo' are integers greater than 0. It can be omitted if equal than 1.
   *
   * @param  {array}   coefficients             Optional returns coefficients sorted by increased exponent
   *
   *
   * @return {node}        new node tree with one variable polynomial or string error.
   */function M(e,t){void 0===t&&(t=[]),// coefficients.
t[0]=0;var r,n={};n.cte=1,n.oper="+",// fire: mark with * or ^ when finds * or ^ down tree, reset to "" with + and -.
//       It is used to deduce the exponent: 1 for *, 0 for "".
n.fire="";var i=0,a="";// maximum exponent
/**
     * Recursive auxilary function inside polyToCanonical for
     * converting expression in canonical form
     *
     * Syntax:
     *
     *     recurPol(node, noPai, obj)
     *
     * @param  {Node} node        The current subpolynomial expression
     * @param  {Node | Null}  noPai   The current parent node
     * @param  {object}    obj        Object with many internal flags
     *
     * @return {}                    No return. If error, throws an exception
     */(function e(r,n,o){var s=r.type;if("FunctionNode"===s)// No function call in polynomial expression
throw Error("There is an unsolved function call");if("OperatorNode"===s){// ***** OperatorName *****
if(-1==="+-*^".indexOf(r.op))throw Error("Operator "+r.op+" invalid");if(null!==n&&(("unaryMinus"===r.fn||"pow"===r.fn)&&"add"!==n.fn&&"subtract"!==n.fn&&"multiply"!==n.fn||("subtract"===r.fn||"add"===r.fn||"multiply"===r.fn)&&"add"!==n.fn&&"subtract"!==n.fn||("subtract"===r.fn||"add"===r.fn||"unaryMinus"===r.fn)&&0!==o.noFil))throw Error("Invalid "+r.op+" placing");// Has parent
// Firers: ^,*       Old:   ^,&,-(unary): firers
("^"===r.op||"*"===r.op)&&(o.fire=r.op);for(var u=0;u<r.args.length;u++)"unaryMinus"===r.fn&&(o.oper="-"),("+"===r.op||"subtract"===r.fn)&&(o.fire="",o.cte=1,o.oper=0===u?"+":r.op),o.noFil=u,e(r.args[u],r,o);// for in children
}else if("SymbolNode"===s){// ***** SymbolName *****
if(r.name!==a&&""!==a)throw Error("There is more than one variable");if(a=r.name,null===n){t[1]=1;return}// ^: Symbol is First child
if("^"===n.op&&0!==o.noFil)throw Error("In power the variable should be the first parameter");// *: Symbol is Second child
if("*"===n.op&&1!==o.noFil)throw Error("In multiply the variable should be the second parameter");(""===o.fire||"*"===o.fire)&&(i<1&&(t[1]=0),t[1]+=o.cte*("+"===o.oper?1:-1),i=Math.max(1,i))}else if("ConstantNode"===s){var l=parseFloat(r.value);if(null===n){t[0]=l;return}if("^"===n.op){// cte: second  child of power
if(1!==o.noFil)throw Error("Constant cannot be powered");if(!eh(l)||l<=0)throw Error("Non-integer exponent is not allowed");for(var c=i+1;c<l;c++)t[c]=0;l>i&&(t[l]=0),t[l]+=o.cte*("+"===o.oper?1:-1),i=Math.max(l,i);return}o.cte=l,""===o.fire&&(t[0]+=o.cte*("+"===o.oper?1:-1))}else throw Error("Type "+s+" is not allowed")}// End of recurPol
)(e,null,n),i=t.length-1;for(var o=!0,s=i;s>=0;s--)if(0!==t[s]){var u=new b(o?t[s]:Math.abs(t[s])),l=t[s]<0?"-":"+";if(s>0){// Is not a constant without variable
var c=new A(a);s>1&&(c=new E("^","pow",[c,new b(s)])),u=-1===t[s]&&o?new E("-","unaryMinus",[c]):1===Math.abs(t[s])?c:new E("*","multiply",[u,c])}r=o?u:"+"===l?new E("+","add",[r,u]):new E("-","subtract",[r,u]),o=!1}// for
return o?new b(0):r}// End of polyToCanonical
}),np="RelationalNode",nm=ta(np,["Node"],t=>{var{Node:Node}=t,r={equal:"==",unequal:"!=",smaller:"<",larger:">",smallerEq:"<=",largerEq:">="};class n extends Node{/**
     * A node representing a chained conditional expression, such as 'x > y > z'
     *
     * @param {String[]} conditionals
     *     An array of conditional operators used to compare the parameters
     * @param {Node[]} params
     *     The parameters that will be compared
     *
     * @constructor RelationalNode
     * @extends {Node}
     */constructor(e,t){if(super(),!Array.isArray(e))throw TypeError("Parameter conditionals must be an array");if(!Array.isArray(t))throw TypeError("Parameter params must be an array");if(e.length!==t.length-1)throw TypeError("Parameter params must contain exactly one more element than parameter conditionals");this.conditionals=e,this.params=t}get type(){return np}get isRelationalNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){var r=this,n=this.params.map(r=>r._compile(e,t));return function(t,i,a){for(var o,s=n[0](t,i,a),u=0;u<r.conditionals.length;u++)if(o=s,s=n[u+1](t,i,a),!eu(e,r.conditionals[u])(o,s))return!1;return!0}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){this.params.forEach((t,r)=>e(t,"params["+r+"]",this),this)}/**
     * Create a new RelationalNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RelationalNode} Returns a transformed copy of the node
     */map(e){return new n(this.conditionals.slice(),this.params.map((t,r)=>this._ifNode(e(t,"params["+r+"]",this)),this))}/**
     * Create a clone of this node, a shallow copy
     * @return {RelationalNode}
     */clone(){return new n(this.conditionals,this.params)}/**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */_toString(e){for(var t=e&&e.parenthesis?e.parenthesis:"keep",n=tx(this,t,e&&e.implicit),i=this.params.map(function(r,i){var a=tx(r,t,e&&e.implicit);return"all"===t||null!==a&&a<=n?"("+r.toString(e)+")":r.toString(e)}),a=i[0],o=0;o<this.conditionals.length;o++)a+=" "+r[this.conditionals[o]]+" "+i[o+1];return a}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:np,conditionals:this.conditionals,params:this.params}}/**
     * Instantiate a RelationalNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "RelationalNode", "conditionals": ..., "params": ...}`,
     *     where mathjs is optional
     * @returns {RelationalNode}
     */static fromJSON(e){return new n(e.conditionals,e.params)}/**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */toHTML(e){for(var t=e&&e.parenthesis?e.parenthesis:"keep",n=tx(this,t,e&&e.implicit),i=this.params.map(function(r,i){var a=tx(r,t,e&&e.implicit);return"all"===t||null!==a&&a<=n?'<span class="math-parenthesis math-round-parenthesis">(</span>'+r.toHTML(e)+'<span class="math-parenthesis math-round-parenthesis">)</span>':r.toHTML(e)}),a=i[0],o=0;o<this.conditionals.length;o++)a+='<span class="math-operator math-binary-operator math-explicit-binary-operator">'+eL(r[this.conditionals[o]])+"</span>"+i[o+1];return a}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */_toTex(e){for(var t=e&&e.parenthesis?e.parenthesis:"keep",r=tx(this,t,e&&e.implicit),n=this.params.map(function(n,i){var a=tx(n,t,e&&e.implicit);return"all"===t||null!==a&&a<=r?"\\left("+n.toTex(e)+"\right)":n.toTex(e)}),i=n[0],a=0;a<this.conditionals.length;a++)i+=tX[this.conditionals[a]]+n[a+1];return i}}return /*@__PURE__*/e(et)(n,"name",np),n},{isClass:!0,isNode:!0}),nd=ta("resolve",["typed","parse","ConstantNode","FunctionNode","OperatorNode","ParenthesisNode"],e=>{var{typed:t,parse:r,ConstantNode:n,FunctionNode:i,OperatorNode:a,ParenthesisNode:o}=e;/**
   * resolve(expr, scope) replaces variable nodes with their scoped values
   *
   * Syntax:
   *
   *     math.resolve(expr, scope)
   *
   * Examples:
   *
   *     math.resolve('x + y', {x:1, y:2})           // Node '1 + 2'
   *     math.resolve(math.parse('x+y'), {x:1, y:2}) // Node '1 + 2'
   *     math.simplify('x+y', {x:2, y: math.parse('x+x')}).toString() // "6"
   *
   * See also:
   *
   *     simplify, evaluate
   *
   * @param {Node | Node[]} node
   *     The expression tree (or trees) to be simplified
   * @param {Object} scope
   *     Scope specifying variables to be resolved
   * @return {Node | Node[]} Returns `node` with variables recursively substituted.
   * @throws {ReferenceError}
   *     If there is a cyclic dependency among the variables in `scope`,
   *     resolution is impossible and a ReferenceError is thrown.
   */function s(e,t){var u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;// note `within`:
// `within` is not documented, since it is for internal cycle
// detection only
if(!t)return e;if(V(e)){if(u.has(e.name)){var l=Array.from(u).join(", ");throw ReferenceError("recursive loop of variable definitions among {".concat(l,"}"))}var c=t.get(e.name);if(U(c)){var f=new Set(u);return f.add(e.name),s(c,t,f)}return"number"==typeof c?r(String(c)):void 0!==c?new n(c):e}if($(e)){var p=e.args.map(function(e){return s(e,t,u)});return new a(e.op,e.fn,p,e.implicit)}if(H(e))return new o(s(e.content,t,u));if(P(e)){var m=e.args.map(function(e){return s(e,t,u)});return new i(e.name,m)}// Otherwise just recursively resolve any children (might also work
// for some of the above special cases)
return e.map(e=>s(e,t,u))}return t("resolve",{Node:s,"Node, Map | null | undefined":s,"Node, Object":(e,t)=>s(e,ru(t)),// For arrays and matrices, we map `self` rather than `_resolve`
// because resolve is fairly expensive anyway, and this way
// we get nice error messages if one entry in the array has wrong type.
"Array | Matrix":t.referToSelf(e=>t=>t.map(t=>e(t))),"Array | Matrix, null | undefined":t.referToSelf(e=>t=>t.map(t=>e(t))),"Array, Object":t.referTo("Array,Map",e=>(t,r)=>e(t,ru(r))),"Matrix, Object":t.referTo("Matrix,Map",e=>(t,r)=>e(t,ru(r))),"Array | Matrix, Map":t.referToSelf(e=>(t,r)=>t.map(t=>e(t,r)))})}),nh=ta("reviver",["classes"],e=>{var{classes:t}=e;/**
   * Instantiate mathjs data types from their JSON representation
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */return function(e,r){var n=t[r&&r.mathjs];return n&&"function"==typeof n.fromJSON?n.fromJSON(r):r}}),ng=ta("row",["typed","Index","matrix","range"],e=>{var{typed:t,Index:r,matrix:n,range:i}=e;/**
   * Return a row from a Matrix.
   *
   * Syntax:
   *
   *     math.row(value, index)
   *
   * Example:
   *
   *     // get a row
   *     const d = [[1, 2], [3, 4]]
   *     math.row(d, 1) // returns [[3, 4]]
   *
   * See also:
   *
   *     column
   *
   * @param {Array | Matrix } value   An array or matrix
   * @param {number} row              The index of the row
   * @return {Array | Matrix}         The retrieved row
   */return t("row",{"Matrix, number":a,"Array, number":function(e,t){return a(n(J(e)),t).valueOf()}});/**
   * Retrieve a row of a matrix
   * @param {Matrix } value  A matrix
   * @param {number} row     The index of the row
   * @return {Matrix}        The retrieved row
   */function a(e,t){// check dimensions
if(2!==e.size().length)throw Error("Only two dimensional matrix is supported");eY(t,e.size()[0]);var a=new r(t,i(0,e.size()[1])),o=e.subset(a);return g(o)?o:n([[o]])}}),ny=ta("row",["typed","Index","matrix","range"],e=>{var{typed:t,Index:r,matrix:n,range:i}=e,a=ng({typed:t,Index:r,matrix:n,range:i});// @see: comment of row itself
return t("row",{"...any":function(e){// change last argument from zero-based to one-based
var t=e.length-1,r=e[t];l(r)&&(e[t]=r-1);try{return a.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0});function nv(e){return k(e)||$(e)&&e.isUnary()&&k(e.args[0])}function nx(e){return!!(k(e)||(P(e)||$(e))&&e.args.every(nx)||H(e)&&nx(e.content))}function nb(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function nN(t){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?nb(Object(n),!0).forEach(function(r){/*@__PURE__*/e(et)(t,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):nb(Object(n)).forEach(function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))})}return t}var nw=ta("simplifyUtil",["FunctionNode","OperatorNode","SymbolNode"],e=>{var{FunctionNode:t,OperatorNode:r,SymbolNode:n}=e,i="defaultF",a={/*      */add:{trivial:!0,total:!0,commutative:!0,associative:!0},/**/unaryPlus:{trivial:!0,total:!0,commutative:!0,associative:!0},/* */subtract:{trivial:!1,total:!0,commutative:!1,associative:!1},/* */multiply:{trivial:!0,total:!0,commutative:!0,associative:!0},/*   */divide:{trivial:!1,total:!0,commutative:!1,associative:!1},/*    */paren:{trivial:!0,total:!0,commutative:!0,associative:!1},/* */defaultF:{trivial:!1,total:!0,commutative:!1,associative:!1}};function o(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:a,n=i;if("string"==typeof e?n=e:$(e)?n=e.fn.toString():P(e)?n=e.name:H(e)&&(n="paren"),K(r,n)){var o=r[n];if(K(o,t))return o[t];if(K(a,n))return a[n][t]}if(K(r,i)){var s=r[i];return K(s,t)?s[t]:a[i][t]}/* name not found in context and context has no global default *//* So use default context. */if(K(a,n)){var u=a[n];if(K(u,t))return u[t]}return a[i][t]}function s(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a;return o(e,"associative",t)}/**
   * Get the children of a node as if it has been flattened.
   * TODO implement for FunctionNodes
   */function u(e,t){var r,n=[];return s(e,t)?(r=e.op,!function e(t){for(var i=0;i<t.args.length;i++){var a=t.args[i];$(a)&&r===a.op?e(a):n.push(a)}}(e),n):e.args}function l(e){return $(e)?function(t){try{return new r(e.op,e.fn,t,e.implicit)}catch(e){return console.error(e),[]}}:function(r){return new t(new n(e.name),r)}}return{createMakeNodeFunction:l,hasProperty:o,isCommutative:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a;return o(e,"commutative",t)},isAssociative:s,mergeContext:/**
   * Merge the given contexts, with primary overriding secondary
   * wherever they might conflict
   */function(e,t){var r=nN({},e);for(var n in t)K(e,n)?r[n]=nN(nN({},t[n]),e[n]):r[n]=t[n];return r},flatten:/**
   * Flatten all associative operators in an expression tree.
   * Assumes parentheses have already been removed.
   */function e(t,r){if(!t.args||0===t.args.length)return t;t.args=u(t,r);for(var n=0;n<t.args.length;n++)e(t.args[n],r)},allChildren:u,unflattenr:/**
   *  Unflatten all flattened operators to a right-heavy binary tree.
   */function e(t,r){if(t.args&&0!==t.args.length){for(var n=l(t),i=t.args.length,a=0;a<i;a++)e(t.args[a],r);if(i>2&&s(t,r)){for(var o=t.args.pop();t.args.length>0;)o=n([t.args.pop(),o]);t.args=o.args}}},unflattenl:/**
   *  Unflatten all flattened operators to a left-heavy binary tree.
   */function e(t,r){if(t.args&&0!==t.args.length){for(var n=l(t),i=t.args.length,a=0;a<i;a++)e(t.args[a],r);if(i>2&&s(t,r)){for(var o=t.args.shift();t.args.length>0;)o=n([o,t.args.shift()]);t.args=o.args}}},defaultContext:a,realContext:{divide:{total:!1},log:{total:!1}},positiveContext:{subtract:{total:!1},abs:{trivial:!0},log:{total:!0}}}}),nD=ta("simplify",["config","typed","parse","add","subtract","multiply","divide","pow","isZero","equal","resolve","simplifyConstant","simplifyCore","?fraction","?bignumber","mathWithTransform","matrix","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode"],e=>{var{config:t,typed:r,parse:n,add:i,subtract:a,multiply:o,divide:s,pow:u,isZero:l,equal:c,resolve:f,simplifyConstant:p,simplifyCore:m,fraction:d,bignumber:h,mathWithTransform:g,matrix:y,AccessorNode:v,ArrayNode:x,ConstantNode:b,FunctionNode:N,IndexNode:w,ObjectNode:D,OperatorNode:E,ParenthesisNode:A,SymbolNode:S}=e,{hasProperty:C,isCommutative:M,isAssociative:F,mergeContext:B,flatten:T,unflattenr:O,unflattenl:_,createMakeNodeFunction:z,defaultContext:q,realContext:I,positiveContext:R}=nw({FunctionNode:N,OperatorNode:E,SymbolNode:S});/**
   * Simplify an expression tree.
   *
   * A list of rules are applied to an expression, repeating over the list until
   * no further changes are made.
   * It's possible to pass a custom set of rules to the function as second
   * argument. A rule can be specified as an object, string, or function:
   *
   *     const rules = [
   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },
   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',
   *       function (node) {
   *         // ... return a new node or return the node unchanged
   *         return node
   *       }
   *     ]
   *
   * String and object rules consist of a left and right pattern. The left is
   * used to match against the expression and the right determines what matches
   * are replaced with. The main difference between a pattern and a normal
   * expression is that variables starting with the following characters are
   * interpreted as wildcards:
   *
   * - 'n' - Matches any node [Node]
   * - 'c' - Matches a constant literal (5 or 3.2) [ConstantNode]
   * - 'cl' - Matches a constant literal; same as c [ConstantNode]
   * - 'cd' - Matches a decimal literal (5 or -3.2) [ConstantNode or unaryMinus wrapping a ConstantNode]
   * - 'ce' - Matches a constant expression (-5 or √3) [Expressions consisting of only ConstantNodes, functions, and operators]
   * - 'v' - Matches a variable; anything not matched by c (-5 or x) [Node that is not a ConstantNode]
   * - 'vl' - Matches a variable literal (x or y) [SymbolNode]
   * - 'vd' - Matches a non-decimal expression; anything not matched by cd (x or √3) [Node that is not a ConstantNode or unaryMinus that is wrapping a ConstantNode]
   * - 've' - Matches a variable expression; anything not matched by ce (x or 2x) [Expressions that contain a SymbolNode or other non-constant term]
   *
   * The default list of rules is exposed on the function as `simplify.rules`
   * and can be used as a basis to built a set of custom rules. Note that since
   * the `simplifyCore` function is in the default list of rules, by default
   * simplify will convert any function calls in the expression that have
   * operator equivalents to their operator forms.
   *
   * To specify a rule as a string, separate the left and right pattern by '->'
   * When specifying a rule as an object, the following keys are meaningful:
   * - l - the left pattern
   * - r - the right pattern
   * - s - in lieu of l and r, the string form that is broken at -> to give them
   * - repeat - whether to repeat this rule until the expression stabilizes
   * - assuming - gives a context object, as in the 'context' option to
   *     simplify. Every property in the context object must match the current
   *     context in order, or else the rule will not be applied.
   * - imposeContext - gives a context object, as in the 'context' option to
   *     simplify. Any settings specified will override the incoming context
   *     for all matches of this rule.
   *
   * For more details on the theory, see:
   *
   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)
   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)
   *
   *  An optional `options` argument can be passed as last argument of `simplify`.
   *  Currently available options (defaults in parentheses):
   *  - `consoleDebug` (false): whether to write the expression being simplified
   *    and any changes to it, along with the rule responsible, to console
   *  - `context` (simplify.defaultContext): an object giving properties of
   *    each operator, which determine what simplifications are allowed. The
   *    currently meaningful properties are commutative, associative,
   *    total (whether the operation is defined for all arguments), and
   *    trivial (whether the operation applied to a single argument leaves
   *    that argument unchanged). The default context is very permissive and
   *    allows almost all simplifications. Only properties differing from
   *    the default need to be specified; the default context is used as a
   *    fallback. Additional contexts `simplify.realContext` and
   *    `simplify.positiveContext` are supplied to cause simplify to perform
   *    just simplifications guaranteed to preserve all values of the expression
   *    assuming all variables and subexpressions are real numbers or
   *    positive real numbers, respectively. (Note that these are in some cases
   *    more restrictive than the default context; for example, the default
   *    context will allow `x/x` to simplify to 1, whereas
   *    `simplify.realContext` will not, as `0/0` is not equal to 1.)
   *  - `exactFractions` (true): whether to try to convert all constants to
   *    exact rational numbers.
   *  - `fractionsLimit` (10000): when `exactFractions` is true, constants will
   *    be expressed as fractions only when both numerator and denominator
   *    are smaller than `fractionsLimit`.
   *
   * Syntax:
   *
   *     math.simplify(expr)
   *     math.simplify(expr, rules)
   *     math.simplify(expr, rules)
   *     math.simplify(expr, rules, scope)
   *     math.simplify(expr, rules, scope, options)
   *     math.simplify(expr, scope)
   *     math.simplify(expr, scope, options)
   *
   * Examples:
   *
   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node "2 * x"
   *     math.simplify('2 * 3 * x', {x: 4})        // Node "24"
   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')
   *     math.simplify(f)                          // Node "2 * x"
   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node "x * 2 / 5"
   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node "0.4 * x"
   *
   * See also:
   *
   *     simplifyCore, derivative, evaluate, parse, rationalize, resolve
   *
   * @param {Node | string} expr
   *            The expression to be simplified
   * @param {SimplifyRule[]} [rules]
   *            Optional list with custom rules
   * @param {Object} [scope] Optional scope with variables
   * @param {SimplifyOptions} [options] Optional configuration settings
   * @return {Node} Returns the simplified form of `expr`
   */r.addConversion({from:"Object",to:"Map",convert:ru});var P=r("simplify",{Node:Z,"Node, Map":(e,t)=>Z(e,!1,t),"Node, Map, Object":(e,t,r)=>Z(e,!1,t,r),"Node, Array":Z,"Node, Array, Map":Z,"Node, Array, Map, Object":Z});function j(e){return e.transform(function(e,t,r){return H(e)?j(e.content):e})}r.removeConversion({from:"Object",to:"Map",convert:ru}),P.defaultContext=q,P.realContext=I,P.positiveContext=R;// All constants that are allowed in rules
var U={true:!0,false:!0,e:!0,i:!0,Infinity:!0,LN2:!0,LN10:!0,LOG2E:!0,LOG10E:!0,NaN:!0,phi:!0,pi:!0,SQRT1_2:!0,SQRT2:!0,tau:!0};// Array of strings, used to build the ruleSet.
// Each l (left side) and r (right side) are parsed by
// the expression parser into a node tree.
// Left hand sides are matched to subtrees within the
// expression to be parsed and replaced with the right
// hand side.
// TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])
// To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.
// It is possible to get into an infinite loop with conflicting rules
P.rules=[m,// { l: 'n+0', r: 'n' },     // simplifyCore
// { l: 'n^0', r: '1' },     // simplifyCore
// { l: '0*n', r: '0' },     // simplifyCore
// { l: 'n/n', r: '1'},      // simplifyCore
// { l: 'n^1', r: 'n' },     // simplifyCore
// { l: '+n1', r:'n1' },     // simplifyCore
// { l: 'n--n1', r:'n+n1' }, // simplifyCore
{l:"log(e)",r:"1"},// temporary rules
// Note initially we tend constants to the right because like-term
// collection prefers the left, and we would rather collect nonconstants
{s:"n-n1 -> n+-n1",// temporarily replace 'subtract' so we can further flatten the 'add' operator
assuming:{subtract:{total:!0}}},{s:"n-n -> 0",// partial alternative when we can't always subtract
assuming:{subtract:{total:!1}}},{s:"-(cl*v) -> v * (-cl)",// make non-constant terms positive
assuming:{multiply:{commutative:!0},subtract:{total:!0}}},{s:"-(cl*v) -> (-cl) * v",// non-commutative version, part 1
assuming:{multiply:{commutative:!1},subtract:{total:!0}}},{s:"-(v*cl) -> v * (-cl)",// non-commutative version, part 2
assuming:{multiply:{commutative:!1},subtract:{total:!0}}},{l:"-(n1/n2)",r:"-n1/n2"},{l:"-v",r:"v * (-1)"},// finish making non-constant terms positive
{l:"(n1 + n2)*(-1)",r:"n1*(-1) + n2*(-1)",repeat:!0},// expand negations to achieve as much sign cancellation as possible
{l:"n/n1^n2",r:"n*n1^-n2"},// temporarily replace 'divide' so we can further flatten the 'multiply' operator
{l:"n/n1",r:"n*n1^-1"},{s:"(n1*n2)^n3 -> n1^n3 * n2^n3",assuming:{multiply:{commutative:!0}}},{s:"(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",assuming:{multiply:{commutative:!1}}},// expand nested exponentiation
{s:"(n ^ n1) ^ n2 -> n ^ (n1 * n2)",assuming:{divide:{total:!0}}// 1/(1/n) = n needs 1/n to exist
},// collect like factors; into a sum, only do this for nonconstants
{l:" vd   * ( vd   * n1 + n2)",r:"vd^2       * n1 +  vd   * n2"},{s:" vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",assuming:{divide:{total:!0}}// v*1/v = v^(1+-1) needs 1/v
},{s:"vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",assuming:{divide:{total:!0}}},{s:"vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",assuming:{divide:{total:!0}}},{l:"n*n",r:"n^2"},{s:"n * n^n1 -> n^(n1+1)",assuming:{divide:{total:!0}}// n*1/n = n^(-1+1) needs 1/n
},{s:"n^n1 * n^n2 -> n^(n1+n2)",assuming:{divide:{total:!0}}// ditto for n^2*1/n^2
},// Unfortunately, to deal with more complicated cancellations, it
// becomes necessary to simplify constants twice per pass. It's not
// terribly expensive compared to matching rules, so this should not
// pose a performance problem.
p,// First: before collecting like terms
// collect like terms
{s:"n+n -> 2*n",assuming:{add:{total:!0}}// 2 = 1 + 1 needs to exist
},{l:"n+-n",r:"0"},{l:"vd*n + vd",r:"vd*(n+1)"},// NOTE: leftmost position is special:
{l:"n3*n1 + n3*n2",r:"n3*(n1+n2)"},// All sub-monomials tried there.
{l:"n3^(-n4)*n1 +   n3  * n2",r:"n3^(-n4)*(n1 + n3^(n4+1) *n2)"},{l:"n3^(-n4)*n1 + n3^n5 * n2",r:"n3^(-n4)*(n1 + n3^(n4+n5)*n2)"},// noncommutative additional cases (term collection & factoring)
{s:"n*vd + vd -> (n+1)*vd",assuming:{multiply:{commutative:!1}}},{s:"vd + n*vd -> (1+n)*vd",assuming:{multiply:{commutative:!1}}},{s:"n1*n3 + n2*n3 -> (n1+n2)*n3",assuming:{multiply:{commutative:!1}}},{s:"n^n1 * n -> n^(n1+1)",assuming:{divide:{total:!0},multiply:{commutative:!1}}},{s:"n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",assuming:{multiply:{commutative:!1}}},{s:"n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",assuming:{multiply:{commutative:!1}}},{l:"n*cd + cd",r:"(n+1)*cd"},{s:"cd*n + cd -> cd*(n+1)",assuming:{multiply:{commutative:!1}}},{s:"cd + cd*n -> cd*(1+n)",assuming:{multiply:{commutative:!1}}},p,// Second: before returning expressions to "standard form"
// make factors positive (and undo 'make non-constant terms positive')
{s:"(-n)*n1 -> -(n*n1)",assuming:{subtract:{total:!0}}},{s:"n1*(-n) -> -(n1*n)",// in case * non-commutative
assuming:{subtract:{total:!0},multiply:{commutative:!1}}},// final ordering of constants
{s:"ce+ve -> ve+ce",assuming:{add:{commutative:!0}},imposeContext:{add:{commutative:!1}}},{s:"vd*cd -> cd*vd",assuming:{multiply:{commutative:!0}},imposeContext:{multiply:{commutative:!1}}},// undo temporary rules
// { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
{l:"n+-n1",r:"n-n1"},// undo replace 'subtract'
{l:"n+-(n1)",r:"n-(n1)"},{s:"n*(n1^-1) -> n/n1",// undo replace 'divide'; for * commutative
assuming:{multiply:{commutative:!0}}// o.w. / not conventional
},{s:"n*n1^-n2 -> n/n1^n2",assuming:{multiply:{commutative:!0}}// o.w. / not conventional
},{s:"n^-1 -> 1/n",assuming:{multiply:{commutative:!0}}// o.w. / not conventional
},{l:"n^1",r:"n"},// can be produced by power cancellation
{s:"n*(n1/n2) -> (n*n1)/n2",// '*' before '/'
assuming:{multiply:{associative:!0}}},{s:"n-(n1+n2) -> n-n1-n2",// '-' before '+'
assuming:{addition:{associative:!0,commutative:!0}}},// { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
// { l: '(n*n1)/(n*n2)', r: 'n1/n2' },
// simplifyConstant can leave an extra factor of 1, which can always
// be eliminated, since the identity always commutes
{l:"1*n",r:"n",imposeContext:{multiply:{commutative:!0}}},{s:"n1/(n2/n3) -> (n1*n3)/n2",assuming:{multiply:{associative:!0}}},{l:"n1/(-n2)",r:"-n1/n2"}];var L=0;function $(){return new S("_p"+L++)}function Z(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:rs(),i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=i.consoleDebug;t=/**
   * Parse the string array of rules into nodes
   *
   * Example syntax for rules:
   *
   * Position constants to the left in a product:
   * { l: 'n1 * c1', r: 'c1 * n1' }
   * n1 is any Node, and c1 is a ConstantNode.
   *
   * Apply difference of squares formula:
   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }
   * n1, n2 mean any Node.
   *
   * Short hand notation:
   * 'n1 * c1 -> c1 * n1'
   */function(e,t){for(var r=[],i=0;i<e.length;i++){var a=e[i],o=void 0,s=typeof a;switch(s){case"string":a={s:a};/* falls through */case"object":o=/**
   * Takes any rule object as allowed by the specification in simplify
   * and puts it in a standard form used by applyRule
   */function(e,t){var r={};if(e.s){var i=e.s.split("->");if(2===i.length)r.l=i[0],r.r=i[1];else throw SyntaxError("Could not parse rule: "+e.s)}else r.l=e.l,r.r=e.r;for(var a of(r.l=j(n(r.l)),r.r=j(n(r.r)),["imposeContext","repeat","assuming"]))a in e&&(r[a]=e[a]);if(e.evaluate&&(r.evaluate=n(e.evaluate)),F(r.l,t)){var o,s=!M(r.l,t);s&&(o=$());var u=z(r.l),l=$();r.expanded={},r.expanded.l=u([r.l,l]),// Push the expandsym into the deepest possible branch.
// This helps to match the newRule against nodes returned from getSplits() later on.
T(r.expanded.l,t),O(r.expanded.l,t),r.expanded.r=u([r.r,l]),s&&(// 'Non-commutative' 1: LHS (placeholder) only
r.expandedNC1={},r.expandedNC1.l=u([o,r.l]),r.expandedNC1.r=u([o,r.r]),// 'Non-commutative' 2: farmost LHS and RHS placeholders
r.expandedNC2={},r.expandedNC2.l=u([o,r.expanded.l]),r.expandedNC2.r=u([o,r.expanded.r]))}return r}(a,t);break;case"function":o=a;break;default:throw TypeError("Unsupported type of rule: "+s)}// console.log('Adding rule: ' + rules[i])
// console.log(newRule)
r.push(o)}return r}(t||P.rules,i.context);var o=f(e,r);o=j(o);for(var s={},u=o.toString({parenthesis:"all"});!s[u];){s[u]=!0,L=0;var l=u;a&&console.log("Working on: ",u);for(var c=0;c<t.length;c++){var p="";if("function"==typeof t[c]?(o=t[c](o,i),a&&(p=t[c].name)):(T(o,i.context),o=W(o,t[c],i.context),a&&(p="".concat(t[c].l.toString()," -> ").concat(t[c].r.toString()))),a){var m=o.toString({parenthesis:"all"});m!==l&&(console.log("Applying",p,"produced",m),l=m)}/* Use left-heavy binary tree internally,
         * since custom rule functions may expect it
         */_(o,i.context)}u=o.toString({parenthesis:"all"})}return o}function G(e,t,r){var n=e;if(e)for(var i=0;i<e.length;++i){var a=W(e[i],t,r);a!==e[i]&&(n===e&&(n=e.slice()),n[i]=a)}return n}/**
   * Returns a simplfied form of node, or the original node if no simplification was possible.
   *
   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
   * @param  {Object | Function} rule
   * @param  {Object} context -- information about assumed properties of operators
   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.
   */function W(e,t,r){//    console.log('Entering applyRule("', rule.l.toString({parenthesis:'all'}), '->', rule.r.toString({parenthesis:'all'}), '",', node.toString({parenthesis:'all'}),')')
// check that the assumptions for this rule are satisfied by the current
// context:
if(t.assuming){for(var n in t.assuming)for(var i in t.assuming[n])if(C(n,i,r)!==t.assuming[n][i])return e}var a=B(t.imposeContext,r),o=e;// First replace our child nodes with their simplified versions
// If a child could not be simplified, applying the rule to it
// will have no effect since the node is returned unchanged
if(o instanceof E||o instanceof N){var s=G(o.args,t,r);s!==o.args&&((o=o.clone()).args=s)}else if(o instanceof A){if(o.content){var u=W(o.content,t,r);u!==o.content&&(o=new A(u))}}else if(o instanceof x){var l=G(o.items,t,r);l!==o.items&&(o=new x(l))}else if(o instanceof v){var c=o.object;o.object&&(c=W(o.object,t,r));var f=o.index;o.index&&(f=W(o.index,t,r)),(c!==o.object||f!==o.index)&&(o=new v(c,f))}else if(o instanceof w){var p=G(o.dimensions,t,r);p!==o.dimensions&&(o=new w(p))}else if(o instanceof D){var m=!1,d={};for(var h in o.properties)d[h]=W(o.properties[h],t,r),d[h]!==o.properties[h]&&(m=!0);m&&(o=new D(d))}// Try to match a rule against this node
var g=t.r,y=J(t.l,o,a)[0];if(!y&&t.expanded&&(g=t.expanded.r,y=J(t.expanded.l,o,a)[0]),y||!t.expandedNC1||(g=t.expandedNC1.r,(y=J(t.expandedNC1.l,o,a)[0])||(// Existence of NC1 implies NC2
g=t.expandedNC2.r,y=J(t.expandedNC2.l,o,a)[0])),y){// const before = res.toString({parenthesis: 'all'})
// Create a new node by cloning the rhs of the matched rule
// we keep any implicit multiplication state if relevant
var b=o.implicit;o=g.clone(),b&&"implicit"in g&&(o.implicit=!0),// Replace placeholders with their respective nodes without traversing deeper into the replaced nodes
o=o.transform(function(e){return e.isSymbolNode&&K(y.placeholders,e.name)?y.placeholders[e.name].clone():e});// const after = res.toString({parenthesis: 'all'})
// console.log('Simplified ' + before + ' to ' + after)
}return t.repeat&&o!==e&&(o=W(o,t,r)),o}/**
   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.
   * Each list represents matches found in one child of a node.
   */function Y(e,t){var r,n=[];if(0===e.length||0===t.length)return n;for(var i=0;i<e.length;i++)for(var a=0;a<t.length;a++)(r=/**
   * Returns the set union of two match-placeholders or null if there is a conflict.
   */function(e,t){var r={placeholders:{}};// Some matches may not have placeholders; this is OK
if(!e.placeholders&&!t.placeholders)return r;if(!e.placeholders)return t;if(!t.placeholders)return e;// Placeholders with the same key must match exactly
for(var n in e.placeholders)if(K(e.placeholders,n)&&(r.placeholders[n]=e.placeholders[n],K(t.placeholders,n)&&!/**
   * Determines whether p and q (and all their children nodes) are identical.
   *
   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p
   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q
   * @return {Object} Information about the match, if it exists.
   */function e(t,r){if(t instanceof b&&r instanceof b){if(!c(t.value,r.value))return!1}else if(t instanceof S&&r instanceof S){if(t.name!==r.name)return!1}else{if((!(t instanceof E)||!(r instanceof E))&&(!(t instanceof N)||!(r instanceof N)))return!1;if(t instanceof E){if(t.op!==r.op||t.fn!==r.fn)return!1}else if(t instanceof N&&t.name!==r.name)return!1;if(t.args.length!==r.args.length)return!1;for(var n=0;n<t.args.length;n++)if(!e(t.args[n],r.args[n]))return!1}return!0}(e.placeholders[n],t.placeholders[n])))return null;for(var i in t.placeholders)K(t.placeholders,i)&&(r.placeholders[i]=t.placeholders[i]);return r}(e[i],t[a]))&&n.push(r);return n}/**
   * Determines whether node matches rule.
   *
   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule
   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
   * @param {Object} context -- provides assumed properties of operators
   * @param {Boolean} isSplit -- whether we are in process of splitting an
   *                    n-ary operator node into possible binary combinations.
   *                    Defaults to false.
   * @return {Object} Information about the match, if it exists.
   */function J(e,t,r,n){//    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')
//    console.log('rule = ' + rule)
//    console.log('node = ' + node)
//    console.log('Entering _ruleMatch(', rule.toString({parenthesis:'all'}), ', ', node.toString({parenthesis:'all'}), ', ', context, ')')
var i=[{placeholders:{}}];if(e instanceof E&&t instanceof E||e instanceof N&&t instanceof N){// If the rule is an OperatorNode or a FunctionNode, then node must match exactly
if(e instanceof E){if(e.op!==t.op||e.fn!==t.fn)return[]}else if(e instanceof N&&e.name!==t.name)return[];// rule and node match. Search the children of rule and node.
if(1===t.args.length&&1===e.args.length||!F(t,r)&&t.args.length===e.args.length||n){for(var a=[],o=0;o<e.args.length;o++){var s=J(e.args[o],t.args[o],r);if(0===s.length)break;// The child matched, so add the information returned from the child to our result
a.push(s)}if(a.length!==e.args.length){if(!M(t,r)||// exact match in order needed
1===e.args.length)return[];if(e.args.length>2)/* Need to generate all permutations and try them.
             * It's a bit complicated, and unlikely to come up since there
             * are very few ternary or higher operators. So punt for now.
             */throw Error("permuting >2 commutative non-associative rule arguments not yet implemented");/* Exactly two arguments, try them reversed */var u=J(e.args[0],t.args[1],r);if(0===u.length)return[];var l=J(e.args[1],t.args[0],r);if(0===l.length)return[];a=[u,l]}i=/**
   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.
   * Each list represents matches found in one child of a node.
   * Returns a list of unique matches.
   */function(e){if(0===e.length)return e;for(var t=e.reduce(Y),r=[],n={},i=0;i<t.length;i++){var a=JSON.stringify(t[i]);n[a]||(n[a]=!0,r.push(t[i]))}return r}(a)}else if(t.args.length>=2&&2===e.args.length){for(var f=/**
   * Get (binary) combinations of a flattened binary node
   * e.g. +(node1, node2, node3) -> [
   *        +(node1,  +(node2, node3)),
   *        +(node2,  +(node1, node3)),
   *        +(node3,  +(node1, node2))]
   *
   */function(e,t){var r,n,i=[],a=z(e);if(M(e,t))for(var o=0;o<e.args.length;o++)(n=e.args.slice(0)).splice(o,1),r=1===n.length?n[0]:a(n),i.push(a([e.args[o],r]));else for(var s=1;s<e.args.length;s++){var u=e.args[0];s>1&&(u=a(e.args.slice(0,s))),r=1===(n=e.args.slice(s)).length?n[0]:a(n),i.push(a([u,r]))}return i}(t,r),p=[],m=0;m<f.length;m++){var d=J(e,f[m],r,!0);// recursing at the same tree depth here
p=p.concat(d)}return p}else if(!(e.args.length>2))return[];else throw Error("Unexpected non-binary associative function: "+e.toString())}else if(e instanceof S){// If the rule is a SymbolNode, then it carries a special meaning
// according to the first one or two characters of the symbol node name.
// These meanings are expalined in the documentation for simplify()
if(0===e.name.length)throw Error("Symbol in rule has 0 length...!?");if(U[e.name])// built-in constant must match exactly
{if(e.name!==t.name)return[]}else switch(e.name[1]>="a"&&e.name[1]<="z"?e.name.substring(0,2):e.name[0]){case"n":case"_p":// rule matches _anything_, so assign this node to the rule.name placeholder
// Assign node to the rule.name placeholder.
// Our parent will check for matches among placeholders.
i[0].placeholders[e.name]=t;break;case"c":case"cl":// rule matches a ConstantNode
if(!k(t))return[];i[0].placeholders[e.name]=t;break;case"v":// rule matches anything other than a ConstantNode
if(k(t))return[];i[0].placeholders[e.name]=t;break;case"vl":// rule matches VariableNode
if(!V(t))return[];i[0].placeholders[e.name]=t;break;case"cd":// rule matches a ConstantNode or unaryMinus-wrapped ConstantNode
if(!nv(t))return[];i[0].placeholders[e.name]=t;break;case"vd":// rule matches anything other than a ConstantNode or unaryMinus-wrapped ConstantNode
if(nv(t))return[];i[0].placeholders[e.name]=t;break;case"ce":// rule matches expressions that have a constant value
if(!nx(t))return[];i[0].placeholders[e.name]=t;break;case"ve":// rule matches expressions that do not have a constant value
if(nx(t))return[];i[0].placeholders[e.name]=t;break;default:throw Error("Invalid symbol in rule: "+e.name)}}else if(!(e instanceof b))return[];else // Literal constant must match exactly
if(!c(e.value,t.value))return[];// It's a match!
// console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')
return i}return P}),nE=ta("simplifyConstant",["typed","config","mathWithTransform","matrix","?fraction","?bignumber","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","SymbolNode"],e=>{var{typed:t,config:r,mathWithTransform:n,matrix:i,fraction:a,bignumber:o,AccessorNode:s,ArrayNode:u,ConstantNode:l,FunctionNode:c,IndexNode:f,ObjectNode:m,OperatorNode:d,SymbolNode:h}=e,{isCommutative:y,isAssociative:v,allChildren:x,createMakeNodeFunction:b}=nw({FunctionNode:c,OperatorNode:d,SymbolNode:h}),N=t("simplifyConstant",{Node:e=>E(F(e,{})),"Node, Object":function(e,t){return E(F(e,t))}});function w(e,t,r){try{return n[e].apply(null,t)}catch(a){return(// sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions
t=t.map(function e(t){return p(t)?t.valueOf():t instanceof Array?t.map(e):g(t)?i(e(t.valueOf())):t}),S(n[e].apply(null,t),r))}}var D=t({Fraction:function(e){var t,r=e.s*e.n;return(t=r<0?new d("-","unaryMinus",[new l(-r)]):new l(r),1===e.d)?t:new d("/","divide",[t,new l(e.d)])},number:function(e){return e<0?C(new l(-e)):new l(e)},BigNumber:function(e){return e<0?C(new l(-e)):new l(e)},Complex:function(e){throw Error("Cannot convert Complex number to Node")},string:function(e){return new l(e)},Matrix:function(e){return new u(e.valueOf().map(e=>D(e)))}});function E(e){return U(e)?e:D(e)}// convert a number to a fraction only if it can be expressed exactly,
// and when both numerator and denominator are small enough
function A(e,t){if(t&&!1!==t.exactFractions&&isFinite(e)&&a){var r=a(e),n=t&&"number"==typeof t.fractionsLimit?t.fractionsLimit:1/0;if(r.valueOf()===e&&r.n<n&&r.d<n)return r}return e}// Convert numbers to a preferred number type in preference order: Fraction, number, Complex
// BigNumbers are left alone
var S=t({"string, Object":function(e,t){return"BigNumber"===r.number?(void 0===o&&ni(),o(e)):"Fraction"===r.number?(void 0===a&&na(),a(e)):A(parseFloat(e),t)},"Fraction, Object":function(e,t){return e},// we don't need options here
"BigNumber, Object":function(e,t){return e},// we don't need options here
"number, Object":function(e,t){return A(e,t)},"Complex, Object":function(e,t){return 0!==e.im?e:A(e.re,t)},"Matrix, Object":function(e,t){return i(A(e.valueOf()))},"Array, Object":function(e,t){return e.map(A)}});function C(e){return new d("-","unaryMinus",[e])}/*
   * Create a binary tree from a list of Fractions and Nodes.
   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so
   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).
   * @param args - list of Fractions and Nodes
   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions
   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes
   * if args.length is 1, returns args[0]
   * @return - Either a Node representing a binary expression or Fraction
   */function M(e,t,r,n){var i=t.shift(),a=t.reduce((t,i)=>{if(!U(i)){var a=t.pop();if(U(a))return[a,i];// Two constants in a row, try to fold them into one
try{return t.push(w(e,[a,i],n)),t}catch(e){t.push(a);// fall through to Node case
}}// Encountered a Node, or failed folding --
// collapse everything so far into a single tree:
t.push(E(t.pop()));var o=1===t.length?t[0]:r(t);return[r([o,E(i)])]},[i]);return 1===a.length?a[0]:r([a[0],D(a[1])])}// destroys the original node and returns a folded one
function F(e,t){switch(e.type){case"SymbolNode":return e;case"ConstantNode":switch(typeof e.value){case"number":return S(e.value,t);case"string":return e.value;default:if(!isNaN(e.value))return S(e.value,t)}return e;case"FunctionNode":if(n[e.name]&&n[e.name].rawArgs)return e;if(-1===["add","multiply"].indexOf(e.name)){var r=e.args.map(e=>F(e,t));// If all args are numbers
if(!r.some(U))try{return w(e.name,r,t)}catch(e){}// Size of a matrix does not depend on entries
if("size"===e.name&&1===r.length&&O(r[0])){for(var a=[],o=r[0];O(o);)a.push(o.items.length),o=o.items[0];return i(a)}// Convert all args to nodes and construct a symbolic function call
return new c(e.name,r.map(E))}/* falls through */case"OperatorNode":var p,d,h=e.fn.toString(),D=b(e);if($(e)&&e.isUnary())d=U((p=[F(e.args[0],t)])[0])?D(p):w(h,p,t);else if(v(e,t.context)){if(p=(p=x(e,t.context)).map(e=>F(e,t)),y(h,t.context)){for(var A=[],C=[],B=0;B<p.length;B++)U(p[B])?C.push(p[B]):A.push(p[B]);A.length>1?(d=M(h,A,D,t),C.unshift(d),d=M(h,C,D,t)):d=M(h,p,D,t)}else d=M(h,p,D,t)}else d=M(h,// non-associative binary operator
p=e.args.map(e=>F(e,t)),D,t);return d;case"ParenthesisNode":// remove the uneccessary parenthesis
return F(e.content,t);case"AccessorNode":return /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */function(e,t,r){if(!j(t))return new s(E(e),E(t));if(O(e)||g(e)){/* We will resolve constant indices one at a time, looking
       * just in the first or second dimensions because (a) arrays
       * of more than two dimensions are likely rare, and (b) pulling
       * out the third or higher dimension would be pretty intricate.
       * The price is that we miss simplifying [..3d array][x,y,1]
       */for(var n=Array.from(t.dimensions);n.length>0;)if(k(n[0])&&"string"!=typeof n[0].value){var a=S(n.shift().value,r);O(e)?e=e.items[a-1]:// matrix
(e=e.valueOf()[a-1])instanceof Array&&(e=i(e))}else if(n.length>1&&k(n[1])&&"string"!=typeof n[1].value){var o=S(n[1].value,r),c=[],p=O(e)?e.items:e.valueOf();for(var m of p)if(O(m))c.push(m.items[o-1]);else if(g(e))c.push(m[o-1]);else break;if(c.length===p.length)e=O(e)?new u(c):i(c),n.splice(1,1);else break}else break;return n.length===t.dimensions.length?new s(E(e),t):n.length>0?(/* Indexed some but not all dimensions */t=new f(n),new s(E(e),t)):e}if(L(e)&&1===t.dimensions.length&&k(t.dimensions[0])){var d=t.dimensions[0].value;return d in e.properties?e.properties[d]:new l}/* Don't know how to index this sort of obj, at least not with this index */return new s(E(e),t)}(F(e.object,t),F(e.index,t),t);case"ArrayNode":var T=e.items.map(e=>F(e,t));if(T.some(U))return new u(T.map(E));/* All literals -- return a Matrix so we can operate on it */return i(T);case"IndexNode":return new f(e.dimensions.map(e=>N(e,t)));case"ObjectNode":var _={};for(var z in e.properties)_[z]=N(e.properties[z],t);return new m(_);default:throw Error("Unimplemented node type in simplifyConstant: ".concat(e.type))}}return N}),nA="simplifyCore",nS=ta(nA,["typed","parse","equal","isZero","add","subtract","multiply","divide","pow","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode"],e=>{var{typed:t,parse:r,equal:n,isZero:i,add:a,subtract:o,multiply:s,divide:u,pow:l,AccessorNode:c,ArrayNode:f,ConstantNode:p,FunctionNode:m,IndexNode:d,ObjectNode:h,OperatorNode:g,ParenthesisNode:y,SymbolNode:v}=e,x=new p(0),b=new p(1),N=new p(!0),w=new p(!1);// test if a node will always have a boolean value (true/false)
// not sure if this list is complete
function D(e){return $(e)&&["and","not","or"].includes(e.op)}var{hasProperty:E,isCommutative:A}=nw({FunctionNode:m,OperatorNode:g,SymbolNode:v});/**
   * simplifyCore() performs single pass simplification suitable for
   * applications requiring ultimate performance. To roughly summarize,
   * it handles cases along the lines of simplifyConstant() but where
   * knowledge of a single argument is sufficient to determine the value.
   * In contrast, simplify() extends simplifyCore() with additional passes
   * to provide deeper simplification (such as gathering like terms).
   *
   * Specifically, simplifyCore:
   *
   * * Converts all function calls with operator equivalents to their
   *   operator forms.
   * * Removes operators or function calls that are guaranteed to have no
   *   effect (such as unary '+').
   * * Removes double unary '-', '~', and 'not'
   * * Eliminates addition/subtraction of 0 and multiplication/division/powers
   *   by 1 or 0.
   * * Converts addition of a negation into subtraction.
   * * Eliminates logical operations with constant true or false leading
   *   arguments.
   * * Puts constants on the left of a product, if multiplication is
   *   considered commutative by the options (which is the default)
   *
   * Syntax:
   *
   *     math.simplifyCore(expr)
   *     math.simplifyCore(expr, options)
   *
   * Examples:
   *
   *     const f = math.parse('2 * 1 * x ^ (1 - 0)')
   *     math.simplifyCore(f)                          // Node "2 * x"
   *     math.simplify('2 * 1 * x ^ (1 - 0)', [math.simplifyCore]) // Node "2 * x"
   *
   * See also:
   *
   *     simplify, simplifyConstant, resolve, derivative
   *
   * @param {Node | string} node
   *     The expression to be simplified
   * @param {Object} options
   *     Simplification options, as per simplify()
   * @return {Node} Returns expression with basic simplifications applied
   */function S(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=t?t.context:void 0;if(E(e,"trivial",r)){// This node does nothing if it has only one argument, so if so,
// return that argument simplified
if(P(e)&&1===e.args.length)return S(e.args[0],t);// For other node types, we try the generic methods
var a=!1,o=0;if(e.forEach(e=>{1==++o&&(a=S(e,t))}),1===o)return a}var s=e;if(P(s)){var u=function(e){var t="OperatorNode:"+e;for(var r of ty)if(t in r)return r[t].op;return null}(s.name);if(!u)return new m(S(s.fn),s.args.map(e=>S(e,t)));// Replace FunctionNode with a new OperatorNode
if(s.args.length>2&&E(s,"associative",r))for(;s.args.length>2;){var l=s.args.pop(),p=s.args.pop();s.args.push(new g(u,s.name,[l,p]))}s=new g(u,s.name,s.args)}if($(s)&&s.isUnary()){var y=S(s.args[0],t);if("~"===s.op&&$(y)&&y.isUnary()&&"~"===y.op||"not"===s.op&&$(y)&&y.isUnary()&&"not"===y.op&&D(y.args[0]))return y.args[0];var v=!0;if("-"===s.op&&$(y)&&(y.isBinary()&&"subtract"===y.fn&&(s=new g("-","subtract",[y.args[1],y.args[0]]),v=!1),y.isUnary()&&"-"===y.op))return y.args[0];if(v)return new g(s.op,s.fn,[y])}if($(s)&&s.isBinary()){var C=S(s.args[0],t),M=S(s.args[1],t);if("+"===s.op){if(k(C)&&i(C.value))return M;if(k(M)&&i(M.value))return C;$(M)&&M.isUnary()&&"-"===M.op&&(s=new g("-","subtract",[C,M=M.args[0]]))}if("-"===s.op)return $(M)&&M.isUnary()&&"-"===M.op?S(new g("+","add",[C,M.args[0]]),t):k(C)&&i(C.value)?S(new g("-","unaryMinus",[M])):k(M)&&i(M.value)?C:new g(s.op,s.fn,[C,M]);if("*"===s.op){if(k(C)){if(i(C.value))return x;if(n(C.value,1))return M}if(k(M)){if(i(M.value))return x;if(n(M.value,1))return C;if(A(s,r))return new g(s.op,s.fn,[M,C],s.implicit);// constants on left
}return new g(s.op,s.fn,[C,M],s.implicit)}if("/"===s.op)return k(C)&&i(C.value)?x:k(M)&&n(M.value,1)?C:new g(s.op,s.fn,[C,M]);if("^"===s.op&&k(M)){if(i(M.value))return b;if(n(M.value,1))return C}if("and"===s.op){if(k(C)){if(!C.value)return w;if(D(M))return M}if(k(M)){if(!M.value)return w;if(D(C))return C}}if("or"===s.op){if(k(C)){if(C.value)return N;if(D(M))return M}if(k(M)){if(M.value)return N;if(D(C))return C}}return new g(s.op,s.fn,[C,M])}if($(s))return new g(s.op,s.fn,s.args.map(e=>S(e,t)));if(O(s))return new f(s.items.map(e=>S(e,t)));if(T(s))return new c(S(s.object,t),S(s.index,t));if(j(s))return new d(s.dimensions.map(e=>S(e,t)));if(L(s)){var F={};for(var B in s.properties)F[B]=S(s.properties[B],t);return new h(F)}// cannot simplify
return s}return t(nA,{Node:S,"Node,Object":S})}),nC=ta("std",["typed","map","sqrt","variance"],e=>{var{typed:t,map:r,sqrt:n,variance:i}=e;/**
   * Compute the standard deviation of a matrix or a  list with values.
   * The standard deviations is defined as the square root of the variance:
   * `std(A) = sqrt(variance(A))`.
   * In case of a (multi dimensional) array or matrix, the standard deviation
   * over all elements will be calculated by default, unless an axis is specified
   * in which case the standard deviation will be computed along that axis.
   *
   * Additionally, it is possible to compute the standard deviation along the rows
   * or columns of a matrix by specifying the dimension as the second argument.
   *
   * Optionally, the type of normalization can be specified as the final
   * parameter. The parameter `normalization` can be one of the following values:
   *
   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
   * - 'uncorrected'        The sum of squared errors is divided by n
   * - 'biased'             The sum of squared errors is divided by (n + 1)
   *
   *
   * Syntax:
   *
   *     math.std(a, b, c, ...)
   *     math.std(A)
   *     math.std(A, normalization)
   *     math.std(A, dimension)
   *     math.std(A, dimension, normalization)
   *
   * Examples:
   *
   *     math.std(2, 4, 6)                     // returns 2
   *     math.std([2, 4, 6, 8])                // returns 2.581988897471611
   *     math.std([2, 4, 6, 8], 'uncorrected') // returns 2.23606797749979
   *     math.std([2, 4, 6, 8], 'biased')      // returns 2
   *
   *     math.std([[1, 2, 3], [4, 5, 6]])      // returns 1.8708286933869707
   *     math.std([[1, 2, 3], [4, 6, 8]], 0)    // returns [2.1213203435596424, 2.8284271247461903, 3.5355339059327378]
   *     math.std([[1, 2, 3], [4, 6, 8]], 1)    // returns [1, 2]
   *     math.std([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.7071067811865476, 1.4142135623730951]
   *
   * See also:
   *
   *    mean, median, max, min, prod, sum, variance
   *
   * @param {Array | Matrix} array
   *                        A single matrix or or multiple scalar values
   * @param {string} [normalization='unbiased']
   *                        Determines how to normalize the variance.
   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
   * @param dimension {number | BigNumber}
   *                        Determines the axis to compute the standard deviation for a matrix
   * @return {*} The standard deviation
   */return t("std",{// std([a, b, c, d, ...])
"Array | Matrix":a,// std([a, b, c, d, ...], normalization)
"Array | Matrix, string":a,// std([a, b, c, c, ...], dim)
"Array | Matrix, number | BigNumber":a,// std([a, b, c, c, ...], dim, normalization)
"Array | Matrix, number | BigNumber, string":a,// std(a, b, c, d, ...)
"...":function(e){return a(e)}});function a(e,t){if(0===e.length)throw SyntaxError("Function std requires one or more parameters (0 provided)");try{var a=i.apply(null,arguments);if(y(a))return r(a,n);return n(a)}catch(e){if(e instanceof TypeError&&-1!==e.message.indexOf(" variance"))throw TypeError(e.message.replace(" variance"," std"));throw e}}}),nM=ta("std",["typed","map","sqrt","variance"],e=>{var{typed:t,map:r,sqrt:n,variance:i}=e,a=nC({typed:t,map:r,sqrt:n,variance:i});return t("std",{"...any":function(e){e=rn(e);try{return a.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0}),nF="subset",nB=ta(nF,["typed","matrix","zeros","add"],e=>{var{typed:t,matrix:r,zeros:n,add:i}=e;/**
   * Get or set a subset of a matrix or string.
   *
   * Syntax:
   *     math.subset(value, index)                                // retrieve a subset
   *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
   *
   * Examples:
   *
   *     // get a subset
   *     const d = [[1, 2], [3, 4]]
   *     math.subset(d, math.index(1, 0))             // returns 3
   *     math.subset(d, math.index([0, 1], 1))        // returns [[2], [4]]
   *     math.subset(d, math.index([false, true], 0)) // returns [[3]]
   *
   *     // replace a subset
   *     const e = []
   *     const f = math.subset(e, math.index(0, [0, 2]), [5, 6])  // f = [[5, 0, 6]]
   *     const g = math.subset(f, math.index(1, 1), 7, 0)         // g = [[5, 0, 6], [0, 7, 0]]
   *     math.subset(g, math.index([false, true], 1), 8)          // returns [[5, 0, 6], [0, 8, 0]]
   *
   *     // get submatrix using ranges
   *     const M = [
   *       [1,2,3],
   *       [4,5,6],
   *       [7,8,9]
   *     ]
   *     math.subset(M, math.index(math.range(0,2), math.range(0,3))) // [[1, 2, 3], [4, 5, 6]]
   *
   * See also:
   *
   *     size, resize, squeeze, index
   *
   * @param {Array | Matrix | string} matrix  An array, matrix, or string
   * @param {Index} index
   *    For each dimension of the target, specifies an index or a list of
   *    indices to fetch or set. `subset` uses the cartesian product of
   *    the indices specified in each dimension.
   * @param {*} [replacement]                 An array, matrix, or scalar.
   *                                          If provided, the subset is replaced with replacement.
   *                                          If not provided, the subset is returned
   * @param {*} [defaultValue=undefined]      Default value, filled in on new entries when
   *                                          the matrix is resized. If not provided,
   *                                          math.matrix elements will be left undefined.
   * @return {Array | Matrix | string} Either the retrieved subset or the updated matrix.
   */return t(nF,{// get subset
"Matrix, Index":function(e,t){return eJ(t)?r():(eW(e,t),e.subset(t))},"Array, Index":t.referTo("Matrix, Index",function(e){return function(t,n){var i=e(r(t),n);return n.isScalar()?i:i.valueOf()}}),"Object, Index":n_,"string, Index":nT,// set subset
"Matrix, Index, any, any":function(e,t,r,a){return eJ(t)?e:(eW(e,t),e.clone().subset(t,/**
   * Broadcasts a replacment value to be the same size as index
   * @param {number | BigNumber | Array | Matrix} replacement Replacement value to try to broadcast
   * @param {*} index Index value
   * @returns broadcasted replacement that matches the size of index
   */function(e,t){if("string"==typeof e)throw Error("can't boradcast a string");if(t._isScalar)return e;var r=t.size();if(!r.every(e=>e>0))return e;try{return i(e,n(r))}catch(t){return e}}(r,t),a))},"Array, Index, any, any":t.referTo("Matrix, Index, any, any",function(e){return function(t,n,i,a){var o=e(r(t),n,i,a);return o.isMatrix?o.valueOf():o}}),"Array, Index, any":t.referTo("Matrix, Index, any, any",function(e){return function(t,n,i){return e(r(t),n,i,void 0).valueOf()}}),"Matrix, Index, any":t.referTo("Matrix, Index, any, any",function(e){return function(t,r,n){return e(t,r,n,void 0)}}),"string, Index, string":nO,"string, Index, string, string":nO,"Object, Index, any":nz})});/**
 * Retrieve a subset of a string
 * @param {string} str            string from which to get a substring
 * @param {Index} index           An index or list of indices (character positions)
 * @returns {string} substring
 * @private
 */function nT(e,t){if(!N(t))throw TypeError("Index expected");if(eJ(t))return"";if(eW(Array.from(e),t),1!==t.size().length)throw new eH(t.size().length,1);// validate whether the range is out of range
var r=e.length;eY(t.min()[0],r),eY(t.max()[0],r);var n=t.dimension(0),i="";return n.forEach(function(t){i+=e.charAt(t)}),i}/**
 * Replace a substring in a string
 * @param {string} str            string to be replaced
 * @param {Index} index           An index or list of indices (character positions)
 * @param {string} replacement    Replacement string
 * @param {string} [defaultValue] Default value to be used when resizing
 *                                the string. is ' ' by default
 * @returns {string} result
 * @private
 */function nO(e,t,r,n){if(!t||!0!==t.isIndex)throw TypeError("Index expected");if(eJ(t))return e;if(eW(Array.from(e),t),1!==t.size().length)throw new eH(t.size().length,1);if(void 0!==n){if("string"!=typeof n||1!==n.length)throw TypeError("Single character expected as defaultValue")}else n=" ";var i=t.dimension(0);if(i.size()[0]!==r.length)throw new eH(i.size()[0],r.length);// validate whether the range is out of range
var a=e.length;eY(t.min()[0]),eY(t.max()[0]);for(var o=[],s=0;s<a;s++)o[s]=e.charAt(s);// initialize undefined characters with a space
if(i.forEach(function(e,t){o[e]=r.charAt(t[0])}),o.length>a)for(var u=a-1,l=o.length;u<l;u++)o[u]||(o[u]=n);return o.join("")}/**
 * Retrieve a property from an object
 * @param {Object} object
 * @param {Index} index
 * @return {*} Returns the value of the property
 * @private
 */function n_(e,t){if(!eJ(t)){if(1!==t.size().length)throw new eH(t.size(),1);var r=t.dimension(0);if("string"!=typeof r)throw TypeError("String expected as index to retrieve an object property");return eu(e,r)}}/**
 * Set a property on an object
 * @param {Object} object
 * @param {Index} index
 * @param {*} replacement
 * @return {*} Returns the updated object
 * @private
 */function nz(e,t,r){if(eJ(t))return e;if(1!==t.size().length)throw new eH(t.size(),1);var n=t.dimension(0);if("string"!=typeof n)throw TypeError("String expected as index to retrieve an object property");// clone the object, and apply the property to the clone
var i=J(e);return el(i,n,r),i}var nq=ta("subset",["typed","matrix","zeros","add"],e=>{var{typed:t,matrix:r,zeros:n,add:i}=e,a=nB({typed:t,matrix:r,zeros:n,add:i});/**
   * Attach a transform function to math.subset
   * Adds a property transform containing the transform function.
   *
   * This transform creates a range which includes the end value
   */return t("subset",{"...any":function(e){try{return a.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0}),nk=ta("sum",["typed","config","add","numeric"],e=>{var{typed:t,config:r,add:n,numeric:i}=e;/**
   * Compute the sum of a matrix or a list with values.
   * In case of a multidimensional array or matrix, the sum of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.sum(a, b, c, ...)
   *     math.sum(A)
   *     math.sum(A, dimension)
   *
   * Examples:
   *
   *     math.sum(2, 1, 4, 3)               // returns 10
   *     math.sum([2, 1, 4, 3])             // returns 10
   *     math.sum([[2, 5], [4, 3], [1, 7]]) // returns 22
   *
   * See also:
   *
   *    mean, median, min, max, prod, std, variance, cumsum
   *
   * @param {... *} args  A single matrix or multiple scalar values
   * @return {*} The sum of all values
   */return t("sum",{// sum([a, b, c, d, ...])
"Array | Matrix":a,// sum([a, b, c, d, ...], dim)
"Array | Matrix, number | BigNumber":function(e,t){try{return tk(e,t,n)}catch(e){throw t4(e,"sum")}},// sum(a, b, c, d, ...)
"...":function(e){if(t_(e))throw TypeError("Scalar values expected in function sum");return a(e)}});/**
   * Recursively calculate the sum of an n-dimensional array
   * @param {Array | Matrix} array
   * @return {number} sum
   * @private
   */function a(e){var t;return tz(e,function(e){try{t=void 0===t?e:n(t,e)}catch(t){throw t4(t,"sum",e)}}),void 0===t&&(t=i(0,r.number)),"string"==typeof t&&(t=i(t,r.number)),t}}),nI=ta("sum",["typed","config","add","numeric"],e=>{var{typed:t,config:r,add:n,numeric:i}=e,a=nk({typed:t,config:r,add:n,numeric:i});return t("sum",{"...any":function(e){e=rn(e);try{return a.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0}),nR="symbolicEqual",nP=ta(nR,["parse","simplify","typed","OperatorNode"],e=>{var{parse:t,simplify:r,typed:n,OperatorNode:i}=e;/**
   * Attempts to determine if two expressions are symbolically equal, i.e.
   * one is the result of valid algebraic manipulations on the other.
   * Currently, this simply checks if the difference of the two expressions
   * simplifies down to 0. So there are two important caveats:
   * 1. whether two expressions are symbolically equal depends on the
   *     manipulations allowed. Therefore, this function takes an optional
   *     third argument, which are the options that control the behavior
   *     as documented for the `simplify()` function.
   * 2. it is in general intractable to find the minimal simplification of
   *     an arbitrarily complicated expression. So while a `true` value
   *     of `symbolicEqual` ensures that the two expressions can be manipulated
   *     to match each other, a `false` value does not absolutely rule this out.
   *
   * Syntax:
   *
   *     math.symbolicEqual(expr1, expr2)
   *     math.symbolicEqual(expr1, expr2, options)
   *
   * Examples:
   *
   *     math.symbolicEqual('x*y', 'y*x') // Returns true
   *     math.symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}}) // Returns false
   *     math.symbolicEqual('x/y', '(y*x^(-1))^(-1)') // Returns true
   *     math.symbolicEqual('abs(x)','x') // Returns false
   *     math.symbolicEqual('abs(x)','x', simplify.positiveContext) // Returns true
   *
   * See also:
   *
   *     simplify, evaluate
   *
   * @param {Node|string} expr1  The first expression to compare
   * @param {Node|string} expr2  The second expression to compare
   * @param {Object} [options] Optional option object, passed to simplify
   * @returns {boolean}
   *     Returns true if a valid manipulation making the expressions equal
   *     is found.
   */function a(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=r(new i("-","subtract",[e,t]),{},n);return k(a)&&!a.value}return n(nR,{"Node, Node":a,"Node, Node, Object":a})}),nj=ta("SymbolNode",["math","?Unit","Node"],e=>{var{math:t,Unit:r,Node:Node}=e;/**
   * Check whether some name is a valueless unit like "inch".
   * @param {string} name
   * @return {boolean}
   */function n(e){return!!r&&r.isValuelessUnit(e)}class i extends Node{/**
     * @constructor SymbolNode
     * @extends {Node}
     * A symbol node can hold and resolve a symbol
     * @param {string} name
     * @extends {Node}
     */constructor(e){// validate input
if(super(),"string"!=typeof e)throw TypeError('String expected for parameter "name"');this.name=e}get type(){return"SymbolNode"}get isSymbolNode(){return!0}/**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */_compile(e,t){var a=this.name;if(!0===t[a])// (like an x when inside the expression of a function
// assignment `f(x) = ...`)
return function(e,t,r){return eu(t,a)};if(a in e)return function(t,r,n){return t.has(a)?t.get(a):eu(e,a)};var o=n(a);return function(e,t,n){return e.has(a)?e.get(a):o?new r(null,a):i.onUndefinedSymbol(a)}}/**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */forEach(e){// nothing to do, we don't have any children
}/**
     * Create a new SymbolNode with children produced by the given callback.
     * Trivial since a SymbolNode has no children
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {SymbolNode} Returns a clone of the node
     */map(e){return this.clone()}/**
     * Throws an error 'Undefined symbol {name}'
     * @param {string} name
     */static onUndefinedSymbol(e){throw Error("Undefined symbol "+e)}/**
     * Create a clone of this node, a shallow copy
     * @return {SymbolNode}
     */clone(){return new i(this.name)}/**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */_toString(e){return this.name}/**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */toHTML(e){var t=eL(this.name);return"true"===t||"false"===t?'<span class="math-symbol math-boolean">'+t+"</span>":"i"===t?'<span class="math-symbol math-imaginary-symbol">'+t+"</span>":"Infinity"===t?'<span class="math-symbol math-infinity-symbol">'+t+"</span>":"NaN"===t?'<span class="math-symbol math-nan-symbol">'+t+"</span>":"null"===t?'<span class="math-symbol math-null-symbol">'+t+"</span>":"undefined"===t?'<span class="math-symbol math-undefined-symbol">'+t+"</span>":'<span class="math-symbol">'+t+"</span>"}/**
     * Get a JSON representation of the node
     * @returns {Object}
     */toJSON(){return{mathjs:"SymbolNode",name:this.name}}/**
     * Instantiate a SymbolNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", name: "x"}`,
     *                       where mathjs is optional
     * @returns {SymbolNode}
     */static fromJSON(e){return new i(e.name)}/**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */_toTex(e){var r=!1;void 0===t[this.name]&&n(this.name)&&(r=!0);var i=t1(this.name,r);return"\\"===i[0]?i:" "+i}}return i},{isClass:!0,isNode:!0}),nU="unbiased",nL="variance",n$=ta(nL,["typed","add","subtract","multiply","divide","apply","isNaN"],e=>{var{typed:t,add:r,subtract:n,multiply:i,divide:a,apply:o,isNaN:s}=e;/**
   * Compute the variance of a matrix or a  list with values.
   * In case of a multidimensional array or matrix, the variance over all
   * elements will be calculated.
   *
   * Additionally, it is possible to compute the variance along the rows
   * or columns of a matrix by specifying the dimension as the second argument.
   *
   * Optionally, the type of normalization can be specified as the final
   * parameter. The parameter `normalization` can be one of the following values:
   *
   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
   * - 'uncorrected'        The sum of squared errors is divided by n
   * - 'biased'             The sum of squared errors is divided by (n + 1)
   *
   *
   * Note that older browser may not like the variable name `var`. In that
   * case, the function can be called as `math['var'](...)` instead of
   * `math.var(...)`.
   *
   * Syntax:
   *
   *     math.variance(a, b, c, ...)
   *     math.variance(A)
   *     math.variance(A, normalization)
   *     math.variance(A, dimension)
   *     math.variance(A, dimension, normalization)
   *
   * Examples:
   *
   *     math.variance(2, 4, 6)                     // returns 4
   *     math.variance([2, 4, 6, 8])                // returns 6.666666666666667
   *     math.variance([2, 4, 6, 8], 'uncorrected') // returns 5
   *     math.variance([2, 4, 6, 8], 'biased')      // returns 4
   *
   *     math.variance([[1, 2, 3], [4, 5, 6]])      // returns 3.5
   *     math.variance([[1, 2, 3], [4, 6, 8]], 0)   // returns [4.5, 8, 12.5]
   *     math.variance([[1, 2, 3], [4, 6, 8]], 1)   // returns [1, 4]
   *     math.variance([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.5, 2]
   *
   * See also:
   *
   *    mean, median, max, min, prod, std, sum
   *
   * @param {Array | Matrix} array
   *                        A single matrix or or multiple scalar values
   * @param {string} [normalization='unbiased']
   *                        Determines how to normalize the variance.
   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
   * @param dimension {number | BigNumber}
   *                        Determines the axis to compute the variance for a matrix
   * @return {*} The variance
   */return t(nL,{// variance([a, b, c, d, ...])
"Array | Matrix":function(e){return u(e,nU)},// variance([a, b, c, d, ...], normalization)
"Array | Matrix, string":u,// variance([a, b, c, c, ...], dim)
"Array | Matrix, number | BigNumber":function(e,t){return l(e,t,nU)},// variance([a, b, c, c, ...], dim, normalization)
"Array | Matrix, number | BigNumber, string":l,// variance(a, b, c, d, ...)
"...":function(e){return u(e,nU)}});/**
   * Recursively calculate the variance of an n-dimensional array
   * @param {Array} array
   * @param {string} normalization
   *                        Determines how to normalize the variance:
   *                        - 'unbiased'    The sum of squared errors is divided by (n - 1)
   *                        - 'uncorrected' The sum of squared errors is divided by n
   *                        - 'biased'      The sum of squared errors is divided by (n + 1)
   * @return {number | BigNumber} variance
   * @private
   */function u(e,t){var o,u=0;if(0===e.length)throw SyntaxError("Function variance requires one or more parameters (0 provided)");if(tz(e,function(e){try{o=void 0===o?e:r(o,e),u++}catch(t){throw t4(t,"variance",e)}}),0===u)throw Error("Cannot calculate variance of an empty array");var l=a(o,u);if(// calculate the variance
o=void 0,tz(e,function(e){var t=n(e,l);o=void 0===o?i(t,t):r(o,i(t,t))}),s(o))return o;switch(t){case"uncorrected":return a(o,u);case"biased":return a(o,u+1);case"unbiased":var f=c(o)?o.mul(0):0;return 1===u?f:a(o,u-1);default:throw Error('Unknown normalization "'+t+'". Choose "unbiased" (default), "uncorrected", or "biased".')}}function l(e,t,r){try{if(0===e.length)throw SyntaxError("Function variance requires one or more parameters (0 provided)");return o(e,t,e=>u(e,r))}catch(e){throw t4(e,"variance")}}}),nH="variance",nZ=ta(nH,["typed","add","subtract","multiply","divide","apply","isNaN"],e=>{var{typed:t,add:r,subtract:n,multiply:i,divide:a,apply:o,isNaN:s}=e,u=n$({typed:t,add:r,subtract:n,multiply:i,divide:a,apply:o,isNaN:s});return t(nH,{"...any":function(e){e=rn(e);try{return u.apply(null,e)}catch(e){throw ts(e)}}})},{isTransformFunction:!0}),nG="number",nV="number, number";function nW(e){return Math.abs(e)}function nY(e,t){return e+t}function nJ(e,t){return e-t}function nX(e,t){return e*t}function nQ(e){return-e}function nK(e){return e}function n0(e){return eb(e)}function n1(e){return e*e*e}function n2(e){return Math.exp(e)}function n3(e){return eN(e)}function n4(e,t){if(!eh(e)||!eh(t))throw Error("Parameters in function lcm must be integer numbers");if(0===e||0===t)return 0;for(var r,n=e*t;0!==t;)t=e%(r=t),e=r;return Math.abs(n/e)}function n5(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,r=t<0;if(r&&(t=-t),0===t)throw Error("Root must be non-zero");if(e<0&&Math.abs(t)%2!=1)throw Error("Root must be odd when a is negative.");// edge cases zero and infinity
if(0===e)return r?1/0:0;if(!isFinite(e))return r?0:e;var n=Math.pow(Math.abs(e),1/t);return(// If a < 0, we require that root is an odd integer,
// so (-1) ^ (1/root) = -1
n=e<0?-n:n,r?1/n:n);// Very nice algorithm, but fails with nthRoot(-2, 3).
// Newton's method has some well-known problems at times:
// https://en.wikipedia.org/wiki/Newton%27s_method#Failure_analysis
/*
  let x = 1 // Initial guess
  let xPrev = 1
  let i = 0
  const iMax = 10000
  do {
    const delta = (a / Math.pow(x, root - 1) - x) / root
    xPrev = x
    x = x + delta
    i++
  }
  while (xPrev !== x && i < iMax)
   if (xPrev !== x) {
    throw new Error('Function nthRoot failed to converge')
  }
   return inv ? 1 / x : x
  */}function n8(e){return eg(e)}function n6(e){return e*e}function n7(e,t){var r,n,i,a=0,o=1,s=1,u=0;if(!eh(e)||!eh(t))throw Error("Parameters in function xgcd must be integer numbers");for(;t;)n=Math.floor(e/t),i=e-n*t,r=a,a=o-n*a,o=r,r=s,s=u-n*s,u=r,e=t,t=i;return e<0?[-e,-o,-u]:[e,e?o:0,u]}function n9(e,t){return(// x^Infinity === 0 if -1 < x < 1
// A real number 0 is returned instead of complex(0)
e*e<1&&t===1/0||e*e>1&&t===-1/0?0:Math.pow(e,t))}function ie(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!eh(t)||t<0||t>15)throw Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");return parseFloat(eA(e,t))}nW.signature=nG,nY.signature=nV,nJ.signature=nV,nX.signature=nV,nQ.signature=nG,nK.signature=nG,n0.signature=nG,n1.signature=nG,n2.signature=nG,n3.signature=nG,n4.signature=nV,n8.signature=nG,n6.signature=nG,n7.signature=nV,n9.signature=nV;var it=ta("abs",["typed"],e=>{var{typed:t}=e;/**
   * Calculate the absolute value of a number. For matrices, the function is
   * evaluated element wise.
   *
   * Syntax:
   *
   *    math.abs(x)
   *
   * Examples:
   *
   *    math.abs(3.5)                // returns number 3.5
   *    math.abs(-4.2)               // returns number 4.2
   *
   *    math.abs([3, -5, -1, 0, 2])  // returns Array [3, 5, 1, 0, 2]
   *
   * See also:
   *
   *    sign
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
   *            A number or matrix for which to get the absolute value
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
   *            Absolute value of `x`
   */return t("abs",{number:nW,"Complex | BigNumber | Fraction | Unit":e=>e.abs(),// deep map collection, skip zeros since abs(0) = 0
"Array | Matrix":t.referToSelf(e=>t=>tq(t,e,!0))})}),ir="acos",ii=ta(ir,["typed","config","Complex"],e=>{var{typed:t,config:r,Complex:n}=e;/**
   * Calculate the inverse cosine of a value.
   *
   * To avoid confusion with the matrix arccosine, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.acos(x)
   *
   * Examples:
   *
   *    math.acos(0.5)           // returns number 1.0471975511965979
   *    math.acos(math.cos(1.5)) // returns number 1.5
   *
   *    math.acos(2)             // returns Complex 0 + 1.3169578969248166 i
   *
   * See also:
   *
   *    cos, atan, asin
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} The arc cosine of x
   */return t(ir,{number:function(e){return e>=-1&&e<=1||r.predictable?Math.acos(e):new n(e,0).acos()},Complex:function(e){return e.acos()},BigNumber:function(e){return e.acos()}})}),ia="number";function io(e){return Math.atan(1/e)}function is(e){return isFinite(e)?(Math.log((e+1)/e)+Math.log(e/(e-1)))/2:0}function iu(e){return Math.asin(1/e)}function il(e){var t=1/e;return Math.log(t+Math.sqrt(t*t+1))}function ic(e){return Math.acos(1/e)}function ip(e){var t=1/e;return Math.log(Math.sqrt(t*t-1)+t)}function im(e){return eO(e)}function id(e){return 1/Math.tan(e)}function ih(e){var t=Math.exp(2*e);return(t+1)/(t-1)}function ig(e){return 1/Math.sin(e)}function iy(e){return(// consider values close to zero (+/-)
0===e?Number.POSITIVE_INFINITY:Math.abs(2/(Math.exp(e)-Math.exp(-e)))*eg(e))}function iv(e){return 1/Math.cos(e)}function ix(e){return 2/(Math.exp(e)+Math.exp(-e))}function ib(e){return eq(e)}io.signature=ia,is.signature=ia,iu.signature=ia,il.signature=ia,ic.signature=ia,ip.signature=ia,im.signature=ia,id.signature=ia,ih.signature=ia,ig.signature=ia,iy.signature=ia,iv.signature=ia,ix.signature=ia,ib.signature=ia;var iN="acosh",iw=ta(iN,["typed","config","Complex"],e=>{var{typed:t,config:r,Complex:n}=e;/**
   * Calculate the hyperbolic arccos of a value,
   * defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acosh(x)
   *
   * Examples:
   *
   *    math.acosh(1.5)       // returns 0.9624236501192069
   *
   * See also:
   *
   *    cosh, asinh, atanh
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic arccosine of x
   */return t(iN,{number:function(e){return e>=1||r.predictable?eT(e):e<=-1?new n(Math.log(Math.sqrt(e*e-1)-e),Math.PI):new n(e,0).acosh()},Complex:function(e){return e.acosh()},BigNumber:function(e){return e.acosh()}})}),iD="acot",iE=ta(iD,["typed","BigNumber"],e=>{var{typed:t,BigNumber:r}=e;/**
   * Calculate the inverse cotangent of a value, defined as `acot(x) = atan(1/x)`.
   *
   * To avoid confusion with the matrix arccotanget, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.acot(x)
   *
   * Examples:
   *
   *    math.acot(0.5)           // returns number 1.1071487177940904
   *    math.acot(2)             // returns number 0.4636476090008061
   *    math.acot(math.cot(1.5)) // returns number 1.5
   *
   * See also:
   *
   *    cot, atan
   *
   * @param {number | BigNumber| Complex} x   Function input
   * @return {number | BigNumber| Complex} The arc cotangent of x
   */return t(iD,{number:io,Complex:function(e){return e.acot()},BigNumber:function(e){return new r(1).div(e).atan()}})}),iA="acoth",iS=ta(iA,["typed","config","Complex","BigNumber"],e=>{var{typed:t,config:r,Complex:n,BigNumber:i}=e;/**
   * Calculate the hyperbolic arccotangent of a value,
   * defined as `acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.
   *
   * To avoid confusion with the matrix hyperbolic arccotangent, this
   * function does not apply to matrices.
   *
   * Syntax:
   *
   *    math.acoth(x)
   *
   * Examples:
   *
   *    math.acoth(0.5)       // returns 0.8047189562170503
   *
   * See also:
   *
   *    acsch, asech
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic arccotangent of x
   */return t(iA,{number:function(e){return e>=1||e<=-1||r.predictable?is(e):new n(e,0).acoth()},Complex:function(e){return e.acoth()},BigNumber:function(e){return new i(1).div(e).atanh()}})}),iC="acsc",iM=ta(iC,["typed","config","Complex","BigNumber"],e=>{var{typed:t,config:r,Complex:n,BigNumber:i}=e;/**
   * Calculate the inverse cosecant of a value, defined as `acsc(x) = asin(1/x)`.
   *
   * To avoid confusion with the matrix arccosecant, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.acsc(x)
   *
   * Examples:
   *
   *    math.acsc(2)             // returns 0.5235987755982989
   *    math.acsc(0.5)           // returns Complex 1.5707963267948966 -1.3169578969248166i
   *    math.acsc(math.csc(1.5)) // returns number ~1.5
   *
   * See also:
   *
   *    csc, asin, asec
   *
   * @param {number | BigNumber | Complex} x   Function input
   * @return {number | BigNumber | Complex} The arc cosecant of x
   */return t(iC,{number:function(e){return e<=-1||e>=1||r.predictable?iu(e):new n(e,0).acsc()},Complex:function(e){return e.acsc()},BigNumber:function(e){return new i(1).div(e).asin()}})}),iF="acsch",iB=ta(iF,["typed","BigNumber"],e=>{var{typed:t,BigNumber:r}=e;/**
   * Calculate the hyperbolic arccosecant of a value,
   * defined as `acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1))`.
   *
   * To avoid confusion with the matrix hyperbolic arccosecant, this function
   * does not apply to matrices.
   *
   * Syntax:
   *
   *    math.acsch(x)
   *
   * Examples:
   *
   *    math.acsch(0.5)       // returns 1.4436354751788103
   *
   * See also:
   *
   *    asech, acoth
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic arccosecant of x
   */return t(iF,{number:il,Complex:function(e){return e.acsch()},BigNumber:function(e){return new r(1).div(e).asinh()}})}),iT=ta("matAlgo01xDSid",["typed"],e=>{var{typed:t}=e;/**
   * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).
   * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
   *
   *
   *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  Dij          ; otherwise
   *
   *
   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
   */return function(e,r,n,i){// dense matrix arrays
var a,o,s=e._data,u=e._size,l=e._datatype,c=r._values,f=r._index,p=r._ptr,m=r._size,d=r._datatype;// validate dimensions
if(u.length!==m.length)throw new eH(u.length,m.length);// check rows & columns
if(u[0]!==m[0]||u[1]!==m[1])throw RangeError("Dimension mismatch. Matrix A ("+u+") must match Matrix B ("+m+")");// sparse matrix cannot be a Pattern matrix
if(!c)throw Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");// rows & columns
var h=u[0],g=u[1],y="string"==typeof l&&l===d?l:void 0,v=y?t.find(n,[y,y]):n,x=[];// initialize c
for(a=0;a<h;a++)x[a]=[];// workspace
var b=[],N=[];// loop columns in b
for(o=0;o<g;o++){// values in column j
for(var w=o+1,D=p[o],E=p[o+1],A=D;A<E;A++)// update workspace
b[// row
a=f[A]]=i?v(c[A],s[a][o]):v(s[a][o],c[A]),// mark i as updated
N[a]=w;// loop rows
for(a=0;a<h;a++)N[a]===w?x[a][o]=b[a]:x[a][o]=s[a][o]}// return dense matrix
return e.createDenseMatrix({data:x,size:[h,g],datatype:y})}}),iO=ta("matAlgo04xSidSid",["typed","equalScalar"],e=>{var{typed:t,equalScalar:r}=e;/**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
   * Callback function invoked MAX(NNZA, NNZB) times
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
   * C(i,j) = ┤  A(i,j)       ; A(i,j) !== 0 && B(i,j) === 0
   *          └  B(i,j)       ; A(i,j) === 0
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */return function(e,n,i){// sparse matrix arrays
var a,o,s,u,l,c,f=e._values,p=e._index,m=e._ptr,d=e._size,h=e._datatype,g=n._values,y=n._index,v=n._ptr,x=n._size,b=n._datatype;// validate dimensions
if(d.length!==x.length)throw new eH(d.length,x.length);// check rows & columns
if(d[0]!==x[0]||d[1]!==x[1])throw RangeError("Dimension mismatch. Matrix A ("+d+") must match Matrix B ("+x+")");// rows & columns
var N=d[0],w=d[1],D=r,E=0,A=i;"string"==typeof h&&h===b&&(// datatype
a=h,// find signature that matches (dt, dt)
D=t.find(r,[a,a]),// convert 0 to the same datatype
E=t.convert(0,a),// callback
A=t.find(i,[a,a]));// result arrays
var S=f&&g?[]:void 0,C=[],M=[],F=f&&g?[]:void 0,B=f&&g?[]:void 0,T=[],O=[];// loop columns
for(s=0;s<w;s++){// update cptr
M[s]=C.length;// columns mark
var _=s+1;// loop A(:,j)
for(l=m[s],c=m[s+1],u=l;u<c;u++)// row
o=p[u],// update c
C.push(o),// update workspace
T[o]=_,F&&(F[o]=f[u]);// loop B(:,j)
for(l=v[s],c=v[s+1],u=l;u<c;u++)// check row exists in A
if(T[// row
o=y[u]]===_){if(F){// invoke callback
var z=A(F[o],g[u]);// check for zero
D(z,E)?T[o]=null:F[o]=z}}else // update c
C.push(o),// update workspace
O[o]=_,B&&(B[o]=g[u]);// check we need to process values (non pattern matrix)
if(F&&B)// loop index in j
for(// initialize first index in j
u=M[s];u<C.length;)// check workspace has value @ i
T[// row
o=C[u]]===_?(// push value (Aij != 0 || (Aij != 0 && Bij != 0))
S[u]=F[o],// increment pointer
u++):O[o]===_?(// push value (bij != 0)
S[u]=B[o],// increment pointer
u++):C.splice(u,1)}// return sparse matrix
return(// update cptr
M[w]=C.length,e.createSparseMatrix({values:S,index:C,ptr:M,size:[N,w],datatype:a}))}}),i_=ta("matAlgo10xSids",["typed","DenseMatrix"],e=>{var{typed:t,DenseMatrix:r}=e;/**
   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
   * Callback function invoked NZ times (number of nonzero items in S).
   *
   *
   *          ┌  f(Sij, b)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  b          ; otherwise
   *
   *
   * @param {Matrix}   s                 The SparseMatrix instance (S)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
   */return function(e,n,i,a){// sparse matrix arrays
var o,s=e._values,u=e._index,l=e._ptr,c=e._size,f=e._datatype;// sparse matrix cannot be a Pattern matrix
if(!s)throw Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");// rows & columns
var p=c[0],m=c[1],d=i;// process data types
"string"==typeof f&&(// datatype
o=f,// convert b to the same datatype
n=t.convert(n,o),// callback
d=t.find(i,[o,o]));// loop columns
for(var h=[],g=[],y=[],v=0;v<m;v++){// values in j
for(var x=v+1,b=l[v],N=l[v+1],w=b;w<N;w++){// row
var D=u[w];// update workspace
g[D]=s[w],y[D]=x}// loop rows
for(var E=0;E<p;E++)0===v&&(h[E]=[]),y[E]===x?h[E][v]=a?d(n,g[E]):d(g[E],n):h[E][v]=n}// return dense matrix
return new r({data:h,size:[p,m],datatype:o})}}),iz=ta("matAlgo13xDD",["typed"],e=>{var{typed:t}=e;/**
   * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, Bij..z).
   * Callback function invoked MxN times.
   *
   * C(i,j,...z) = f(Aij..z, Bij..z)
   *
   * @param {Matrix}   a                 The DenseMatrix instance (A)
   * @param {Matrix}   b                 The DenseMatrix instance (B)
   * @param {Function} callback          The f(Aij..z,Bij..z) operation to invoke
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97658658
   */return function(e,r,n){// a arrays
var i,a=e._data,o=e._size,s=e._datatype,u=r._data,l=r._size,c=r._datatype,f=[];// validate dimensions
if(o.length!==l.length)throw new eH(o.length,l.length);// validate each one of the dimension sizes
for(var p=0;p<o.length;p++){// must match
if(o[p]!==l[p])throw RangeError("Dimension mismatch. Matrix A ("+o+") must match Matrix B ("+l+")");// update dimension in c
f[p]=o[p]}// callback signature to use
var m=n;// process data types
"string"==typeof s&&s===c&&(// datatype
i=s,// callback
m=t.find(n,[i,i]));// populate cdata, iterate through dimensions
var d=f.length>0?// recursive function
function e(t,r,n,i,a,o){// initialize array for this level
var s=[];// check we reach the last level
if(r===n.length-1)for(var u=0;u<i;u++)s[u]=t(a[u],o[u]);else for(var l=0;l<i;l++)s[l]=e(t,r+1,n,n[r+1],a[l],o[l]);return s}(m,0,f,f[0],a,u):[];// c matrix
return e.createDenseMatrix({data:d,size:f,datatype:i})}}),iq=ta("matAlgo14xDs",["typed"],e=>{var{typed:t}=e;/**
   * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, b).
   * Callback function invoked MxN times.
   *
   * C(i,j,...z) = f(Aij..z, b)
   *
   * @param {Matrix}   a                 The DenseMatrix instance (A)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij..z,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Aij..z)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97659042
   */return function(e,r,n,i){// a arrays
var a,o=e._data,s=e._size,u=e._datatype,l=n;// process data types
"string"==typeof u&&(// datatype
a=u,// convert b to the same datatype
r=t.convert(r,a),// callback
l=t.find(n,[a,a]));// populate cdata, iterate through dimensions
var c=s.length>0?// recursive function
function e(t,r,n,i,a,o,s){// initialize array for this level
var u=[];// check we reach the last level
if(r===n.length-1)for(var l=0;l<i;l++)u[l]=s?t(o,a[l]):t(a[l],o);else for(var c=0;c<i;c++)u[c]=e(t,r+1,n,n[r+1],a[c],o,s);return u}(l,0,s,s[0],o,r,i):[];// c matrix
return e.createDenseMatrix({data:c,size:J(s),datatype:a})}}),ik=ta("broadcast",["concat"],e=>{var{concat:t}=e;/**
  * Broadcasts two matrices, and return both in an array
  * It checks if it's possible with broadcasting rules
  *
  * @param {Matrix}   A      First Matrix
  * @param {Matrix}   B      Second Matrix
  *
  * @return {Matrix[]}      [ broadcastedA, broadcastedB ]
  */return function(e,t){var i=Math.max(e._size.length,t._size.length);// max number of dims
if(e._size.length===t._size.length&&e._size.every((e,r)=>e===t._size[r]))return[e,t];for(var a=r(e._size,i,0),o=r(t._size,i,0),s=[],u=0;u<i;u++)s[u]=Math.max(a[u],o[u]);tn(a,s),tn(o,s);// reshape A or B if needed to make them ready for concat
var l=e.clone(),c=t.clone();l._size.length<i?l.reshape(r(l._size,i,1)):c._size.length<i&&c.reshape(r(c._size,i,1));// stretches the matrices on each dimension to make them the same size
for(var f=0;f<i;f++)l._size[f]<s[f]&&(l=n(l,s[f],f)),c._size[f]<s[f]&&(c=n(c,s[f],f));// return the array with the two broadcasted matrices
return[l,c]};function r(e,t,r){// pads an array of dimensions with numbers to the left, unitl the number of dimensions is N
return[...Array(t-e.length).fill(r),...e]}function n(e,r,n){// stretches a matrix up to a certain size in a certain dimension
return t(...Array(r).fill(e),n)}}),iI=ta("matrixAlgorithmSuite",["typed","matrix","concat"],e=>{var{typed:t,matrix:r,concat:n}=e,i=iz({typed:t}),a=iq({typed:t}),o=ik({concat:n});/**
   * Return a signatures object with the usual boilerplate of
   * matrix algorithms, based on a plain options object with the
   * following properties:
   *   elop: function -- the elementwise operation to use, defaults to self
   *   SS: function -- the algorithm to apply for two sparse matrices
   *   DS: function -- the algorithm to apply for a dense and a sparse matrix
   *   SD: function -- algo for a sparse and a dense; defaults to SD flipped
   *   Ss: function -- the algorithm to apply for a sparse matrix and scalar
   *   sS: function -- algo for scalar and sparse; defaults to Ss flipped
   *   scalar: string -- typed-function type for scalars, defaults to 'any'
   *
   * If Ss is not specified, no matrix-scalar signatures are generated.
   *
   * @param {object} options
   * @return {Object<string, function>} signatures
   */return function(e){var n,s=e.elop,u=e.SD||e.DS;s?(// First the dense ones
n={"DenseMatrix, DenseMatrix":(e,t)=>i(...o(e,t),s),"Array, Array":(e,t)=>i(...o(r(e),r(t)),s).valueOf(),"Array, DenseMatrix":(e,t)=>i(...o(r(e),t),s),"DenseMatrix, Array":(e,t)=>i(...o(e,r(t)),s)},e.SS&&(n["SparseMatrix, SparseMatrix"]=(t,r)=>e.SS(...o(t,r),s,!1)),e.DS&&(n["DenseMatrix, SparseMatrix"]=(t,r)=>e.DS(...o(t,r),s,!1),n["Array, SparseMatrix"]=(t,n)=>e.DS(...o(r(t),n),s,!1)),u&&(n["SparseMatrix, DenseMatrix"]=(e,t)=>u(...o(t,e),s,!0),n["SparseMatrix, Array"]=(e,t)=>u(...o(r(t),e),s,!0))):(// No elop, use this
// First the dense ones
n={"DenseMatrix, DenseMatrix":t.referToSelf(e=>(t,r)=>i(...o(t,r),e)),"Array, Array":t.referToSelf(e=>(t,n)=>i(...o(r(t),r(n)),e).valueOf()),"Array, DenseMatrix":t.referToSelf(e=>(t,n)=>i(...o(r(t),n),e)),"DenseMatrix, Array":t.referToSelf(e=>(t,n)=>i(...o(t,r(n)),e))},e.SS&&(n["SparseMatrix, SparseMatrix"]=t.referToSelf(t=>(r,n)=>e.SS(...o(r,n),t,!1))),e.DS&&(n["DenseMatrix, SparseMatrix"]=t.referToSelf(t=>(r,n)=>e.DS(...o(r,n),t,!1)),n["Array, SparseMatrix"]=t.referToSelf(t=>(n,i)=>e.DS(...o(r(n),i),t,!1))),u&&(n["SparseMatrix, DenseMatrix"]=t.referToSelf(e=>(t,r)=>u(...o(r,t),e,!0)),n["SparseMatrix, Array"]=t.referToSelf(e=>(t,n)=>u(...o(r(n),t),e,!0))));// Now add the scalars
var l=e.scalar||"any";(e.Ds||e.Ss)&&(s?(n["DenseMatrix,"+l]=(e,t)=>a(e,t,s,!1),n[l+", DenseMatrix"]=(e,t)=>a(t,e,s,!0),n["Array,"+l]=(e,t)=>a(r(e),t,s,!1).valueOf(),n[l+", Array"]=(e,t)=>a(r(t),e,s,!0).valueOf()):(n["DenseMatrix,"+l]=t.referToSelf(e=>(t,r)=>a(t,r,e,!1)),n[l+", DenseMatrix"]=t.referToSelf(e=>(t,r)=>a(r,t,e,!0)),n["Array,"+l]=t.referToSelf(e=>(t,n)=>a(r(t),n,e,!1).valueOf()),n[l+", Array"]=t.referToSelf(e=>(t,n)=>a(r(n),t,e,!0).valueOf())));var c=void 0!==e.sS?e.sS:e.Ss;return s?(e.Ss&&(n["SparseMatrix,"+l]=(t,r)=>e.Ss(t,r,s,!1)),c&&(n[l+", SparseMatrix"]=(e,t)=>c(t,e,s,!0))):(e.Ss&&(n["SparseMatrix,"+l]=t.referToSelf(t=>(r,n)=>e.Ss(r,n,t,!1))),c&&(n[l+", SparseMatrix"]=t.referToSelf(e=>(t,r)=>c(r,t,e,!0)))),s&&s.signatures&&X(n,s.signatures),n}}),iR=ta("add",["typed","matrix","addScalar","equalScalar","DenseMatrix","SparseMatrix","concat"],e=>{var{typed:t,matrix:r,addScalar:n,equalScalar:i,DenseMatrix:a,SparseMatrix:o,concat:s}=e,u=iT({typed:t}),l=iO({typed:t,equalScalar:i}),c=i_({typed:t,DenseMatrix:a}),f=iI({typed:t,matrix:r,concat:s});/**
  * Add two or more values, `x + y`.
  * For matrices, the function is evaluated element wise.
  *
  * Syntax:
  *
  *    math.add(x, y)
  *    math.add(x, y, z, ...)
  *
  * Examples:
  *
  *    math.add(2, 3)               // returns number 5
  *    math.add(2, 3, 4)            // returns number 9
  *
  *    const a = math.complex(2, 3)
  *    const b = math.complex(-4, 1)
  *    math.add(a, b)               // returns Complex -2 + 4i
  *
  *    math.add([1, 2, 3], 4)       // returns Array [5, 6, 7]
  *
  *    const c = math.unit('5 cm')
  *    const d = math.unit('2.1 mm')
  *    math.add(c, d)               // returns Unit 52.1 mm
  *
  *    math.add("2.3", "4")         // returns number 6.3
  *
  * See also:
  *
  *    subtract, sum
  *
  * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to add
  * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to add
  * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Sum of `x` and `y`
  */return t("add",{"any, any":n,"any, any, ...any":t.referToSelf(e=>(t,r,n)=>{for(var i=e(t,r),a=0;a<n.length;a++)i=e(i,n[a]);return i})},f({elop:n,DS:u,SS:l,Ss:c}))}),iP="addScalar",ij=ta(iP,["typed"],e=>{var{typed:t}=e;/**
   * Add two scalar values, `x + y`.
   * This function is meant for internal use: it is used by the public function
   * `add`
   *
   * This function does not support collections (Array or Matrix).
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to add
   * @param  {number | BigNumber | Fraction | Complex} y          Second value to add
   * @return {number | BigNumber | Fraction | Complex | Unit}     Sum of `x` and `y`
   * @private
   */return t(iP,{"number, number":nY,"Complex, Complex":function(e,t){return e.add(t)},"BigNumber, BigNumber":function(e,t){return e.plus(t)},"Fraction, Fraction":function(e,t){return e.add(t)},"Unit, Unit":t.referToSelf(e=>(r,n)=>{if(null===r.value||void 0===r.value)throw Error("Parameter x contains a unit with undefined value");if(null===n.value||void 0===n.value)throw Error("Parameter y contains a unit with undefined value");if(!r.equalBase(n))throw Error("Units do not match");var i=r.clone();return i.value=t.find(e,[i.valueType(),n.valueType()])(i.value,n.value),i.fixPrefix=!1,i})})}),iU=ta("matAlgo02xDS0",["typed","equalScalar"],e=>{var{typed:t,equalScalar:r}=e;/**
   * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).
   * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
   *
   *
   *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
   */return function(e,n,i,a){// dense matrix arrays
var o,s=e._data,u=e._size,l=e._datatype,c=n._values,f=n._index,p=n._ptr,m=n._size,d=n._datatype;// validate dimensions
if(u.length!==m.length)throw new eH(u.length,m.length);// check rows & columns
if(u[0]!==m[0]||u[1]!==m[1])throw RangeError("Dimension mismatch. Matrix A ("+u+") must match Matrix B ("+m+")");// sparse matrix cannot be a Pattern matrix
if(!c)throw Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");// rows & columns
var h=u[0],g=u[1],y=r,v=0,x=i;"string"==typeof l&&l===d&&(// datatype
o=l,// find signature that matches (dt, dt)
y=t.find(r,[o,o]),// convert 0 to the same datatype
v=t.convert(0,o),// callback
x=t.find(i,[o,o]));// loop columns in b
for(var b=[],N=[],w=[],D=0;D<g;D++){// update cptr
w[D]=N.length;// values in column j
for(var E=p[D],A=p[D+1],S=E;S<A;S++){// row
var C=f[S],M=a?x(c[S],s[C][D]):x(s[C][D],c[S]);// check for nonzero
y(M,v)||(// push i & v
N.push(C),b.push(M))}}// return sparse matrix
return(// update cptr
w[g]=N.length,n.createSparseMatrix({values:b,index:N,ptr:w,size:[h,g],datatype:o}))}}),iL=ta("matAlgo11xS0s",["typed","equalScalar"],e=>{var{typed:t,equalScalar:r}=e;/**
   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
   * Callback function invoked NZ times (number of nonzero items in S).
   *
   *
   *          ┌  f(Sij, b)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  0          ; otherwise
   *
   *
   * @param {Matrix}   s                 The SparseMatrix instance (S)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
   */return function(e,n,i,a){// sparse matrix arrays
var o,s=e._values,u=e._index,l=e._ptr,c=e._size,f=e._datatype;// sparse matrix cannot be a Pattern matrix
if(!s)throw Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");// rows & columns
var p=c[0],m=c[1],d=r,h=0,g=i;"string"==typeof f&&(// datatype
o=f,// find signature that matches (dt, dt)
d=t.find(r,[o,o]),// convert 0 to the same datatype
h=t.convert(0,o),// convert b to the same datatype
n=t.convert(n,o),// callback
g=t.find(i,[o,o]));// loop columns
for(var y=[],v=[],x=[],b=0;b<m;b++){// initialize ptr
x[b]=v.length;// values in j
for(var N=l[b],w=l[b+1],D=N;D<w;D++){// row
var E=u[D],A=a?g(n,s[D]):g(s[D],n);// check value is zero
d(A,h)||(// push index & value
v.push(E),y.push(A))}}// return sparse matrix
return(// update ptr
x[m]=v.length,e.createSparseMatrix({values:y,index:v,ptr:x,size:[p,m],datatype:o}))}}),i$=ta("matAlgo06xS0S0",["typed","equalScalar"],e=>{var{typed:t,equalScalar:r}=e;/**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
   * Callback function invoked (Anz U Bnz) times, where Anz and Bnz are the nonzero elements in both matrices.
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
   * C(i,j) = ┤
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */return function(e,n,i){// sparse matrix arrays
var a,o=e._values,s=e._size,u=e._datatype,l=n._values,c=n._size,f=n._datatype;// validate dimensions
if(s.length!==c.length)throw new eH(s.length,c.length);// check rows & columns
if(s[0]!==c[0]||s[1]!==c[1])throw RangeError("Dimension mismatch. Matrix A ("+s+") must match Matrix B ("+c+")");// rows & columns
var p=s[0],m=s[1],d=r,h=0,g=i;"string"==typeof u&&u===f&&(// datatype
a=u,// find signature that matches (dt, dt)
d=t.find(r,[a,a]),// convert 0 to the same datatype
h=t.convert(0,a),// callback
g=t.find(i,[a,a]));// loop columns
for(var y=o&&l?[]:void 0,v=[],x=[],b=y?[]:void 0,N=[],w=[],D=0;D<m;D++){// update cptr
x[D]=v.length;// columns mark
var E=D+1;// check we need to process values (non pattern matrix)
if(tR(e,D,N,b,w,E,v,g),tR(n,D,N,b,w,E,v,g),b)// loop index in j
for(// initialize first index in j
var A=x[D];A<v.length;){// row
var S=v[A];// check function was invoked on current row (Aij !=0 && Bij != 0)
if(w[S]===E){// value @ i
var C=b[S];// check for zero value
d(C,h)?v.splice(A,1):(// push value
y.push(C),// increment pointer
A++)}else v.splice(A,1)}else // loop index in j
for(// initialize first index in j
var M=x[D];M<v.length;)// check function was invoked on current row (Aij !=0 && Bij != 0)
w[v[M]]!==E?v.splice(M,1):M++}// return sparse matrix
return(// update cptr
x[m]=v.length,e.createSparseMatrix({values:y,index:v,ptr:x,size:[p,m],datatype:a}))}}),iH="number, number";function iZ(e){return!e}function iG(e,t){return!!(e||t)}function iV(e,t){return!!e!=!!t}function iW(e,t){return!!(e&&t)}iZ.signature="number",iG.signature=iH,iV.signature=iH,iW.signature=iH;var iY=ta("and",["typed","matrix","equalScalar","zeros","not","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,zeros:i,not:a,concat:o}=e,s=iU({typed:t,equalScalar:n}),u=i$({typed:t,equalScalar:n}),l=iL({typed:t,equalScalar:n}),c=iq({typed:t}),f=iI({typed:t,matrix:r,concat:o});/**
   * Logical `and`. Test whether two values are both defined with a nonzero/nonempty value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.and(x, y)
   *
   * Examples:
   *
   *    math.and(2, 4)   // returns true
   *
   *    a = [2, 0, 0]
   *    b = [3, 7, 0]
   *    c = 0
   *
   *    math.and(a, b)   // returns [true, false, false]
   *    math.and(a, c)   // returns [false, false, false]
   *
   * See also:
   *
   *    not, or, xor
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when both inputs are defined with a nonzero/nonempty value.
   */return t("and",{"number, number":iW,"Complex, Complex":function(e,t){return(0!==e.re||0!==e.im)&&(0!==t.re||0!==t.im)},"BigNumber, BigNumber":function(e,t){return!e.isZero()&&!t.isZero()&&!e.isNaN()&&!t.isNaN()},"Unit, Unit":t.referToSelf(e=>(t,r)=>e(t.value||0,r.value||0)),"SparseMatrix, any":t.referToSelf(e=>(t,r)=>// check scalar
        a(r)?i(t.size(),t.storage()):l(t,r,e,!1)),"DenseMatrix, any":t.referToSelf(e=>(t,r)=>// check scalar
        a(r)?i(t.size(),t.storage()):c(t,r,e,!1)),"any, SparseMatrix":t.referToSelf(e=>(t,r)=>// check scalar
        a(t)?i(t.size(),t.storage()):l(r,t,e,!0)),"any, DenseMatrix":t.referToSelf(e=>(t,r)=>// check scalar
        a(t)?i(t.size(),t.storage()):c(r,t,e,!0)),"Array, any":t.referToSelf(e=>(t,n)=>e(r(t),n).valueOf()),"any, Array":t.referToSelf(e=>(t,n)=>e(t,r(n)).valueOf())},f({SS:u,DS:s}))}),iJ=ta("arg",["typed"],e=>{var{typed:t}=e;/**
   * Compute the argument of a complex value.
   * For a complex number `a + bi`, the argument is computed as `atan2(b, a)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.arg(x)
   *
   * Examples:
   *
   *    const a = math.complex(2, 2)
   *    math.arg(a) / math.pi          // returns number 0.25
   *
   *    const b = math.complex('2 + 3i')
   *    math.arg(b)                    // returns number 0.982793723247329
   *    math.atan2(3, 2)               // returns number 0.982793723247329
   *
   * See also:
   *
   *    re, im, conj, abs
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Array | Matrix} The argument of x
   */return t("arg",{number:function(e){return Math.atan2(0,e)},BigNumber:function(e){return e.constructor.atan2(0,e)},Complex:function(e){return e.arg()},// TODO: implement BigNumber support for function arg
"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),iX="asec",iQ=ta(iX,["typed","config","Complex","BigNumber"],e=>{var{typed:t,config:r,Complex:n,BigNumber:i}=e;/**
   * Calculate the inverse secant of a value. Defined as `asec(x) = acos(1/x)`.
   *
   * To avoid confusion with the matrix arcsecant, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.asec(x)
   *
   * Examples:
   *
   *    math.asec(2)             // returns 1.0471975511965979
   *    math.asec(math.sec(1.5)) // returns 1.5
   *
   *    math.asec(0.5)           // returns Complex 0 + 1.3169578969248166i
   *
   * See also:
   *
   *    acos, acot, acsc
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} The arc secant of x
   */return t(iX,{number:function(e){return e<=-1||e>=1||r.predictable?ic(e):new n(e,0).asec()},Complex:function(e){return e.asec()},BigNumber:function(e){return new i(1).div(e).acos()}})}),iK="asech",i0=ta(iK,["typed","config","Complex","BigNumber"],e=>{var{typed:t,config:r,Complex:n,BigNumber:i}=e;/**
   * Calculate the hyperbolic arcsecant of a value,
   * defined as `asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x)`.
   *
   * To avoid confusion with the matrix hyperbolic arcsecant, this function
   * does not apply to matrices.
   *
   * Syntax:
   *
   *    math.asech(x)
   *
   * Examples:
   *
   *    math.asech(0.5)       // returns 1.3169578969248166
   *
   * See also:
   *
   *    acsch, acoth
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic arcsecant of x
   */return t(iK,{number:function(e){if(e<=1&&e>=-1||r.predictable){var t=1/e;return t>0||r.predictable?ip(e):new n(Math.log(Math.sqrt(t*t-1)-t),Math.PI)}return new n(e,0).asech()},Complex:function(e){return e.asech()},BigNumber:function(e){return new i(1).div(e).acosh()}})}),i1="asin",i2=ta(i1,["typed","config","Complex"],e=>{var{typed:t,config:r,Complex:n}=e;/**
   * Calculate the inverse sine of a value.
   *
   * To avoid confusion with the matric arcsine, this function does not apply
   * to matrices.
   *
   * Syntax:
   *
   *    math.asin(x)
   *
   * Examples:
   *
   *    math.asin(0.5)           // returns number 0.5235987755982989
   *    math.asin(math.sin(1.5)) // returns number ~1.5
   *
   *    math.asin(2)             // returns Complex 1.5707963267948966 -1.3169578969248166i
   *
   * See also:
   *
   *    sin, atan, acos
   *
   * @param {number | BigNumber | Complex} x   Function input
   * @return {number | BigNumber | Complex} The arc sine of x
   */return t(i1,{number:function(e){return e>=-1&&e<=1||r.predictable?Math.asin(e):new n(e,0).asin()},Complex:function(e){return e.asin()},BigNumber:function(e){return e.asin()}})}),i3=ta("asinh",["typed"],e=>{var{typed:t}=e;/**
   * Calculate the hyperbolic arcsine of a value,
   * defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.
   *
   * To avoid confusion with the matrix hyperbolic arcsine, this function
   * does not apply to matrices.
   *
   * Syntax:
   *
   *    math.asinh(x)
   *
   * Examples:
   *
   *    math.asinh(0.5)       // returns 0.48121182505960347
   *
   * See also:
   *
   *    acosh, atanh
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic arcsine of x
   */return t("asinh",{number:im,Complex:function(e){return e.asinh()},BigNumber:function(e){return e.asinh()}})}),i4=ta("atan",["typed"],e=>{var{typed:t}=e;/**
   * Calculate the inverse tangent of a value.
   *
   * To avoid confusion with matrix arctangent, this function does not apply
   * to matrices.
   *
   * Syntax:
   *
   *    math.atan(x)
   *
   * Examples:
   *
   *    math.atan(0.5)           // returns number 0.4636476090008061
   *    math.atan(2)             // returns number 1.1071487177940904
   *    math.atan(math.tan(1.5)) // returns number 1.5
   *
   * See also:
   *
   *    tan, asin, acos
   *
   * @param {number | BigNumber | Complex} x   Function input
   * @return {number | BigNumber | Complex} The arc tangent of x
   */return t("atan",{number:function(e){return Math.atan(e)},Complex:function(e){return e.atan()},BigNumber:function(e){return e.atan()}})}),i5=ta("matAlgo03xDSf",["typed"],e=>{var{typed:t}=e;/**
   * Iterates over SparseMatrix items and invokes the callback function f(Dij, Sij).
   * Callback function invoked M*N times.
   *
   *
   *          ┌  f(Dij, Sij)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  f(Dij, 0)    ; otherwise
   *
   *
   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (C)
   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
   */return function(e,r,n,i){// dense matrix arrays
var a,o=e._data,s=e._size,u=e._datatype,l=r._values,c=r._index,f=r._ptr,p=r._size,m=r._datatype;// validate dimensions
if(s.length!==p.length)throw new eH(s.length,p.length);// check rows & columns
if(s[0]!==p[0]||s[1]!==p[1])throw RangeError("Dimension mismatch. Matrix A ("+s+") must match Matrix B ("+p+")");// sparse matrix cannot be a Pattern matrix
if(!l)throw Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");// rows & columns
var d=s[0],h=s[1],g=0,y=n;// process data types
"string"==typeof u&&u===m&&(// datatype
a=u,// convert 0 to the same datatype
g=t.convert(0,a),// callback
y=t.find(n,[a,a]));// initialize dense matrix
for(var v=[],x=0;x<d;x++)v[x]=[];// loop columns in b
for(var b=[],N=[],w=0;w<h;w++){// values in column j
for(var D=w+1,E=f[w],A=f[w+1],S=E;S<A;S++){// row
var C=c[S];// update workspace
b[C]=i?y(l[S],o[C][w]):y(o[C][w],l[S]),N[C]=D}// process workspace
for(var M=0;M<d;M++)N[M]===D?v[M][w]=b[M]:v[M][w]=i?y(g,o[M][w]):y(o[M][w],g)}// return dense matrix
return e.createDenseMatrix({data:v,size:[d,h],datatype:a})}}),i8=ta("matAlgo09xS0Sf",["typed","equalScalar"],e=>{var{typed:t,equalScalar:r}=e;/**
   * Iterates over SparseMatrix A and invokes the callback function f(Aij, Bij).
   * Callback function invoked NZA times, number of nonzero elements in A.
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0
   * C(i,j) = ┤
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */return function(e,n,i){// sparse matrix arrays
var a,o,s,u,l,c,f=e._values,p=e._index,m=e._ptr,d=e._size,h=e._datatype,g=n._values,y=n._index,v=n._ptr,x=n._size,b=n._datatype;// validate dimensions
if(d.length!==x.length)throw new eH(d.length,x.length);// check rows & columns
if(d[0]!==x[0]||d[1]!==x[1])throw RangeError("Dimension mismatch. Matrix A ("+d+") must match Matrix B ("+x+")");// rows & columns
var N=d[0],w=d[1],D=r,E=0,A=i;"string"==typeof h&&h===b&&(// datatype
a=h,// find signature that matches (dt, dt)
D=t.find(r,[a,a]),// convert 0 to the same datatype
E=t.convert(0,a),// callback
A=t.find(i,[a,a]));// result arrays
var S=f&&g?[]:void 0,C=[],M=[],F=S?[]:void 0,B=[];// loop columns
for(s=0;s<w;s++){// update cptr
M[s]=C.length;// column mark
var T=s+1;// check we need to process values
if(F)for(l=v[s],c=v[s+1],u=l;u<c;u++)// update workspace
B[// row
o=y[u]]=T,F[o]=g[u];// loop A(:,j)
for(l=m[s],c=m[s+1],u=l;u<c;u++)// check we need to process values
if(// row
o=p[u],F){// b value @ i,j
var O=B[o]===T?F[o]:E,_=A(f[u],O);// check zero value
D(_,E)||(// push index
C.push(o),// push value
S.push(_))}else C.push(o)}// return sparse matrix
return(// update cptr
M[w]=C.length,e.createSparseMatrix({values:S,index:C,ptr:M,size:[N,w],datatype:a}))}}),i6=ta("matAlgo12xSfs",["typed","DenseMatrix"],e=>{var{typed:t,DenseMatrix:r}=e;/**
   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
   * Callback function invoked MxN times.
   *
   *
   *          ┌  f(Sij, b)  ; S(i,j) !== 0
   * C(i,j) = ┤
   *          └  f(0, b)    ; otherwise
   *
   *
   * @param {Matrix}   s                 The SparseMatrix instance (S)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
   */return function(e,n,i,a){// sparse matrix arrays
var o,s=e._values,u=e._index,l=e._ptr,c=e._size,f=e._datatype;// sparse matrix cannot be a Pattern matrix
if(!s)throw Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");// rows & columns
var p=c[0],m=c[1],d=i;// process data types
"string"==typeof f&&(// datatype
o=f,// convert b to the same datatype
n=t.convert(n,o),// callback
d=t.find(i,[o,o]));// loop columns
for(var h=[],g=[],y=[],v=0;v<m;v++){// values in j
for(var x=v+1,b=l[v],N=l[v+1],w=b;w<N;w++){// row
var D=u[w];// update workspace
g[D]=s[w],y[D]=x}// loop rows
for(var E=0;E<p;E++)0===v&&(h[E]=[]),y[E]===x?h[E][v]=a?d(n,g[E]):d(g[E],n):h[E][v]=a?d(n,0):d(0,n)}// return dense matrix
return new r({data:h,size:[p,m],datatype:o})}}),i7="atan2",i9=ta(i7,["typed","matrix","equalScalar","BigNumber","DenseMatrix","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,BigNumber:i,DenseMatrix:a,concat:o}=e,s=iU({typed:t,equalScalar:n}),u=i5({typed:t}),l=i8({typed:t,equalScalar:n}),c=iL({typed:t,equalScalar:n}),f=i6({typed:t,DenseMatrix:a}),p=iI({typed:t,matrix:r,concat:o});/**
   * Calculate the inverse tangent function with two arguments, y/x.
   * By providing two arguments, the right quadrant of the computed angle can be
   * determined.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atan2(y, x)
   *
   * Examples:
   *
   *    math.atan2(2, 2) / math.pi       // returns number 0.25
   *
   *    const angle = math.unit(60, 'deg') // returns Unit 60 deg
   *    const x = math.cos(angle)
   *    const y = math.sin(angle)
   *
   *    math.atan(2)             // returns number 1.1071487177940904
   *
   * See also:
   *
   *    tan, atan, sin, cos
   *
   * @param {number | Array | Matrix} y  Second dimension
   * @param {number | Array | Matrix} x  First dimension
   * @return {number | Array | Matrix} Four-quadrant inverse tangent
   */return t(i7,{"number, number":Math.atan2,// Complex numbers doesn't seem to have a reasonable implementation of
// atan2(). Even Matlab removed the support, after they only calculated
// the atan only on base of the real part of the numbers and ignored
// the imaginary.
"BigNumber, BigNumber":(e,t)=>i.atan2(e,t)},p({scalar:"number | BigNumber",SS:l,DS:u,SD:s,Ss:c,sS:f}))}),ae="atanh",at=ta(ae,["typed","config","Complex"],e=>{var{typed:t,config:r,Complex:n}=e;/**
   * Calculate the hyperbolic arctangent of a value,
   * defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.
   *
   * To avoid confusion with the matrix hyperbolic arctangent, this function
   * does not apply to matrices.
   *
   * Syntax:
   *
   *    math.atanh(x)
   *
   * Examples:
   *
   *    math.atanh(0.5)       // returns 0.5493061443340549
   *
   * See also:
   *
   *    acosh, asinh
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic arctangent of x
   */return t(ae,{number:function(e){return e<=1&&e>=-1||r.predictable?e_(e):new n(e,0).atanh()},Complex:function(e){return e.atanh()},BigNumber:function(e){return e.atanh()}})}),ar=/* #__PURE__ */aQ("speedOfLight","299792458","m s^-1"),an=/* #__PURE__ */aQ("gravitationConstant","6.67430e-11","m^3 kg^-1 s^-2"),ai=/* #__PURE__ */aQ("planckConstant","6.62607015e-34","J s"),aa=/* #__PURE__ */aQ("reducedPlanckConstant","1.0545718176461565e-34","J s"),ao=/* #__PURE__ */aQ("magneticConstant","1.25663706212e-6","N A^-2"),as=/* #__PURE__ */aQ("electricConstant","8.8541878128e-12","F m^-1"),au=/* #__PURE__ */aQ("vacuumImpedance","376.730313667","ohm"),al=/* #__PURE__ */aQ("coulomb","8.987551792261171e9","N m^2 C^-2"),ac=/* #__PURE__ */aQ("elementaryCharge","1.602176634e-19","C"),af=/* #__PURE__ */aQ("bohrMagneton","9.2740100783e-24","J T^-1"),ap=/* #__PURE__ */aQ("conductanceQuantum","7.748091729863649e-5","S"),am=/* #__PURE__ */aQ("inverseConductanceQuantum","12906.403729652257","ohm"),ad=/* #__PURE__ */aQ("magneticFluxQuantum","2.0678338484619295e-15","Wb"),ah=/* #__PURE__ */aQ("nuclearMagneton","5.0507837461e-27","J T^-1"),ag=/* #__PURE__ */aQ("klitzing","25812.807459304513","ohm"),ay=/* #__PURE__ */aQ("bohrRadius","5.29177210903e-11","m"),av=/* #__PURE__ */aQ("classicalElectronRadius","2.8179403262e-15","m"),ax=/* #__PURE__ */aQ("electronMass","9.1093837015e-31","kg"),ab=/* #__PURE__ */aQ("fermiCoupling","1.1663787e-5","GeV^-2"),aN=aK("fineStructure",.0072973525693),aw=/* #__PURE__ */aQ("hartreeEnergy","4.3597447222071e-18","J"),aD=/* #__PURE__ */aQ("protonMass","1.67262192369e-27","kg"),aE=/* #__PURE__ */aQ("deuteronMass","3.3435830926e-27","kg"),aA=/* #__PURE__ */aQ("neutronMass","1.6749271613e-27","kg"),aS=/* #__PURE__ */aQ("quantumOfCirculation","3.6369475516e-4","m^2 s^-1"),aC=/* #__PURE__ */aQ("rydberg","10973731.568160","m^-1"),aM=/* #__PURE__ */aQ("thomsonCrossSection","6.6524587321e-29","m^2"),aF=aK("weakMixingAngle",.2229),aB=aK("efimovFactor",22.7),aT=/* #__PURE__ */aQ("atomicMass","1.66053906660e-27","kg"),aO=/* #__PURE__ */aQ("avogadro","6.02214076e23","mol^-1"),a_=/* #__PURE__ */aQ("boltzmann","1.380649e-23","J K^-1"),az=/* #__PURE__ */aQ("faraday","96485.33212331001","C mol^-1"),aq=/* #__PURE__ */aQ("firstRadiation","3.7417718521927573e-16","W m^2"),ak=/* #__PURE__ */aQ("loschmidt","2.686780111798444e25","m^-3"),aI=/* #__PURE__ */aQ("gasConstant","8.31446261815324","J K^-1 mol^-1"),aR=/* #__PURE__ */aQ("molarPlanckConstant","3.990312712893431e-10","J s mol^-1"),aP=/* #__PURE__ */aQ("molarVolume","0.022413969545014137","m^3 mol^-1"),aj=aK("sackurTetrode",-1.16487052358),aU=/* #__PURE__ */aQ("secondRadiation","0.014387768775039337","m K"),aL=/* #__PURE__ */aQ("stefanBoltzmann","5.67037441918443e-8","W m^-2 K^-4"),a$=/* #__PURE__ */aQ("wienDisplacement","2.897771955e-3","m K"),aH=/* #__PURE__ */aQ("molarMass","0.99999999965e-3","kg mol^-1"),aZ=/* #__PURE__ */aQ("molarMassC12","11.9999999958e-3","kg mol^-1"),aG=/* #__PURE__ */aQ("gravity","9.80665","m s^-2"),aV=/* #__PURE__ */aQ("planckLength","1.616255e-35","m"),aW=/* #__PURE__ */aQ("planckMass","2.176435e-8","kg"),aY=/* #__PURE__ */aQ("planckTime","5.391245e-44","s"),aJ=/* #__PURE__ */aQ("planckCharge","1.87554603778e-18","C"),aX=/* #__PURE__ */aQ("planckTemperature","1.416785e+32","K");// helper function to create a factory function which creates a physical constant,
// a Unit with either a number value or a BigNumber value depending on the configuration
function aQ(e,t,r){return ta(e,["config","Unit","BigNumber"],e=>{var{config:n,Unit:i,BigNumber:a}=e,o=new i("BigNumber"===n.number?new a(t):parseFloat(t),r);return o.fixPrefix=!0,o})}// helper function to create a factory function which creates a numeric constant,
// either a number or BigNumber depending on the configuration
function aK(e,t){return ta(e,["config","BigNumber"],e=>{var{config:r,BigNumber:n}=e;return"BigNumber"===r.number?new n(t):t})}var a0="bellNumbers",a1=ta(a0,["typed","addScalar","isNegative","isInteger","stirlingS2"],e=>{var{typed:t,addScalar:r,isNegative:n,isInteger:i,stirlingS2:a}=e;/**
   * The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S.
   * bellNumbers only takes integer arguments.
   * The following condition must be enforced: n >= 0
   *
   * Syntax:
   *
   *   math.bellNumbers(n)
   *
   * Examples:
   *
   *    math.bellNumbers(3) // returns 5
   *    math.bellNumbers(8) // returns 4140
   *
   * See also:
   *
   *    stirlingS2
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @return {Number | BigNumber}     B(n)
   */return t(a0,{"number | BigNumber":function(e){if(!i(e)||n(e))throw TypeError("Non-negative integer value expected in function bellNumbers");for(var t=0,o=0;o<=e;o++)t=r(t,a(e,o));return t}})}),a2=ta("bignumber",["typed","BigNumber"],e=>{var{typed:t,BigNumber:r}=e;/**
   * Create a BigNumber, which can store numbers with arbitrary precision.
   * When a matrix is provided, all elements will be converted to BigNumber.
   *
   * Syntax:
   *
   *    math.bignumber(x)
   *
   * Examples:
   *
   *    0.1 + 0.2                                  // returns number 0.30000000000000004
   *    math.bignumber(0.1) + math.bignumber(0.2)  // returns BigNumber 0.3
   *
   *
   *    7.2e500                                    // returns number Infinity
   *    math.bignumber('7.2e500')                  // returns BigNumber 7.2e500
   *
   * See also:
   *
   *    boolean, complex, index, matrix, string, unit
   *
   * @param {number | string | Fraction | BigNumber | Array | Matrix | boolean | null} [value]  Value for the big number,
   *                                                    0 by default.
   * @returns {BigNumber} The created bignumber
   */return t("bignumber",{"":function(){return new r(0)},number:function(e){// convert to string to prevent errors in case of >15 digits
return new r(e+"")},string:function(e){var t=e.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);if(t){// x has a word size suffix
var n=t[2],i=r(t[1]),a=new r(2).pow(Number(n));if(i.gt(a.sub(1)))throw SyntaxError('String "'.concat(e,'" is out of range'));var o=new r(2).pow(Number(n)-1);return i.gte(o)?i.sub(a):i}return new r(e)},BigNumber:function(e){// we assume a BigNumber is immutable
return e},Unit:t.referToSelf(e=>t=>{var r=t.clone();return r.value=e(t.value),r}),Fraction:function(e){return new r(e.n).div(e.d).times(e.s)},null:function(e){return new r(0)},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),a3={};!function(e){/*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   */// -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //
// The maximum exponent magnitude.
// The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
var t,r,n,i,a="0123456789abcdef",o="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",s="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",u={// These values must be integers within the stated ranges (inclusive).
// Most of these values can be changed at run-time using the `Decimal.config` method.
// The maximum number of significant digits of the result of a calculation or base conversion.
// E.g. `Decimal.config({ precision: 20 });`
precision:20,// The rounding mode used when rounding to `precision`.
//
// ROUND_UP         0 Away from zero.
// ROUND_DOWN       1 Towards zero.
// ROUND_CEIL       2 Towards +Infinity.
// ROUND_FLOOR      3 Towards -Infinity.
// ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
// ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
// ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
// ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
// ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
//
// E.g.
// `Decimal.rounding = 4;`
// `Decimal.rounding = Decimal.ROUND_HALF_UP;`
rounding:4,// The modulo mode used when calculating the modulus: a mod n.
// The quotient (q = a / n) is calculated according to the corresponding rounding mode.
// The remainder (r) is calculated as: r = a - n * q.
//
// UP         0 The remainder is positive if the dividend is negative, else is negative.
// DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
// FLOOR      3 The remainder has the same sign as the divisor (Python %).
// HALF_EVEN  6 The IEEE 754 remainder function.
// EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
//
// Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
// division (9) are commonly used for the modulus operation. The other rounding modes can also
// be used, but they may not give useful results.
modulo:1,// The exponent value at and beneath which `toString` returns exponential notation.
// JavaScript numbers: -7
toExpNeg:-7,// The exponent value at and above which `toString` returns exponential notation.
// JavaScript numbers: 21
toExpPos:21,// The minimum exponent value, beneath which underflow to zero occurs.
// JavaScript numbers: -324  (5e-324)
minE:-9e15,// The maximum exponent value, above which overflow to Infinity occurs.
// JavaScript numbers: 308  (1.7976931348623157e+308)
maxE:9e15,// Whether to use cryptographically-secure random number generation, if available.
crypto:!1// true/false
},l=!0,c="[DecimalError] ",f=c+"Invalid argument: ",p=c+"Precision limit exceeded",m=c+"crypto unavailable",d="[object Decimal]",h=Math.floor,g=Math.pow,y=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,v=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,x=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,b=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,N=o.length-1,w=s.length-1,D={toStringTag:d};// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.
/*
   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
   *                           finiteToString, naturalExponential, naturalLogarithm
   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
   *  convertBase              toStringBinary, parseOther
   *  cos                      P.cos
   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
   *                           taylorSeries, atan2, parseOther
   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
   *                           P.truncated, divide, getLn10, getPi, naturalExponential,
   *                           naturalLogarithm, ceil, floor, round, trunc
   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
   *                           toStringBinary
   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
   *  getLn10                  P.logarithm, naturalLogarithm
   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
   *  getPrecision             P.precision, P.toFraction
   *  getZeroString            digitsToString, finiteToString
   *  intPow                   P.toPower, parseOther
   *  isOdd                    toLessThanHalfPi
   *  maxOrMin                 max, min
   *  naturalExponential       P.naturalExponential, P.toPower
   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
   *                           P.toPower, naturalExponential
   *  nonFiniteToString        finiteToString, toStringBinary
   *  parseDecimal             Decimal
   *  parseOther               Decimal
   *  sin                      P.sin
   *  taylorSeries             P.cosh, P.sinh, cos, sin
   *  toLessThanHalfPi         P.cos, P.sin
   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
   *  truncate                 intPow
   *
   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
   *                           naturalLogarithm, config, parseOther, random, Decimal
   */function E(e){var t,r,n,i=e.length-1,a="",o=e[0];if(i>0){for(a+=o,t=1;t<i;t++)(r=7-(n=e[t]+"").length)&&(a+=q(r)),a+=n;(r=7-(n=(o=e[t])+"").length)&&(a+=q(r))}else if(0===o)return"0";// Remove trailing zeros of last w.
for(;o%10==0;)o/=10;return a+o}function A(e,t,r){if(e!==~~e||e<t||e>r)throw Error(f+e)}/*
   * Check 5 rounding digits if `repeating` is null, 4 otherwise.
   * `repeating == null` if caller is `log` or `pow`,
   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
   */function S(e,t,r,n){var i,a,o,s;// Get the length of the first word of the array d.
for(a=e[0];a>=10;a/=10)--t;return--t<0?(t+=7,i=0):(i=Math.ceil((t+1)/7),t%=7),// i is the index (0 - 6) of the rounding digit.
// E.g. if within the word 3487563 the first rounding digit is 5,
// then i = 4, k = 1000, rd = 3487563 % 1000 = 563
a=g(10,7-t),s=e[i]%a|0,null==n?t<3?(0==t?s=s/100|0:1==t&&(s=s/10|0),o=r<4&&99999==s||r>3&&49999==s||5e4==s||0==s):o=(r<4&&s+1==a||r>3&&s+1==a/2)&&(e[i+1]/a/100|0)==g(10,t-2)-1||(s==a/2||0==s)&&(e[i+1]/a/100|0)==0:t<4?(0==t?s=s/1e3|0:1==t?s=s/100|0:2==t&&(s=s/10|0),o=(n||r<4)&&9999==s||!n&&r>3&&4999==s):o=((n||r<4)&&s+1==a||!n&&r>3&&s+1==a/2)&&(e[i+1]/a/1e3|0)==g(10,t-3)-1,o}// Convert string of `baseIn` to an array of numbers of `baseOut`.
// Eg. convertBase('255', 10, 16) returns [15, 15].
// Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
function C(e,t,r){for(var n,i,o=[0],s=0,u=e.length;s<u;){for(i=o.length;i--;)o[i]*=t;for(o[0]+=a.indexOf(e.charAt(s++)),n=0;n<o.length;n++)o[n]>r-1&&(void 0===o[n+1]&&(o[n+1]=0),o[n+1]+=o[n]/r|0,o[n]%=r)}return o.reverse()}// Decimal prototype methods
/*
   *  absoluteValue             abs
   *  ceil
   *  clampedTo                 clamp
   *  comparedTo                cmp
   *  cosine                    cos
   *  cubeRoot                  cbrt
   *  decimalPlaces             dp
   *  dividedBy                 div
   *  dividedToIntegerBy        divToInt
   *  equals                    eq
   *  floor
   *  greaterThan               gt
   *  greaterThanOrEqualTo      gte
   *  hyperbolicCosine          cosh
   *  hyperbolicSine            sinh
   *  hyperbolicTangent         tanh
   *  inverseCosine             acos
   *  inverseHyperbolicCosine   acosh
   *  inverseHyperbolicSine     asinh
   *  inverseHyperbolicTangent  atanh
   *  inverseSine               asin
   *  inverseTangent            atan
   *  isFinite
   *  isInteger                 isInt
   *  isNaN
   *  isNegative                isNeg
   *  isPositive                isPos
   *  isZero
   *  lessThan                  lt
   *  lessThanOrEqualTo         lte
   *  logarithm                 log
   *  [maximum]                 [max]
   *  [minimum]                 [min]
   *  minus                     sub
   *  modulo                    mod
   *  naturalExponential        exp
   *  naturalLogarithm          ln
   *  negated                   neg
   *  plus                      add
   *  precision                 sd
   *  round
   *  sine                      sin
   *  squareRoot                sqrt
   *  tangent                   tan
   *  times                     mul
   *  toBinary
   *  toDecimalPlaces           toDP
   *  toExponential
   *  toFixed
   *  toFraction
   *  toHexadecimal             toHex
   *  toNearest
   *  toNumber
   *  toOctal
   *  toPower                   pow
   *  toPrecision
   *  toSignificantDigits       toSD
   *  toString
   *  truncated                 trunc
   *  valueOf                   toJSON
   *//*
   * Return a new Decimal whose value is the absolute value of this Decimal.
   *
   */D.absoluteValue=D.abs=function(){var e=new this.constructor(this);return e.s<0&&(e.s=1),F(e)},/*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of positive Infinity.
   *
   */D.ceil=function(){return F(new this.constructor(this),this.e+1,2)},/*
   * Return a new Decimal whose value is the value of this Decimal clamped to the range
   * delineated by `min` and `max`.
   *
   * min {number|string|Decimal}
   * max {number|string|Decimal}
   *
   */D.clampedTo=D.clamp=function(e,t){var r=this.constructor;if(e=new r(e),t=new r(t),!e.s||!t.s)return new r(NaN);if(e.gt(t))throw Error(f+t);return 0>this.cmp(e)?e:this.cmp(t)>0?t:new r(this)},/*
   * Return
   *   1    if the value of this Decimal is greater than the value of `y`,
   *  -1    if the value of this Decimal is less than the value of `y`,
   *   0    if they have the same value,
   *   NaN  if the value of either Decimal is NaN.
   *
   */D.comparedTo=D.cmp=function(e){var t,r,n,i,a=this.d,o=(e=new this.constructor(e)).d,s=this.s,u=e.s;// Either NaN or ±Infinity?
if(!a||!o)return s&&u?s!==u?s:a===o?0:!a^s<0?1:-1:NaN;// Either zero?
if(!a[0]||!o[0])return a[0]?s:o[0]?-u:0;// Signs differ?
if(s!==u)return s;// Compare exponents.
if(this.e!==e.e)return this.e>e.e^s<0?1:-1;// Compare digit by digit.
for(t=0,r=(n=a.length)<(i=o.length)?n:i;t<r;++t)if(a[t]!==o[t])return a[t]>o[t]^s<0?1:-1;// Compare lengths.
return n===i?0:n>i^s<0?1:-1},/*
   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * cos(0)         = 1
   * cos(-0)        = 1
   * cos(Infinity)  = NaN
   * cos(-Infinity) = NaN
   * cos(NaN)       = NaN
   *
   */D.cosine=D.cos=function(){var e,t,r=this,n=r.constructor;return r.d?r.d[0]?(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+7,n.rounding=1,r=/*
   * cos(x) = 1 - x^2/2! + x^4/4! - ...
   * |x| < pi/2
   *
   */function(e,t){var r,n,i;if(t.isZero())return t;// Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
// i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1
// Estimate the optimum number of times to use the argument reduction.
(n=t.d.length)<32?i=(1/H(4,r=Math.ceil(n/3))).toString():(r=16,i="2.3283064365386962890625e-10"),e.precision+=r,t=$(e,1,t.times(i),new e(1));// Reverse argument reduction
for(var a=r;a--;){var o=t.times(t);t=o.times(o).minus(o).times(8).plus(1)}return e.precision-=r,t}(n,Z(n,r)),n.precision=e,n.rounding=t,F(2==i||3==i?r.neg():r,e,t,!0)):new n(1):new n(NaN)},/*
   *
   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   *  cbrt(0)  =  0
   *  cbrt(-0) = -0
   *  cbrt(1)  =  1
   *  cbrt(-1) = -1
   *  cbrt(N)  =  N
   *  cbrt(-I) = -I
   *  cbrt(I)  =  I
   *
   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
   *
   */D.cubeRoot=D.cbrt=function(){var e,t,r,n,i,a,o,s,u,c,f=this.constructor;if(!this.isFinite()||this.isZero())return new f(this);// Halley's method.
// TODO? Compare Newton's method.
for(l=!1,// Initial estimate.
(a=this.s*g(this.s*this,1/3))&&Math.abs(a)!=1/0?n=new f(a.toString()):(r=E(this.d),(a=((e=this.e)-r.length+1)%3)&&(r+=1==a||-2==a?"0":"00"),a=g(r,1/3),// Rarely, e may be one less than the result exponent value.
e=h((e+1)/3)-(e%3==(e<0?-1:2)),(n=new f(r=a==1/0?"5e"+e:(r=a.toExponential()).slice(0,r.indexOf("e")+1)+e)).s=this.s),o=(e=f.precision)+3;;)// TODO? Replace with for-loop and checkRoundingDigits.
if(n=M((c=(u=(s=n).times(s).times(s)).plus(this)).plus(this).times(s),c.plus(u),o+2,1),E(s.d).slice(0,o)===(r=E(n.d)).slice(0,o)){// The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
// , i.e. approaching a rounding boundary, continue the iteration.
if("9999"!=(r=r.slice(o-3,o+1))&&(i||"4999"!=r)){// If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
// If not, then there are further digits and m will be truthy.
+r&&(+r.slice(1)||"5"!=r.charAt(0))||(// Truncate to the first rounding digit.
F(n,e+1,1),t=!n.times(n).times(n).eq(this));break}// On the first iteration only, check to see if rounding up gives the exact result as the
// nines may infinitely repeat.
if(!i&&(F(s,e+1,0),s.times(s).times(s).eq(this))){n=s;break}o+=4,i=1}return l=!0,F(n,e,f.rounding,t)},/*
   * Return the number of decimal places of the value of this Decimal.
   *
   */D.decimalPlaces=D.dp=function(){var e,t=this.d,r=NaN;if(t){if(r=((e=t.length-1)-h(this.e/7))*7,// Subtract the number of trailing zeros of the last word.
e=t[e])for(;e%10==0;e/=10)r--;r<0&&(r=0)}return r},/*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   */D.dividedBy=D.div=function(e){return M(this,new this.constructor(e))},/*
   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */D.dividedToIntegerBy=D.divToInt=function(e){var t=this.constructor;return F(M(this,new t(e),0,1,1),t.precision,t.rounding)},/*
   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
   *
   */D.equals=D.eq=function(e){return 0===this.cmp(e)},/*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of negative Infinity.
   *
   */D.floor=function(){return F(new this.constructor(this),this.e+1,3)},/*
   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
   * false.
   *
   */D.greaterThan=D.gt=function(e){return this.cmp(e)>0},/*
   * Return true if the value of this Decimal is greater than or equal to the value of `y`,
   * otherwise return false.
   *
   */D.greaterThanOrEqualTo=D.gte=function(e){var t=this.cmp(e);return 1==t||0===t},/*
   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [1, Infinity]
   *
   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
   *
   * cosh(0)         = 1
   * cosh(-0)        = 1
   * cosh(Infinity)  = Infinity
   * cosh(-Infinity) = Infinity
   * cosh(NaN)       = NaN
   *
   *  x        time taken (ms)   result
   * 1000      9                 9.8503555700852349694e+433
   * 10000     25                4.4034091128314607936e+4342
   * 100000    171               1.4033316802130615897e+43429
   * 1000000   3817              1.5166076984010437725e+434294
   * 10000000  abandoned after 2 minute wait
   *
   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
   *
   */D.hyperbolicCosine=D.cosh=function(){var e,t,r,n,i,a=this,o=a.constructor,s=new o(1);if(!a.isFinite())return new o(a.s?1/0:NaN);if(a.isZero())return s;r=o.precision,n=o.rounding,o.precision=r+Math.max(a.e,a.sd())+4,o.rounding=1,(i=a.d.length)<32?t=(1/H(4,e=Math.ceil(i/3))).toString():(e=16,t="2.3283064365386962890625e-10"),a=$(o,1,a.times(t),new o(1),!0);for(// Reverse argument reduction
var u,l=e,c=new o(8);l--;)u=a.times(a),a=s.minus(u.times(c.minus(u.times(c))));return F(a,o.precision=r,o.rounding=n,!0)},/*
   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
   *
   * sinh(0)         = 0
   * sinh(-0)        = -0
   * sinh(Infinity)  = Infinity
   * sinh(-Infinity) = -Infinity
   * sinh(NaN)       = NaN
   *
   * x        time taken (ms)
   * 10       2 ms
   * 100      5 ms
   * 1000     14 ms
   * 10000    82 ms
   * 100000   886 ms            1.4033316802130615897e+43429
   * 200000   2613 ms
   * 300000   5407 ms
   * 400000   8824 ms
   * 500000   13026 ms          8.7080643612718084129e+217146
   * 1000000  48543 ms
   *
   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
   *
   */D.hyperbolicSine=D.sinh=function(){var e,t,r,n,i=this,a=i.constructor;if(!i.isFinite()||i.isZero())return new a(i);if(t=a.precision,r=a.rounding,a.precision=t+Math.max(i.e,i.sd())+4,a.rounding=1,(n=i.d.length)<3)i=$(a,2,i,i,!0);else{e=// Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
// i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
// 3 multiplications and 1 addition
// Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
// i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
// 4 multiplications and 2 additions
// Estimate the optimum number of times to use the argument reduction.
(e=1.4*Math.sqrt(n))>16?16:0|e,i=$(a,2,i=i.times(1/H(5,e)),i,!0);for(// Reverse argument reduction
var o,s=new a(5),u=new a(16),l=new a(20);e--;)o=i.times(i),i=i.times(s.plus(o.times(u.times(o).plus(l))))}return a.precision=t,a.rounding=r,F(i,t,r,!0)},/*
   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * tanh(x) = sinh(x) / cosh(x)
   *
   * tanh(0)         = 0
   * tanh(-0)        = -0
   * tanh(Infinity)  = 1
   * tanh(-Infinity) = -1
   * tanh(NaN)       = NaN
   *
   */D.hyperbolicTangent=D.tanh=function(){var e,t,r=this.constructor;return this.isFinite()?this.isZero()?new r(this):(e=r.precision,t=r.rounding,r.precision=e+7,r.rounding=1,M(this.sinh(),this.cosh(),r.precision=e,r.rounding=t)):new r(this.s)},/*
   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
   * this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [0, pi]
   *
   * acos(x) = pi/2 - asin(x)
   *
   * acos(0)       = pi/2
   * acos(-0)      = pi/2
   * acos(1)       = 0
   * acos(-1)      = pi
   * acos(1/2)     = pi/3
   * acos(-1/2)    = 2*pi/3
   * acos(|x| > 1) = NaN
   * acos(NaN)     = NaN
   *
   */D.inverseCosine=D.acos=function(){var e,t=this,r=t.constructor,n=t.abs().cmp(1),i=r.precision,a=r.rounding;return -1!==n?0===n?t.isNeg()?_(r,i,a):new r(0):new r(NaN):t.isZero()?_(r,i+4,a).times(.5):(// TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3
r.precision=i+6,r.rounding=1,t=t.asin(),e=_(r,i+4,a).times(.5),r.precision=i,r.rounding=a,e.minus(t))},/*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
   * value of this Decimal.
   *
   * Domain: [1, Infinity]
   * Range: [0, Infinity]
   *
   * acosh(x) = ln(x + sqrt(x^2 - 1))
   *
   * acosh(x < 1)     = NaN
   * acosh(NaN)       = NaN
   * acosh(Infinity)  = Infinity
   * acosh(-Infinity) = NaN
   * acosh(0)         = NaN
   * acosh(-0)        = NaN
   * acosh(1)         = 0
   * acosh(-1)        = NaN
   *
   */D.inverseHyperbolicCosine=D.acosh=function(){var e,t,r=this,n=r.constructor;return r.lte(1)?new n(r.eq(1)?0:NaN):r.isFinite()?(e=n.precision,t=n.rounding,n.precision=e+Math.max(Math.abs(r.e),r.sd())+4,n.rounding=1,l=!1,r=r.times(r).minus(1).sqrt().plus(r),l=!0,n.precision=e,n.rounding=t,r.ln()):new n(r)},/*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * asinh(x) = ln(x + sqrt(x^2 + 1))
   *
   * asinh(NaN)       = NaN
   * asinh(Infinity)  = Infinity
   * asinh(-Infinity) = -Infinity
   * asinh(0)         = 0
   * asinh(-0)        = -0
   *
   */D.inverseHyperbolicSine=D.asinh=function(){var e,t,r=this,n=r.constructor;return!r.isFinite()||r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+2*Math.max(Math.abs(r.e),r.sd())+6,n.rounding=1,l=!1,r=r.times(r).plus(1).sqrt().plus(r),l=!0,n.precision=e,n.rounding=t,r.ln())},/*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
   * value of this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [-Infinity, Infinity]
   *
   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
   *
   * atanh(|x| > 1)   = NaN
   * atanh(NaN)       = NaN
   * atanh(Infinity)  = NaN
   * atanh(-Infinity) = NaN
   * atanh(0)         = 0
   * atanh(-0)        = -0
   * atanh(1)         = Infinity
   * atanh(-1)        = -Infinity
   *
   */D.inverseHyperbolicTangent=D.atanh=function(){var e,t,r,n,i=this,a=i.constructor;return i.isFinite()?i.e>=0?new a(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=a.precision,t=a.rounding,Math.max(n=i.sd(),e)<-(2*i.e)-1)?F(new a(i),e,t,!0):(a.precision=r=n-i.e,i=M(i.plus(1),new a(1).minus(i),r+e,1),a.precision=e+4,a.rounding=1,i=i.ln(),a.precision=e,a.rounding=t,i.times(.5)):new a(NaN)},/*
   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
   *
   * asin(0)       = 0
   * asin(-0)      = -0
   * asin(1/2)     = pi/6
   * asin(-1/2)    = -pi/6
   * asin(1)       = pi/2
   * asin(-1)      = -pi/2
   * asin(|x| > 1) = NaN
   * asin(NaN)     = NaN
   *
   * TODO? Compare performance of Taylor series.
   *
   */D.inverseSine=D.asin=function(){var e,t,r,n,i=this,a=i.constructor;return i.isZero()?new a(i):(t=i.abs().cmp(1),r=a.precision,n=a.rounding,-1!==t)?// |x| is 1
0===t?((e=_(a,r+4,n).times(.5)).s=i.s,e):new a(NaN):(// TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6
a.precision=r+6,a.rounding=1,i=i.div(new a(1).minus(i.times(i)).sqrt().plus(1)).atan(),a.precision=r,a.rounding=n,i.times(2))},/*
   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
   *
   * atan(0)         = 0
   * atan(-0)        = -0
   * atan(1)         = pi/4
   * atan(-1)        = -pi/4
   * atan(Infinity)  = pi/2
   * atan(-Infinity) = -pi/2
   * atan(NaN)       = NaN
   *
   */D.inverseTangent=D.atan=function(){var e,t,r,n,i,a,o,s,u,c=this,f=c.constructor,p=f.precision,m=f.rounding;if(c.isFinite()){if(c.isZero())return new f(c);if(c.abs().eq(1)&&p+4<=w)return(o=_(f,p+4,m).times(.25)).s=c.s,o}else{if(!c.s)return new f(NaN);if(p+4<=w)return(o=_(f,p+4,m).times(.5)).s=c.s,o}for(f.precision=s=p+10,f.rounding=1,e=// TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);
// Argument reduction
// Ensure |x| < 0.42
// atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))
r=Math.min(28,s/7+2|0);e;--e)c=c.div(c.times(c).plus(1).sqrt().plus(1));// atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
for(l=!1,t=Math.ceil(s/7),n=1,u=c.times(c),o=new f(c),i=c;-1!==e;)if(i=i.times(u),a=o.minus(i.div(n+=2)),i=i.times(u),void 0!==(o=a.plus(i.div(n+=2))).d[t])for(e=t;o.d[e]===a.d[e]&&e--;);return r&&(o=o.times(2<<r-1)),l=!0,F(o,f.precision=p,f.rounding=m,!0)},/*
   * Return true if the value of this Decimal is a finite number, otherwise return false.
   *
   */D.isFinite=function(){return!!this.d},/*
   * Return true if the value of this Decimal is an integer, otherwise return false.
   *
   */D.isInteger=D.isInt=function(){return!!this.d&&h(this.e/7)>this.d.length-2},/*
   * Return true if the value of this Decimal is NaN, otherwise return false.
   *
   */D.isNaN=function(){return!this.s},/*
   * Return true if the value of this Decimal is negative, otherwise return false.
   *
   */D.isNegative=D.isNeg=function(){return this.s<0},/*
   * Return true if the value of this Decimal is positive, otherwise return false.
   *
   */D.isPositive=D.isPos=function(){return this.s>0},/*
   * Return true if the value of this Decimal is 0 or -0, otherwise return false.
   *
   */D.isZero=function(){return!!this.d&&0===this.d[0]},/*
   * Return true if the value of this Decimal is less than `y`, otherwise return false.
   *
   */D.lessThan=D.lt=function(e){return 0>this.cmp(e)},/*
   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
   *
   */D.lessThanOrEqualTo=D.lte=function(e){return 1>this.cmp(e)},/*
   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * If no base is specified, return log[10](arg).
   *
   * log[base](arg) = ln(arg) / ln(base)
   *
   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
   * otherwise:
   *
   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
   * between the result and the correctly rounded result will be one ulp (unit in the last place).
   *
   * log[-b](a)       = NaN
   * log[0](a)        = NaN
   * log[1](a)        = NaN
   * log[NaN](a)      = NaN
   * log[Infinity](a) = NaN
   * log[b](0)        = -Infinity
   * log[b](-0)       = -Infinity
   * log[b](-a)       = NaN
   * log[b](1)        = 0
   * log[b](Infinity) = Infinity
   * log[b](NaN)      = NaN
   *
   * [base] {number|string|Decimal} The base of the logarithm.
   *
   */D.logarithm=D.log=function(e){var t,r,n,i,a,o,s,u=this.constructor,c=u.precision,f=u.rounding;// Default base is 10.
if(null==e)e=new u(10),t=!0;else{// Return NaN if base is negative, or non-finite, or is 0 or 1.
if(r=(e=new u(e)).d,e.s<0||!r||!r[0]||e.eq(1))return new u(NaN);t=e.eq(10)}// Is arg negative, non-finite, 0 or 1?
if(r=this.d,this.s<0||!r||!r[0]||this.eq(1))return new u(r&&!r[0]?-1/0:1!=this.s?NaN:r?0:1/0);// The result will have a non-terminating decimal expansion if base is 10 and arg is not an
// integer power of 10.
if(t){if(r.length>1)i=!0;else{for(n=r[0];n%10==0;)n/=10;i=1!==n}}// If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
// calculate 10 further digits.
//
// If the result is known to have an infinite decimal expansion, repeat this until it is clear
// that the result is above or below the boundary. Otherwise, if after calculating the 10
// further digits, the last 14 are nines, round up and assume the result is exact.
// Also assume the result is exact if the last 14 are zero.
//
// Example of a result that will be incorrectly rounded:
// log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
// The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
// will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
// the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
// place is still 2.6.
if(l=!1,S(// The result will have 5 rounding digits.
(s=M(j(this,o=c+5),t?O(u,o+10):j(e,o),o,1)).d,n=c,f))do if(o+=10,s=M(j(this,o),t?O(u,o+10):j(e,o),o,1),!i){// Check for 14 nines from the 2nd rounding digit, as the first may be 4.
+E(s.d).slice(n+1,n+15)+1==1e14&&(s=F(s,c+1,0));break}while(S(s.d,n+=10,f))return l=!0,F(s,c,f)},/*
   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.max = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'lt');
  };
   *//*
   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.min = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'gt');
  };
   *//*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */D.minus=D.sub=function(e){var t,r,n,i,a,o,s,u,c,f,p,m,d=this.constructor;// If either is not finite...
if(e=new d(e),!this.d||!e.d)return this.s&&e.s?this.d?e.s=-e.s:e=new d(e.d||this.s!==e.s?this:NaN):e=new d(NaN),e;// If signs differ...
if(this.s!=e.s)return e.s=-e.s,this.plus(e);// If either is zero...
if(c=this.d,m=e.d,s=d.precision,u=d.rounding,!c[0]||!m[0]){// Return y negated if x is zero and y is non-zero.
if(m[0])e.s=-e.s;else{if(!c[0])return new d(3===u?-0:0);e=new d(this)}return l?F(e,s,u):e}// If base 1e7 exponents differ...
if(// x and y are finite, non-zero numbers with the same sign.
// Calculate base 1e7 exponents.
r=h(e.e/7),f=h(this.e/7),c=c.slice(),a=f-r){for((p=a<0)?(t=c,a=-a,o=m.length):(t=m,r=f,o=c.length),a>// Numbers with massively different exponents would result in a very high number of
// zeros needing to be prepended, but this can be avoided while still ensuring correct
// rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
(n=Math.max(Math.ceil(s/7),o)+2)&&(a=n,t.length=1),// Prepend zeros to equalise exponents.
t.reverse(),n=a;n--;)t.push(0);t.reverse();// Base 1e7 exponents equal.
}else{for((p=// Check digits to determine which is the bigger number.
(n=c.length)<(o=m.length))&&(o=n),n=0;n<o;n++)if(c[n]!=m[n]){p=c[n]<m[n];break}a=0}// Append zeros to `xd` if shorter.
// Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
for(p&&(t=c,c=m,m=t,e.s=-e.s),o=c.length,n=m.length-o;n>0;--n)c[o++]=0;// Subtract yd from xd.
for(n=m.length;n>a;){if(c[--n]<m[n]){for(i=n;i&&0===c[--i];)c[i]=1e7-1;--c[i],c[n]+=1e7}c[n]-=m[n]}// Remove trailing zeros.
for(;0===c[--o];)c.pop();// Remove leading zeros and adjust exponent accordingly.
for(;0===c[0];c.shift())--r;return(// Zero?
c[0]?(e.d=c,e.e=T(c,r),l?F(e,s,u):e):new d(3===u?-0:0))},/*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * The result depends on the modulo mode.
   *
   */D.modulo=D.mod=function(e){var t,r=this.constructor;return(// Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.
(e=new r(e),this.d&&e.s&&(!e.d||e.d[0]))?e.d&&(!this.d||this.d[0])?(// Prevent rounding of intermediate calculations.
l=!1,9==r.modulo?(// Euclidian division: q = sign(y) * floor(x / abs(y))
// result = x - q * y    where  0 <= result < abs(y)
t=M(this,e.abs(),0,3,1),t.s*=e.s):t=M(this,e,0,r.modulo,1),t=t.times(e),l=!0,this.minus(t)):F(new r(this),r.precision,r.rounding):new r(NaN))},/*
   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */D.naturalExponential=D.exp=function(){return P(this)},/*
   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */D.naturalLogarithm=D.ln=function(){return j(this)},/*
   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
   * -1.
   *
   */D.negated=D.neg=function(){var e=new this.constructor(this);return e.s=-e.s,F(e)},/*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */D.plus=D.add=function(e){var t,r,n,i,a,o,s,u,c,f,p=this.constructor;// If either is not finite...
if(e=new p(e),!this.d||!e.d)return this.s&&e.s?this.d||(e=new p(e.d||this.s===e.s?this:NaN)):e=new p(NaN),e;// If signs differ...
if(this.s!=e.s)return e.s=-e.s,this.minus(e);// If either is zero...
if(c=this.d,f=e.d,s=p.precision,u=p.rounding,!c[0]||!f[0])return f[0]||(e=new p(this)),l?F(e,s,u):e;// If base 1e7 exponents differ...
if(// x and y are finite, non-zero numbers with the same sign.
// Calculate base 1e7 exponents.
a=h(this.e/7),n=h(e.e/7),c=c.slice(),i=a-n){for(i<0?(r=c,i=-i,o=f.length):(r=f,n=a,o=c.length),i>(o=// Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
(a=Math.ceil(s/7))>o?a+1:o+1)&&(i=o,r.length=1),// Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
r.reverse();i--;)r.push(0);r.reverse()}// Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
for((o=c.length)-(i=f.length)<0&&(i=o,r=f,f=c,c=r),t=0;i;)t=(c[--i]=c[i]+f[i]+t)/1e7|0,c[i]%=1e7;// Remove trailing zeros.
// No need to check for zero, as +x + +y != 0 && -x + -y != 0
for(t&&(c.unshift(t),++n),o=c.length;0==c[--o];)c.pop();return e.d=c,e.e=T(c,n),l?F(e,s,u):e},/*
   * Return the number of significant digits of the value of this Decimal.
   *
   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
   *
   */D.precision=D.sd=function(e){var t;if(void 0!==e&&!!e!==e&&1!==e&&0!==e)throw Error(f+e);return this.d?(t=z(this.d),e&&this.e+1>t&&(t=this.e+1)):t=NaN,t},/*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
   * rounding mode `rounding`.
   *
   */D.round=function(){var e=this.constructor;return F(new e(this),this.e+1,e.rounding)},/*
   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * sin(x) = x - x^3/3! + x^5/5! - ...
   *
   * sin(0)         = 0
   * sin(-0)        = -0
   * sin(Infinity)  = NaN
   * sin(-Infinity) = NaN
   * sin(NaN)       = NaN
   *
   */D.sine=D.sin=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+7,n.rounding=1,r=/*
   * sin(x) = x - x^3/3! + x^5/5! - ...
   * |x| < pi/2
   *
   */function(e,t){var r,n=t.d.length;if(n<3)return t.isZero()?t:$(e,2,t,t);r=// Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
// i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
// and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))
// Estimate the optimum number of times to use the argument reduction.
(r=1.4*Math.sqrt(n))>16?16:0|r,t=$(e,2,t=t.times(1/H(5,r)),t);for(// Reverse argument reduction
var i,a=new e(5),o=new e(16),s=new e(20);r--;)i=t.times(t),t=t.times(a.plus(i.times(o.times(i).minus(s))));return t}(n,Z(n,r)),n.precision=e,n.rounding=t,F(i>2?r.neg():r,e,t,!0)):new n(NaN)},/*
   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   *  sqrt(-n) =  N
   *  sqrt(N)  =  N
   *  sqrt(-I) =  N
   *  sqrt(I)  =  I
   *  sqrt(0)  =  0
   *  sqrt(-0) = -0
   *
   */D.squareRoot=D.sqrt=function(){var e,t,r,n,i,a,o=this.d,s=this.e,u=this.s,c=this.constructor;// Negative/NaN/Infinity/zero?
if(1!==u||!o||!o[0])return new c(!u||u<0&&(!o||o[0])?NaN:o?this:1/0);// Newton-Raphson iteration.
for(l=!1,0==// Initial estimate.
(u=Math.sqrt(+this))||u==1/0?(((t=E(o)).length+s)%2==0&&(t+="0"),u=Math.sqrt(t),s=h((s+1)/2)-(s<0||s%2),n=new c(t=u==1/0?"5e"+s:(t=u.toExponential()).slice(0,t.indexOf("e")+1)+s)):n=new c(u.toString()),r=(s=c.precision)+3;;)// TODO? Replace with for-loop and checkRoundingDigits.
if(n=(a=n).plus(M(this,a,r+2,1)).times(.5),E(a.d).slice(0,r)===(t=E(n.d)).slice(0,r)){// The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
// 4999, i.e. approaching a rounding boundary, continue the iteration.
if("9999"!=(t=t.slice(r-3,r+1))&&(i||"4999"!=t)){// If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
// If not, then there are further digits and m will be truthy.
+t&&(+t.slice(1)||"5"!=t.charAt(0))||(// Truncate to the first rounding digit.
F(n,s+1,1),e=!n.times(n).eq(this));break}// On the first iteration only, check to see if rounding up gives the exact result as the
// nines may infinitely repeat.
if(!i&&(F(a,s+1,0),a.times(a).eq(this))){n=a;break}r+=4,i=1}return l=!0,F(n,s,c.rounding,e)},/*
   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * tan(0)         = 0
   * tan(-0)        = -0
   * tan(Infinity)  = NaN
   * tan(-Infinity) = NaN
   * tan(NaN)       = NaN
   *
   */D.tangent=D.tan=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+10,n.rounding=1,(r=r.sin()).s=1,r=M(r,new n(1).minus(r.times(r)).sqrt(),e+10,0),n.precision=e,n.rounding=t,F(2==i||4==i?r.neg():r,e,t,!0)):new n(NaN)},/*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   */D.times=D.mul=function(e){var t,r,n,i,a,o,s,u,c,f=this.constructor,p=this.d,m=(e=new f(e)).d;// If either is NaN, ±Infinity or ±0...
if(e.s*=this.s,!p||!p[0]||!m||!m[0])return new f(e.s&&(!p||p[0]||m)&&(!m||m[0]||p)?p&&m?0*e.s:e.s/0:NaN);for(r=h(this.e/7)+h(e.e/7),(u=p.length)<(c=m.length)&&(a=p,p=m,m=a,o=u,u=c,c=o),// Initialise the result array with zeros.
a=[],n=o=u+c;n--;)a.push(0);// Multiply!
for(n=c;--n>=0;){for(t=0,i=u+n;i>n;)s=a[i]+m[n]*p[i-n-1]+t,a[i--]=s%1e7|0,t=s/1e7|0;a[i]=(a[i]+t)%1e7|0}// Remove trailing zeros.
for(;!a[--o];)a.pop();return t?++r:a.shift(),e.d=a,e.e=T(a,r),l?F(e,f.precision,f.rounding):e},/*
   * Return a string representing the value of this Decimal in base 2, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */D.toBinary=function(e,t){return G(this,2,e,t)},/*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
   *
   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */D.toDecimalPlaces=D.toDP=function(e,t){var r=this,n=r.constructor;return(r=new n(r),void 0===e)?r:(A(e,0,1e9),void 0===t?t=n.rounding:A(t,0,8),F(r,e+r.e+1,t))},/*
   * Return a string representing the value of this Decimal in exponential notation rounded to
   * `dp` fixed decimal places using rounding mode `rounding`.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */D.toExponential=function(e,t){var r,n=this,i=n.constructor;return void 0===e?r=B(n,!0):(A(e,0,1e9),void 0===t?t=i.rounding:A(t,0,8),r=B(n=F(new i(n),e+1,t),!0,e+1)),n.isNeg()&&!n.isZero()?"-"+r:r},/*
   * Return a string representing the value of this Decimal in normal (fixed-point) notation to
   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
   * omitted.
   *
   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
   * (-0).toFixed(3) is '0.000'.
   * (-0.5).toFixed(0) is '-0'.
   *
   */D.toFixed=function(e,t){var r,n,i=this.constructor;// To determine whether to add the minus sign look at the value before it was rounded,
// i.e. look at `x` rather than `y`.
return void 0===e?r=B(this):(A(e,0,1e9),void 0===t?t=i.rounding:A(t,0,8),r=B(n=F(new i(this),e+this.e+1,t),!1,e+n.e+1)),this.isNeg()&&!this.isZero()?"-"+r:r},/*
   * Return an array representing the value of this Decimal as a simple fraction with an integer
   * numerator and an integer denominator.
   *
   * The denominator will be a positive non-zero value less than or equal to the specified maximum
   * denominator. If a maximum denominator is not specified, the denominator will be the lowest
   * value necessary to represent the number exactly.
   *
   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
   *
   */D.toFraction=function(e){var t,r,n,i,a,o,s,u,c,p,m,d,h=this.d,y=this.constructor;if(!h)return new y(this);if(c=r=new y(1),n=u=new y(0),o=(a=(t=new y(n)).e=z(h)-this.e-1)%7,t.d[0]=g(10,o<0?7+o:o),null==e)e=a>0?t:c;else{if(!(s=new y(e)).isInt()||s.lt(c))throw Error(f+s);e=s.gt(t)?a>0?t:c:s}for(l=!1,s=new y(E(h)),p=y.precision,y.precision=a=14*h.length;m=M(s,t,0,1,1),1!=(i=r.plus(m.times(n))).cmp(e);)r=n,n=i,i=c,c=u.plus(m.times(i)),u=i,i=t,t=s.minus(m.times(i)),s=i;return i=M(e.minus(r),n,0,1,1),u=u.plus(i.times(c)),r=r.plus(i.times(n)),u.s=c.s=this.s,// Determine which fraction is closer to x, n0/d0 or n1/d1?
d=1>M(c,n,a,1).minus(this).abs().cmp(M(u,r,a,1).minus(this).abs())?[c,n]:[u,r],y.precision=p,l=!0,d},/*
   * Return a string representing the value of this Decimal in base 16, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */D.toHexadecimal=D.toHex=function(e,t){return G(this,16,e,t)},/*
   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
   *
   * The return value will always have the same sign as this Decimal, unless either this Decimal
   * or `y` is NaN, in which case the return value will be also be NaN.
   *
   * The return value is not affected by the value of `precision`.
   *
   * y {number|string|Decimal} The magnitude to round to a multiple of.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toNearest() rounding mode not an integer: {rm}'
   * 'toNearest() rounding mode out of range: {rm}'
   *
   */D.toNearest=function(e,t){var r=this,n=r.constructor;if(r=new n(r),null==e){// If x is not finite, return x.
if(!r.d)return r;e=new n(1),t=n.rounding}else{// If x is not finite, return x if y is not NaN, else NaN.
if(e=new n(e),void 0===t?t=n.rounding:A(t,0,8),!r.d)return e.s?r:e;// If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
if(!e.d)return e.s&&(e.s=r.s),e}return e.d[0]?(l=!1,r=M(r,e,0,t,1).times(e),l=!0,F(r)):(e.s=r.s,r=e),r},/*
   * Return the value of this Decimal converted to a number primitive.
   * Zero keeps its sign.
   *
   */D.toNumber=function(){return+this},/*
   * Return a string representing the value of this Decimal in base 8, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */D.toOctal=function(e,t){return G(this,8,e,t)},/*
   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
   * to `precision` significant digits using rounding mode `rounding`.
   *
   * ECMAScript compliant.
   *
   *   pow(x, NaN)                           = NaN
   *   pow(x, ±0)                            = 1

   *   pow(NaN, non-zero)                    = NaN
   *   pow(abs(x) > 1, +Infinity)            = +Infinity
   *   pow(abs(x) > 1, -Infinity)            = +0
   *   pow(abs(x) == 1, ±Infinity)           = NaN
   *   pow(abs(x) < 1, +Infinity)            = +0
   *   pow(abs(x) < 1, -Infinity)            = +Infinity
   *   pow(+Infinity, y > 0)                 = +Infinity
   *   pow(+Infinity, y < 0)                 = +0
   *   pow(-Infinity, odd integer > 0)       = -Infinity
   *   pow(-Infinity, even integer > 0)      = +Infinity
   *   pow(-Infinity, odd integer < 0)       = -0
   *   pow(-Infinity, even integer < 0)      = +0
   *   pow(+0, y > 0)                        = +0
   *   pow(+0, y < 0)                        = +Infinity
   *   pow(-0, odd integer > 0)              = -0
   *   pow(-0, even integer > 0)             = +0
   *   pow(-0, odd integer < 0)              = -Infinity
   *   pow(-0, even integer < 0)             = +Infinity
   *   pow(finite x < 0, finite non-integer) = NaN
   *
   * For non-integer or very large exponents pow(x, y) is calculated using
   *
   *   x^y = exp(y*ln(x))
   *
   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
   * probability of an incorrectly rounded result
   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
   * i.e. 1 in 250,000,000,000,000
   *
   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
   *
   * y {number|string|Decimal} The power to which to raise this Decimal.
   *
   */D.toPower=D.pow=function(e){var t,r,n,i,a,o,s=this,u=s.constructor,c=+(e=new u(e));// Either ±Infinity, NaN or ±0?
if(!s.d||!e.d||!s.d[0]||!e.d[0])return new u(g(+s,c));if((s=new u(s)).eq(1))return s;if(n=u.precision,a=u.rounding,e.eq(1))return F(s,n,a);// If y is a small integer use the 'exponentiation by squaring' algorithm.
if(// y exponent
(t=h(e.e/7))>=e.d.length-1&&(r=c<0?-c:c)<=9007199254740991)return i=k(u,s,r,n),e.s<0?new u(1).div(i):F(i,n,a);// if x is negative
if((o=s.s)<0){// if y is not an integer
if(t<e.d.length-1)return new u(NaN);// if x.eq(-1)
if((1&e.d[t])==0&&(o=1),0==s.e&&1==s.d[0]&&1==s.d.length)return s.s=o,s}return(// Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.
// Overflow/underflow?
(t=0!=// Estimate result exponent.
// x^y = 10^e,  where e = y * log10(x)
// log10(x) = log10(x_significand) + x_exponent
// log10(x_significand) = ln(x_significand) / ln(10)
(r=g(+s,c))&&isFinite(r)?new u(r+"").e:h(c*(Math.log("0."+E(s.d))/Math.LN10+s.e+1)))>u.maxE+1||t<u.minE-1?new u(t>0?o/0:0):(l=!1,u.rounding=s.s=1,// Estimate the extra guard digits needed to ensure five correct rounding digits from
// naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
// new Decimal(2.32456).pow('2087987436534566.46411')
// should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
r=Math.min(12,(t+"").length),// r = x^y = exp(y*ln(x))
(i=P(e.times(j(s,n+r)),n)).d&&S(// Truncate to the required precision plus five rounding digits.
(i=F(i,n+5,1)).d,n,a)&&(t=n+10,+E(// Truncate to the increased precision plus five rounding digits.
(i=F(P(e.times(j(s,t+r)),t),t+5,1)).d).slice(n+1,n+15)+1==1e14&&(i=F(i,n+1,0))),i.s=o,l=!0,u.rounding=a,F(i,n,a)))},/*
   * Return a string representing the value of this Decimal rounded to `sd` significant digits
   * using rounding mode `rounding`.
   *
   * Return exponential notation if `sd` is less than the number of digits necessary to represent
   * the integer part of the value in normal notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */D.toPrecision=function(e,t){var r,n=this,i=n.constructor;return void 0===e?r=B(n,n.e<=i.toExpNeg||n.e>=i.toExpPos):(A(e,1,1e9),void 0===t?t=i.rounding:A(t,0,8),r=B(n=F(new i(n),e,t),e<=n.e||n.e<=i.toExpNeg,e)),n.isNeg()&&!n.isZero()?"-"+r:r},/*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
   * omitted.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toSD() digits out of range: {sd}'
   * 'toSD() digits not an integer: {sd}'
   * 'toSD() rounding mode not an integer: {rm}'
   * 'toSD() rounding mode out of range: {rm}'
   *
   */D.toSignificantDigits=D.toSD=function(e,t){var r=this.constructor;return void 0===e?(e=r.precision,t=r.rounding):(A(e,1,1e9),void 0===t?t=r.rounding:A(t,0,8)),F(new r(this),e,t)},/*
   * Return a string representing the value of this Decimal.
   *
   * Return exponential notation if this Decimal has a positive exponent equal to or greater than
   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
   *
   */D.toString=function(){var e=this.constructor,t=B(this,this.e<=e.toExpNeg||this.e>=e.toExpPos);return this.isNeg()&&!this.isZero()?"-"+t:t},/*
   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
   *
   */D.truncated=D.trunc=function(){return F(new this.constructor(this),this.e+1,1)},/*
   * Return a string representing the value of this Decimal.
   * Unlike `toString`, negative zero will include the minus sign.
   *
   */D.valueOf=D.toJSON=function(){var e=this.constructor,t=B(this,this.e<=e.toExpNeg||this.e>=e.toExpPos);return this.isNeg()?"-"+t:t};/*
   * Perform division in the specified base.
   */var M=function(){// Assumes non-zero x and k, and hence non-zero result.
function e(e,t,r){var n,i=0,a=e.length;for(e=e.slice();a--;)n=e[a]*t+i,e[a]=n%r|0,i=n/r|0;return i&&e.unshift(i),e}function t(e,t,r,n){var i,a;if(r!=n)a=r>n?1:-1;else for(i=a=0;i<r;i++)if(e[i]!=t[i]){a=e[i]>t[i]?1:-1;break}return a}function n(e,t,r,n){// Subtract b from a.
for(var i=0;r--;)e[r]-=i,i=e[r]<t[r]?1:0,e[r]=i*n+e[r]-t[r];// Remove leading zeros.
for(;!e[0]&&e.length>1;)e.shift()}return function(i,a,o,s,u,l){var c,f,p,m,d,g,y,v,x,b,N,w,D,E,A,S,C,M,B,T,O=i.constructor,_=i.s==a.s?1:-1,z=i.d,q=a.d;// Either NaN, Infinity or 0?
if(!z||!z[0]||!q||!q[0])return new O(i.s&&a.s&&(z?!q||z[0]!=q[0]:q)?z&&0==z[0]||!q?0*_:_/0:NaN);// Result exponent may be one less than e.
// The digit array of a Decimal from toStringBinary may have trailing zeros.
for(l?(d=1,f=i.e-a.e):(l=1e7,d=7,f=h(i.e/d)-h(a.e/d)),B=q.length,C=z.length,b=(x=new O(_)).d=[],p=0;q[p]==(z[p]||0);p++);if(q[p]>(z[p]||0)&&f--,null==o?(E=o=O.precision,s=O.rounding):E=u?o+(i.e-a.e)+1:o,E<0)b.push(1),g=!0;else{// divisor < 1e7
if(// Convert precision in number of base 10 digits to base 1e7 digits.
E=E/d+2|0,p=0,1==B){// k is the carry.
for(m=0,q=q[0],E++;(p<C||m)&&E--;p++)A=m*l+(z[p]||0),b[p]=A/q|0,m=A%q|0;g=m||p<C;// divisor >= 1e7
}else{// Add zeros to make remainder as long as divisor.
for(// Normalise xd and yd so highest order digit of yd is >= base/2
(m=l/(q[0]+1)|0)>1&&(q=e(q,m,l),z=e(z,m,l),B=q.length,C=z.length),S=B,w=(N=z.slice(0,B)).length;w<B;)N[w++]=0;(T=q.slice()).unshift(0),M=q[0],q[1]>=l/2&&++M;do m=0,// Compare divisor and remainder.
(c=t(q,N,B,w))<0?(// Calculate trial digit, k.
D=N[0],B!=w&&(D=D*l+(N[1]||0)),// k will be how many times the divisor goes into the current remainder.
(m=D/M|0)>1?(m>=l&&(m=l-1),v=// product = divisor * trial digit.
(y=e(q,m,l)).length,w=N.length,1==// Compare product and remainder.
(c=t(y,N,v,w))&&(m--,// Subtract divisor from product.
n(y,B<v?T:q,v,l))):(0==m&&(c=m=1),y=q.slice()),(v=y.length)<w&&y.unshift(0),// Subtract product from remainder.
n(N,y,w,l),-1==c&&(w=N.length,// Compare divisor and new remainder.
(c=t(q,N,B,w))<1&&(m++,// Subtract divisor from remainder.
n(N,B<w?T:q,w,l))),w=N.length):0===c&&(m++,N=[0]),// Add the next digit, k, to the result array.
b[p++]=m,c&&N[0]?N[w++]=z[S]||0:(N=[z[S]],w=1);while((S++<C||void 0!==N[0])&&E--)g=void 0!==N[0]}b[0]||b.shift()}// logBase is 1 when divide is being used for base conversion.
if(1==d)x.e=f,r=g;else{// To calculate q.e, first get the number of digits of qd[0].
for(p=1,m=b[0];m>=10;m/=10)p++;x.e=p+f*d-1,F(x,u?o+x.e+1:o,s,g)}return x}}();/*
   * Round `x` to `sd` significant digits using rounding mode `rm`.
   * Check for over/under-flow.
   */function F(e,t,r,n){var i,a,o,s,u,c,f,p,m,d=e.constructor;// Don't round if sd is null or undefined.
e:if(null!=t){// Infinity/NaN.
if(!(p=e.d))return e;// rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
// w: the word of xd containing rd, a base 1e7 number.
// xdi: the index of w within xd.
// digits: the number of digits of w.
// i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
// they had leading zeros)
// j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).
// Get the length of the first word of the digits array xd.
for(i=1,s=p[0];s>=10;s/=10)i++;// Is the rounding digit in the first word of xd?
if((a=t-i)<0)a+=7,o=t,// Get the rounding digit at index j of w.
u=(f=p[m=0])/g(10,i-o-1)%10|0;else if((m=Math.ceil((a+1)/7))>=(s=p.length)){if(n){// Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
for(;s++<=m;)p.push(0);f=u=0,i=1,a%=7,o=a-7+1}else break e}else{// Get the number of digits of w.
for(i=1,f=s=p[m];s>=10;s/=10)i++;// Get the index of rd within w.
a%=7,// Get the rounding digit at index j of w.
u=// Get the index of rd within w, adjusted for leading zeros.
// The number of leading zeros of w is given by LOG_BASE - digits.
(o=a-7+i)<0?0:f/g(10,i-o-1)%10|0}if(// Are there any non-zero digits after the rounding digit?
n=n||t<0||void 0!==p[m+1]||(o<0?f:f%g(10,i-o-1)),// The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
// of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
// will give 714.
c=r<4?(u||n)&&(0==r||r==(e.s<0?3:2)):u>5||5==u&&(4==r||n||6==r&&(a>0?o>0?f/g(10,i-o):0:p[m-1])%10&1||r==(e.s<0?8:7)),t<1||!p[0])return p.length=0,c?(// Convert sd to decimal places.
t-=e.e+1,// 1, 0.1, 0.01, 0.001, 0.0001 etc.
p[0]=g(10,(7-t%7)%7),e.e=-t||0):p[0]=e.e=0,e;if(0==a?(p.length=m,s=1,m--):(p.length=m+1,s=g(10,7-a),// E.g. 56700 becomes 56000 if 7 is the rounding digit.
// j > 0 means i > number of leading zeros of w.
p[m]=o>0?(f/g(10,i-o)%g(10,o)|0)*s:0),c)for(;;)if(0==m){// i will be the length of xd[0] before k is added.
for(a=1,o=p[0];o>=10;o/=10)a++;for(o=p[0]+=s,s=1;o>=10;o/=10)s++;a!=s&&(e.e++,1e7==p[0]&&(p[0]=1));break}else{if(p[m]+=s,1e7!=p[m])break;p[m--]=0,s=1}// Remove trailing zeros.
for(a=p.length;0===p[--a];)p.pop()}return l&&(e.e>d.maxE?(// Infinity.
e.d=null,e.e=NaN):e.e<d.minE&&(// Zero.
e.e=0,e.d=[0])),e}function B(e,t,r){if(!e.isFinite())return U(e);var n,i=e.e,a=E(e.d),o=a.length;return t?(r&&(n=r-o)>0?a=a.charAt(0)+"."+a.slice(1)+q(n):o>1&&(a=a.charAt(0)+"."+a.slice(1)),a=a+(e.e<0?"e":"e+")+e.e):i<0?(a="0."+q(-i-1)+a,r&&(n=r-o)>0&&(a+=q(n))):i>=o?(a+=q(i+1-o),r&&(n=r-i-1)>0&&(a=a+"."+q(n))):((n=i+1)<o&&(a=a.slice(0,n)+"."+a.slice(n)),r&&(n=r-o)>0&&(i+1===o&&(a+="."),a+=q(n))),a}// Calculate the base 10 exponent from the base 1e7 exponent.
function T(e,t){var r=e[0];// Add the number of digits of the first word of the digits array.
for(t*=7;r>=10;r/=10)t++;return t}function O(e,t,r){if(t>N)throw(// Reset global state in case the exception is caught.
l=!0,r&&(e.precision=r),Error(p));return F(new e(o),t,1,!0)}function _(e,t,r){if(t>w)throw Error(p);return F(new e(s),t,r,!0)}function z(e){var t=e.length-1,r=7*t+1;// If non-zero...
if(t=e[t]){// Subtract the number of trailing zeros of the last word.
for(;t%10==0;t/=10)r--;// Add the number of digits of the first word.
for(t=e[0];t>=10;t/=10)r++}return r}function q(e){for(var t="";e--;)t+="0";return t}/*
   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
   * integer of type number.
   *
   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
   *
   */function k(e,t,r,n){var i,a=new e(1),// Maximum digits array length; leaves [28, 34] guard digits.
o=Math.ceil(n/7+4);for(l=!1;;){if(r%2&&V((a=a.times(t)).d,o)&&(i=!0),0===(r=h(r/2))){// To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
r=a.d.length-1,i&&0===a.d[r]&&++a.d[r];break}V((t=t.times(t)).d,o)}return l=!0,a}function I(e){return 1&e.d[e.d.length-1]}/*
   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
   */function R(e,t,r){for(var n,i=new e(t[0]),a=0;++a<t.length;)if((n=new e(t[a])).s)i[r](n)&&(i=n);else{i=n;break}return i}/*
   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
   * digits.
   *
   * Taylor/Maclaurin series.
   *
   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
   *
   * Argument reduction:
   *   Repeat x = x / 32, k += 5, until |x| < 0.1
   *   exp(x) = exp(x / 2^k)^(2^k)
   *
   * Previously, the argument was initially reduced by
   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
   * found to be slower than just dividing repeatedly by 32 as above.
   *
   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
   *
   *  exp(Infinity)  = Infinity
   *  exp(-Infinity) = 0
   *  exp(NaN)       = NaN
   *  exp(±0)        = 1
   *
   *  exp(x) is non-terminating for any finite, non-zero x.
   *
   *  The result will always be correctly rounded.
   *
   */function P(e,t){var r,n,i,a,o,s,u,c=0,f=0,p=0,m=e.constructor,d=m.rounding,h=m.precision;// 0/NaN/Infinity?
if(!e.d||!e.d[0]||e.e>17)return new m(e.d?e.d[0]?e.s<0?0:1/0:1:e.s?e.s<0?0:e:0/0);// while abs(x) >= 0.1
for(null==t?(l=!1,u=h):u=t,s=new m(.03125);e.e>-2;)// x = x / 2^5
e=e.times(s),p+=5;for(u+=// Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
// necessary to ensure the first 4 rounding digits are correct.
n=Math.log(g(2,p))/Math.LN10*2+5|0,r=a=o=new m(1),m.precision=u;;){if(a=F(a.times(e),u,1),r=r.times(++f),E((s=o.plus(M(a,r,u,1))).d).slice(0,u)===E(o.d).slice(0,u)){for(i=p;i--;)o=F(o.times(o),u,1);// Check to see if the first 4 rounding digits are [49]999.
// If so, repeat the summation with a higher precision, otherwise
// e.g. with precision: 18, rounding: 1
// exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
// `wpr - guard` is the index of first rounding digit.
if(null!=t)return m.precision=h,o;if(!(c<3&&S(o.d,u-n,d,c)))return F(o,m.precision=h,d,l=!0);m.precision=u+=10,r=a=s=new m(1),f=0,c++}o=s}}/*
   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
   * digits.
   *
   *  ln(-n)        = NaN
   *  ln(0)         = -Infinity
   *  ln(-0)        = -Infinity
   *  ln(1)         = 0
   *  ln(Infinity)  = Infinity
   *  ln(-Infinity) = NaN
   *  ln(NaN)       = NaN
   *
   *  ln(n) (n != 1) is non-terminating.
   *
   */function j(e,t){var r,n,i,a,o,s,u,c,f,p,m,d=1,h=e,g=h.d,y=h.constructor,v=y.rounding,x=y.precision;// Is x negative or Infinity, NaN, 0 or 1?
if(h.s<0||!g||!g[0]||!h.e&&1==g[0]&&1==g.length)return new y(g&&!g[0]?-1/0:1!=h.s?NaN:g?0:h);if(null==t?(l=!1,f=x):f=t,y.precision=f+=10,n=(r=E(g)).charAt(0),!(15e14>Math.abs(a=h.e)))return(// The argument reduction method above may result in overflow if the argument y is a massive
// number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
// function using ln(x*10^e) = ln(x) + e*ln(10).
c=O(y,f+2,x).times(a+""),h=j(new y(n+"."+r.slice(1)),f-10).plus(c),y.precision=x,null==t?F(h,x,v,l=!0):h);// Argument reduction.
// The series converges faster the closer the argument is to 1, so using
// ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
// multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
// 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
// later be divided by this number, then separate out the power of 10 using
// ln(a*10^b) = ln(a) + b*ln(10).
// max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
//while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
// max n is 6 (gives 0.7 - 1.3)
for(;n<7&&1!=n||1==n&&r.charAt(1)>3;)n=(r=E((h=h.times(e)).d)).charAt(0),d++;for(a=h.e,n>1?(h=new y("0."+r),a++):h=new y(n+"."+r.slice(1)),// x1 is x reduced to a value near 1.
p=h,// Taylor series.
// ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
// where x = (y - 1)/(y + 1)    (|x| < 1)
u=o=h=M(h.minus(1),h.plus(1),f,1),m=F(h.times(h),f,1),i=3;;){if(o=F(o.times(m),f,1),E((c=u.plus(M(o,new y(i),f,1))).d).slice(0,f)===E(u.d).slice(0,f)){// Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
// been repeated previously) and the first 4 rounding digits 9999?
// If so, restart the summation with a higher precision, otherwise
// e.g. with precision: 12, rounding: 1
// ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
// `wpr - guard` is the index of first rounding digit.
if(u=u.times(2),0!==a&&(u=u.plus(O(y,f+2,x).times(a+""))),u=M(u,new y(d),f,1),null!=t)return y.precision=x,u;if(!S(u.d,f-10,v,s))return F(u,y.precision=x,v,l=!0);y.precision=f+=10,c=o=h=M(p.minus(1),p.plus(1),f,1),m=F(h.times(h),f,1),i=s=1}u=c,i+=2}}// ±Infinity, NaN.
function U(e){// Unsigned.
return String(e.s*e.s/0)}/*
   * Parse the value of a new Decimal `x` from string `str`.
   */function L(e,t){var r,n,i;// Determine leading zeros.
for((r=t.indexOf("."))>-1&&(t=t.replace(".","")),(n=t.search(/e/i))>0?(r<0&&(r=n),r+=+t.slice(n+1),t=t.substring(0,n)):r<0&&(r=t.length),n=0;48===t.charCodeAt(n);n++);// Determine trailing zeros.
for(i=t.length;48===t.charCodeAt(i-1);--i);if(t=t.slice(n,i)){if(i-=n,e.e=r=r-n-1,e.d=[],// Transform base
// e is the base 10 exponent.
// i is where to slice str to get the first word of the digits array.
n=(r+1)%7,r<0&&(n+=7),n<i){for(n&&e.d.push(+t.slice(0,n)),i-=7;n<i;)e.d.push(+t.slice(n,n+=7));n=7-(t=t.slice(n)).length}else n-=i;for(;n--;)t+="0";e.d.push(+t),l&&(e.e>e.constructor.maxE?(// Infinity.
e.d=null,e.e=NaN):e.e<e.constructor.minE&&(// Zero.
e.e=0,e.d=[0]))}else // Zero.
e.e=0,e.d=[0];return e}// Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
function $(e,t,r,n,i){var a,o,s,u,c=e.precision,f=Math.ceil(c/7);for(l=!1,u=r.times(r),s=new e(n);;){if(o=M(s.times(u),new e(t++*t++),c,1),s=i?n.plus(o):n.minus(o),n=M(o.times(u),new e(t++*t++),c,1),void 0!==(o=s.plus(n)).d[f]){for(a=f;o.d[a]===s.d[a]&&a--;);if(-1==a)break}a=s,s=n,n=o,o=a}return l=!0,o.d.length=f+1,o}// Exponent e must be positive and non-zero.
function H(e,t){for(var r=e;--t;)r*=e;return r}// Return the absolute value of `x` reduced to less than or equal to half pi.
function Z(e,t){var r,n=t.s<0,a=_(e,e.precision,1),o=a.times(.5);if((t=t.abs()).lte(o))return i=n?4:1,t;if((r=t.divToInt(a)).isZero())i=n?3:2;else{// 0 <= x < pi
if((t=t.minus(r.times(a))).lte(o))return i=I(r)?n?2:3:n?4:1,t;i=I(r)?n?1:4:n?3:2}return t.minus(a).abs()}/*
   * Return the value of Decimal `x` as a string in base `baseOut`.
   *
   * If the optional `sd` argument is present include a binary exponent suffix.
   */function G(e,t,n,i){var o,s,u,l,c,f,p,m,d,h=e.constructor,g=void 0!==n;if(g?(A(n,1,1e9),void 0===i?i=h.rounding:A(i,0,8)):(n=h.precision,i=h.rounding),e.isFinite()){// Remove trailing zeros.
for(u=(p=B(e)).indexOf("."),g?(o=2,16==t?n=4*n-3:8==t&&(n=3*n-2)):o=t,u>=0&&(p=p.replace(".",""),(d=new h(1)).e=p.length-u,d.d=C(B(d),10,o),d.e=d.d.length),s=c=(m=C(p,10,o)).length;0==m[--c];)m.pop();if(m[0]){if(u<0?s--:((e=new h(e)).d=m,e.e=s,m=(e=M(e,d,n,i,0,o)).d,s=e.e,f=r),// The rounding digit, i.e. the digit after the digit that may be rounded up.
u=m[n],l=o/2,f=f||void 0!==m[n+1],f=i<4?(void 0!==u||f)&&(0===i||i===(e.s<0?3:2)):u>l||u===l&&(4===i||f||6===i&&1&m[n-1]||i===(e.s<0?8:7)),m.length=n,f)for(;++m[--n]>o-1;)m[n]=0,n||(++s,m.unshift(1));// Determine trailing zeros.
for(c=m.length;!m[c-1];--c);// E.g. [4, 11, 15] becomes 4bf.
for(u=0,p="";u<c;u++)p+=a.charAt(m[u]);// Add binary exponent suffix?
if(g){if(c>1){if(16==t||8==t){for(u=16==t?4:3,--c;c%u;c++)p+="0";for(c=(m=C(p,o,t)).length;!m[c-1];--c);// xd[0] will always be be 1
for(u=1,p="1.";u<c;u++)p+=a.charAt(m[u])}else p=p.charAt(0)+"."+p.slice(1)}p=p+(s<0?"p":"p+")+s}else if(s<0){for(;++s;)p="0"+p;p="0."+p}else if(++s>c)for(s-=c;s--;)p+="0";else s<c&&(p=p.slice(0,s)+"."+p.slice(s))}else p=g?"0p+0":"0";p=(16==t?"0x":2==t?"0b":8==t?"0o":"")+p}else p=U(e);return e.s<0?"-"+p:p}// Does not strip trailing zeros.
function V(e,t){if(e.length>t)return e.length=t,!0}// Decimal methods
/*
   *  abs
   *  acos
   *  acosh
   *  add
   *  asin
   *  asinh
   *  atan
   *  atanh
   *  atan2
   *  cbrt
   *  ceil
   *  clamp
   *  clone
   *  config
   *  cos
   *  cosh
   *  div
   *  exp
   *  floor
   *  hypot
   *  ln
   *  log
   *  log2
   *  log10
   *  max
   *  min
   *  mod
   *  mul
   *  pow
   *  random
   *  round
   *  set
   *  sign
   *  sin
   *  sinh
   *  sqrt
   *  sub
   *  sum
   *  tan
   *  tanh
   *  trunc
   *//*
   * Return a new Decimal whose value is the absolute value of `x`.
   *
   * x {number|string|Decimal}
   *
   */function W(e){return new this(e).abs()}/*
   * Return a new Decimal whose value is the arccosine in radians of `x`.
   *
   * x {number|string|Decimal}
   *
   */function Y(e){return new this(e).acos()}/*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */function J(e){return new this(e).acosh()}/*
   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */function X(e,t){return new this(e).plus(t)}/*
   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */function Q(e){return new this(e).asin()}/*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */function K(e){return new this(e).asinh()}/*
   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */function ee(e){return new this(e).atan()}/*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */function et(e){return new this(e).atanh()}/*
   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi, pi]
   *
   * y {number|string|Decimal} The y-coordinate.
   * x {number|string|Decimal} The x-coordinate.
   *
   * atan2(±0, -0)               = ±pi
   * atan2(±0, +0)               = ±0
   * atan2(±0, -x)               = ±pi for x > 0
   * atan2(±0, x)                = ±0 for x > 0
   * atan2(-y, ±0)               = -pi/2 for y > 0
   * atan2(y, ±0)                = pi/2 for y > 0
   * atan2(±y, -Infinity)        = ±pi for finite y > 0
   * atan2(±y, +Infinity)        = ±0 for finite y > 0
   * atan2(±Infinity, x)         = ±pi/2 for finite x
   * atan2(±Infinity, -Infinity) = ±3*pi/4
   * atan2(±Infinity, +Infinity) = ±pi/4
   * atan2(NaN, x) = NaN
   * atan2(y, NaN) = NaN
   *
   */function er(e,t){e=new this(e),t=new this(t);var r,n=this.precision,i=this.rounding,a=n+4;return e.s&&t.s?e.d||t.d?!t.d||e.isZero()?(r=t.s<0?_(this,n,i):new this(0)).s=e.s:!e.d||t.isZero()?(r=_(this,a,1).times(.5)).s=e.s:t.s<0?(this.precision=a,this.rounding=1,r=this.atan(M(e,t,a,1)),t=_(this,a,1),this.precision=n,this.rounding=i,r=e.s<0?r.minus(t):r.plus(t)):r=this.atan(M(e,t,a,1)):(r=_(this,a,1).times(t.s>0?.25:.75)).s=e.s:r=new this(NaN),r}/*
   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */function en(e){return new this(e).cbrt()}/*
   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
   *
   * x {number|string|Decimal}
   *
   */function ei(e){return F(e=new this(e),e.e+1,2)}/*
   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.
   *
   * x {number|string|Decimal}
   * min {number|string|Decimal}
   * max {number|string|Decimal}
   *
   */function ea(e,t,r){return new this(e).clamp(t,r)}/*
   * Configure global settings for a Decimal constructor.
   *
   * `obj` is an object with one or more of the following properties,
   *
   *   precision  {number}
   *   rounding   {number}
   *   toExpNeg   {number}
   *   toExpPos   {number}
   *   maxE       {number}
   *   minE       {number}
   *   modulo     {number}
   *   crypto     {boolean|number}
   *   defaults   {true}
   *
   * E.g. Decimal.config({ precision: 20, rounding: 4 })
   *
   */function eo(e){if(!e||"object"!=typeof e)throw Error(c+"Object expected");var t,r,n,i=!0===e.defaults,a=["precision",1,1e9,"rounding",0,8,"toExpNeg",-9e15,0,"toExpPos",0,9e15,"maxE",0,9e15,"minE",-9e15,0,"modulo",0,9];for(t=0;t<a.length;t+=3)if(r=a[t],i&&(this[r]=u[r]),void 0!==(n=e[r])){if(h(n)===n&&n>=a[t+1]&&n<=a[t+2])this[r]=n;else throw Error(f+r+": "+n)}if(r="crypto",i&&(this[r]=u[r]),void 0!==(n=e[r])){if(!0===n||!1===n||0===n||1===n){if(n){if("undefined"!=typeof crypto&&crypto&&(crypto.getRandomValues||crypto.randomBytes))this[r]=!0;else throw Error(m)}else this[r]=!1}else throw Error(f+r+": "+n)}return this}/*
   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */function es(e){return new this(e).cos()}/*
   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */function eu(e){return new this(e).cosh()}/*
   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */function el(e,t){return new this(e).div(t)}/*
   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The power to which to raise the base of the natural log.
   *
   */function ec(e){return new this(e).exp()}/*
   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
   *
   * x {number|string|Decimal}
   *
   */function ef(e){return F(e=new this(e),e.e+1,3)}/*
   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
   *
   * arguments {number|string|Decimal}
   *
   */function ep(){var e,t,r=new this(0);for(e=0,l=!1;e<arguments.length;)if(t=new this(arguments[e++]),t.d)r.d&&(r=r.plus(t.times(t)));else{if(t.s)return l=!0,new this(1/0);r=t}return l=!0,r.sqrt()}/*
   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
   * otherwise return false.
   *
   */function em(e){return e instanceof t||e&&e.toStringTag===d||!1}/*
   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */function ed(e){return new this(e).ln()}/*
   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * log[y](x)
   *
   * x {number|string|Decimal} The argument of the logarithm.
   * y {number|string|Decimal} The base of the logarithm.
   *
   */function eh(e,t){return new this(e).log(t)}/*
   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */function eg(e){return new this(e).log(2)}/*
   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */function ey(e){return new this(e).log(10)}/*
   * Return a new Decimal whose value is the maximum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */function ev(){return R(this,arguments,"lt")}/*
   * Return a new Decimal whose value is the minimum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */function ex(){return R(this,arguments,"gt")}/*
   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */function eb(e,t){return new this(e).mod(t)}/*
   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */function eN(e,t){return new this(e).mul(t)}/*
   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The base.
   * y {number|string|Decimal} The exponent.
   *
   */function ew(e,t){return new this(e).pow(t)}/*
   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
   * are produced).
   *
   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
   *
   */function eD(e){var t,r,n,i,a=0,o=new this(1),s=[];if(void 0===e?e=this.precision:A(e,1,1e9),n=Math.ceil(e/7),this.crypto){if(crypto.getRandomValues)for(t=crypto.getRandomValues(new Uint32Array(n));a<n;)// 0 <= n < 4294967296
// Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
(i=t[a])>=429e7?t[a]=crypto.getRandomValues(new Uint32Array(1))[0]:// 0 <= (n % 1e7) <= 9999999
s[a++]=i%1e7;else if(crypto.randomBytes){for(// buffer
t=crypto.randomBytes(n*=4);a<n;)// Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
// 0 <= n < 2147483648
(i=t[a]+(t[a+1]<<8)+(t[a+2]<<16)+((127&t[a+3])<<24))>=214e7?crypto.randomBytes(4).copy(t,a):(// 0 <= n <= 2139999999
// 0 <= (n % 1e7) <= 9999999
s.push(i%1e7),a+=4);a=n/4}else throw Error(m)}else for(;a<n;)s[a++]=1e7*Math.random()|0;// Remove trailing words which are zero.
for(n=s[--a],e%=7,n&&e&&(i=g(10,7-e),s[a]=(n/i|0)*i);0===s[a];a--)s.pop();// Zero?
if(a<0)r=0,s=[0];else{// Remove leading words which are zero and adjust exponent accordingly.
for(r=-1;0===s[0];r-=7)s.shift();// Count the digits of the first word of rd to determine leading zeros.
for(n=1,i=s[0];i>=10;i/=10)n++;n<7&&(r-=7-n)}return o.e=r,o.d=s,o}/*
   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
   *
   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
   *
   * x {number|string|Decimal}
   *
   */function eE(e){return F(e=new this(e),e.e+1,this.rounding)}/*
   * Return
   *   1    if x > 0,
   *  -1    if x < 0,
   *   0    if x is 0,
   *  -0    if x is -0,
   *   NaN  otherwise
   *
   * x {number|string|Decimal}
   *
   */function eA(e){return(e=new this(e)).d?e.d[0]?e.s:0*e.s:e.s||NaN}/*
   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */function eS(e){return new this(e).sin()}/*
   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */function eC(e){return new this(e).sinh()}/*
   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */function eM(e){return new this(e).sqrt()}/*
   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */function eF(e,t){return new this(e).sub(t)}/*
   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * Only the result is rounded, not the intermediate calculations.
   *
   * arguments {number|string|Decimal}
   *
   */function eB(){var e=0,t=arguments,r=new this(t[e]);for(l=!1;r.s&&++e<t.length;)r=r.plus(t[e]);return l=!0,F(r,this.precision,this.rounding)}/*
   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */function eT(e){return new this(e).tan()}/*
   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */function eO(e){return new this(e).tanh()}/*
   * Return a new Decimal whose value is `x` truncated to an integer.
   *
   * x {number|string|Decimal}
   *
   */function e_(e){return F(e=new this(e),e.e+1,1)}// Create and configure initial Decimal constructor.
(t=/*
   * Create and return a Decimal constructor with the same configuration properties as this Decimal
   * constructor.
   *
   */function e(r){var n,i,a;/*
     * The Decimal constructor and exported function.
     * Return a new Decimal instance.
     *
     * v {number|string|Decimal} A numeric value.
     *
     */function o(e){var r,n,i;// Decimal called without new.
if(!(this instanceof o))return new o(e);// Duplicate.
if(// Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
// which points to Object.
this.constructor=o,em(e)){this.s=e.s,l?!e.d||e.e>o.maxE?(// Infinity.
this.e=NaN,this.d=null):e.e<o.minE?(// Zero.
this.e=0,this.d=[0]):(this.e=e.e,this.d=e.d.slice()):(this.e=e.e,this.d=e.d?e.d.slice():e.d);return}if("number"==(i=typeof e)){if(0===e){this.s=1/e<0?-1:1,this.e=0,this.d=[0];return}// Fast path for small integers.
if(e<0?(e=-e,this.s=-1):this.s=1,e===~~e&&e<1e7){for(r=0,n=e;n>=10;n/=10)r++;l?r>o.maxE?(this.e=NaN,this.d=null):r<o.minE?(this.e=0,this.d=[0]):(this.e=r,this.d=[e]):(this.e=r,this.d=[e]);return;// Infinity, NaN.
}if(0*e!=0){e||(this.s=NaN),this.e=NaN,this.d=null;return}return L(this,e.toString())}if("string"!==i)throw Error(f+e);return 45===(n=e.charCodeAt(0))?(e=e.slice(1),this.s=-1):(43===n&&(e=e.slice(1)),this.s=1),b.test(e)?L(this,e):/*
   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
   */function(e,r){var n,i,a,o,s,u,c,p,m;if(r.indexOf("_")>-1){if(r=r.replace(/(\d)_(?=\d)/g,"$1"),b.test(r))return L(e,r)}else if("Infinity"===r||"NaN"===r)return+r||(e.s=NaN),e.e=NaN,e.d=null,e;if(v.test(r))n=16,r=r.toLowerCase();else if(y.test(r))n=2;else if(x.test(r))n=8;else throw Error(f+r);// Remove trailing zeros.
for(// Is there a binary exponent part?
(o=r.search(/p/i))>0?(c=+r.slice(o+1),r=r.substring(2,o)):r=r.slice(2),s=// Convert `str` as an integer then divide the result by `base` raised to a power such that the
// fraction part will be restored.
(o=r.indexOf("."))>=0,i=e.constructor,s&&(o=(u=(r=r.replace(".","")).length)-o,// log[10](16) = 1.2041... , log[10](88) = 1.9444....
a=k(i,new i(n),o,2*o)),o=m=(p=C(r,n,1e7)).length-1;0===p[o];--o)p.pop();return o<0?new i(0*e.s):(e.e=T(p,m),e.d=p,l=!1,s&&(e=M(e,a,4*u)),c&&(e=e.times(54>Math.abs(c)?g(2,c):t.pow(2,c))),l=!0,e)}(this,e)}if(o.prototype=D,o.ROUND_UP=0,o.ROUND_DOWN=1,o.ROUND_CEIL=2,o.ROUND_FLOOR=3,o.ROUND_HALF_UP=4,o.ROUND_HALF_DOWN=5,o.ROUND_HALF_EVEN=6,o.ROUND_HALF_CEIL=7,o.ROUND_HALF_FLOOR=8,o.EUCLID=9,o.config=o.set=eo,o.clone=e,o.isDecimal=em,o.abs=W,o.acos=Y,o.acosh=J,o.add=X,o.asin=Q,o.asinh=K,o.atan=ee,o.atanh=et,o.atan2=er,o.cbrt=en,o.ceil=ei,o.clamp=ea,o.cos=es,o.cosh=eu,o.div=el,o.exp=ec,o.floor=ef,o.hypot=ep,o.ln=ed,o.log=eh,o.log10=ey,o.log2=eg,o.max=ev,o.min=ex,o.mod=eb,o.mul=eN,o.pow=ew,o.random=eD,o.round=eE,o.sign=eA,o.sin=eS,o.sinh=eC,o.sqrt=eM,o.sub=eF,o.sum=eB,o.tan=eT,o.tanh=eO,o.trunc=e_,void 0===r&&(r={}),r&&!0!==r.defaults)for(n=0,a=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"];n<a.length;)r.hasOwnProperty(i=a[n++])||(r[i]=this[i]);return o.config(r),o}(u)).prototype.constructor=t,t.default=t.Decimal=t,// Create the internal constants from their string values.
o=new t(o),s=new t(s),"function"==typeof define&&define.amd?define(function(){return t}):a3?("function"==typeof Symbol&&"symbol"==typeof Symbol.iterator&&(D[Symbol.for("nodejs.util.inspect.custom")]=D.toString,D[Symbol.toStringTag]="Decimal"),a3=t):(e||(e="undefined"!=typeof self&&self&&self.self==self?self:window),n=e.Decimal,t.noConflict=function(){return e.Decimal=n,t},e.Decimal=t)}(a3);var a4=ta("BigNumber",["?on","config"],t=>{var{on:r,config:n}=t,i=/*@__PURE__*/e(a3).clone({precision:n.precision,modulo:/*@__PURE__*/e(a3).EUCLID});return i.prototype=Object.create(i.prototype),/**
   * Attach type information
   */i.prototype.type="BigNumber",i.prototype.isBigNumber=!0,/**
   * Get a JSON representation of a BigNumber containing
   * type information
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "BigNumber", "value": "0.2"}`
   */i.prototype.toJSON=function(){return{mathjs:"BigNumber",value:this.toString()}},/**
   * Instantiate a BigNumber from a JSON object
   * @param {Object} json  a JSON object structured as:
   *                       `{"mathjs": "BigNumber", "value": "0.2"}`
   * @return {BigNumber}
   */i.fromJSON=function(e){return new i(e.value)},r&&r("config",function(e,t){e.precision!==t.precision&&i.config({precision:e.precision})}),i},{isClass:!0}),a5=ta("bin",["typed","format"],e=>{var{typed:t,format:r}=e;return t("bin",{"number | BigNumber":function(e){return r(e,{notation:"bin"})},"number | BigNumber, number":function(e,t){return r(e,{notation:"bin",wordSize:t})}})});/**
 * Bitwise and for Bignumbers
 *
 * Special Cases:
 *   N &  n =  N
 *   n &  0 =  0
 *   n & -1 =  n
 *   n &  n =  n
 *   I &  I =  I
 *  -I & -I = -I
 *   I & -I =  0
 *   I &  n =  n
 *   I & -n =  I
 *  -I &  n =  0
 *  -I & -n = -I
 *
 * @param {BigNumber} x
 * @param {BigNumber} y
 * @return {BigNumber} Result of `x` & `y`, is fully precise
 * @private
 */function a8(e,t){if(e.isFinite()&&!e.isInteger()||t.isFinite()&&!t.isInteger())throw Error("Integers expected in function bitAnd");var r=e.constructor;if(e.isNaN()||t.isNaN())return new r(NaN);if(e.isZero()||t.eq(-1)||e.eq(t))return e;if(t.isZero()||e.eq(-1))return t;if(!e.isFinite()||!t.isFinite()){if(!e.isFinite()&&!t.isFinite())return e.isNegative()===t.isNegative()?e:new r(0);if(!e.isFinite())return t.isNegative()?e:e.isNegative()?new r(0):t;if(!t.isFinite())return e.isNegative()?t:t.isNegative()?new r(0):e}return a9(e,t,function(e,t){return e&t})}function a6(e){if(e.isFinite()&&!e.isInteger())throw Error("Integer expected in function bitNot");var t=e.constructor,r=t.precision;t.config({precision:1e9});var n=e.plus(new t(1));return n.s=-n.s||null,t.config({precision:r}),n}function a7(e,t){if(e.isFinite()&&!e.isInteger()||t.isFinite()&&!t.isInteger())throw Error("Integers expected in function bitOr");var r=e.constructor;if(e.isNaN()||t.isNaN())return new r(NaN);var n=new r(-1);return e.isZero()||t.eq(n)||e.eq(t)?t:t.isZero()||e.eq(n)?e:e.isFinite()&&t.isFinite()?a9(e,t,function(e,t){return e|t}):!e.isFinite()&&!e.isNegative()&&t.isNegative()||e.isNegative()&&!t.isNegative()&&!t.isFinite()?n:e.isNegative()&&t.isNegative()?e.isFinite()?e:t:e.isFinite()?t:e}function a9(e,t,r){var n,i,a,o,s,u=e.constructor,l=+(e.s<0),c=+(t.s<0);if(l){n=oe(a6(e));for(var f=0;f<n.length;++f)n[f]^=1}else n=oe(e);if(c){i=oe(a6(t));for(var p=0;p<i.length;++p)i[p]^=1}else i=oe(t);n.length<=i.length?(a=n,o=i,s=l):(a=i,o=n,s=c);var m=a.length,d=o.length,h=1^r(l,c),g=new u(1^h),y=new u(1),v=new u(2),x=u.precision;for(u.config({precision:1e9});m>0;)r(a[--m],o[--d])===h&&(g=g.plus(y)),y=y.times(v);for(;d>0;)r(s,o[--d])===h&&(g=g.plus(y)),y=y.times(v);return u.config({precision:x}),0===h&&(g.s=-g.s),g}/* Extracted from decimal.js, and edited to specialize. */function oe(e){for(var t=e.d,r=t[0]+"",n=1;n<t.length;++n){for(var i=t[n]+"",a=7-i.length;a--;)i="0"+i;r+=i}for(// Convert to string
var o=r.length;"0"===r.charAt(o);)o--;var s=e.e,u=r.slice(0,o+1||1),l=u.length;if(s>0){if(++s>l)for(// Append zeros.
s-=l;s--;)u+="0";else s<l&&(u=u.slice(0,s)+"."+u.slice(s))}for(var c=[0],f=0;f<u.length;){for(var p=c.length;p--;)c[p]*=10;c[0]+=parseInt(u.charAt(f++));// convert to int
for(var m=0;m<c.length;++m)c[m]>1&&((null===c[m+1]||void 0===c[m+1])&&(c[m+1]=0),c[m+1]+=c[m]>>1,c[m]&=1)}return c.reverse()}function ot(e,t){if(e.isFinite()&&!e.isInteger()||t.isFinite()&&!t.isInteger())throw Error("Integers expected in function bitXor");var r=e.constructor;if(e.isNaN()||t.isNaN())return new r(NaN);if(e.isZero())return t;if(t.isZero())return e;if(e.eq(t))return new r(0);var n=new r(-1);return e.eq(n)?a6(t):t.eq(n)?a6(e):e.isFinite()&&t.isFinite()?a9(e,t,function(e,t){return e^t}):e.isFinite()||t.isFinite()?new r(e.isNegative()===t.isNegative()?1/0:-1/0):n}function or(e,t){if(e.isFinite()&&!e.isInteger()||t.isFinite()&&!t.isInteger())throw Error("Integers expected in function leftShift");var r=e.constructor;return e.isNaN()||t.isNaN()||t.isNegative()&&!t.isZero()?new r(NaN):e.isZero()||t.isZero()?e:e.isFinite()||t.isFinite()?t.lt(55)?e.times(Math.pow(2,t.toNumber())+""):e.times(new r(2).pow(t)):new r(NaN)}function on(e,t){if(e.isFinite()&&!e.isInteger()||t.isFinite()&&!t.isInteger())throw Error("Integers expected in function rightArithShift");var r=e.constructor;return e.isNaN()||t.isNaN()||t.isNegative()&&!t.isZero()?new r(NaN):e.isZero()||t.isZero()?e:t.isFinite()?// Math.pow(2, y) is fully precise for y < 55, and fast
t.lt(55)?e.div(Math.pow(2,t.toNumber())+"").floor():e.div(new r(2).pow(t)).floor():new r(e.isNegative()?-1:e.isFinite()?0:NaN)}var oi="number, number";function oa(e,t){if(!eh(e)||!eh(t))throw Error("Integers expected in function bitAnd");return e&t}function oo(e){if(!eh(e))throw Error("Integer expected in function bitNot");return~e}function os(e,t){if(!eh(e)||!eh(t))throw Error("Integers expected in function bitOr");return e|t}function ou(e,t){if(!eh(e)||!eh(t))throw Error("Integers expected in function bitXor");return e^t}function ol(e,t){if(!eh(e)||!eh(t))throw Error("Integers expected in function leftShift");return e<<t}function oc(e,t){if(!eh(e)||!eh(t))throw Error("Integers expected in function rightArithShift");return e>>t}function of(e,t){if(!eh(e)||!eh(t))throw Error("Integers expected in function rightLogShift");return e>>>t}oa.signature=oi,oo.signature="number",os.signature=oi,ou.signature=oi,ol.signature=oi,oc.signature=oi,of.signature=oi;var op="bitAnd",om=ta(op,["typed","matrix","equalScalar","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,concat:i}=e,a=iU({typed:t,equalScalar:n}),o=i$({typed:t,equalScalar:n}),s=iL({typed:t,equalScalar:n}),u=iI({typed:t,matrix:r,concat:i});/**
   * Bitwise AND two values, `x & y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.bitAnd(x, y)
   *
   * Examples:
   *
   *    math.bitAnd(53, 131)               // returns number 1
   *
   *    math.bitAnd([1, 12, 31], 42)       // returns Array [0, 8, 10]
   *
   * See also:
   *
   *    bitNot, bitOr, bitXor, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x First value to and
   * @param  {number | BigNumber | Array | Matrix} y Second value to and
   * @return {number | BigNumber | Array | Matrix} AND of `x` and `y`
   */return t(op,{"number, number":oa,"BigNumber, BigNumber":a8},u({SS:o,DS:a,Ss:s}))}),od="bitNot",oh=ta(od,["typed"],e=>{var{typed:t}=e;/**
   * Bitwise NOT value, `~x`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.bitNot(x)
   *
   * Examples:
   *
   *    math.bitNot(1)               // returns number -2
   *
   *    math.bitNot([2, -3, 4])      // returns Array [-3, 2, -5]
   *
   * See also:
   *
   *    bitAnd, bitOr, bitXor, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x Value to not
   * @return {number | BigNumber | Array | Matrix} NOT of `x`
   */return t(od,{number:oo,BigNumber:a6,"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),og="bitOr",oy=ta(og,["typed","matrix","equalScalar","DenseMatrix","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,DenseMatrix:i,concat:a}=e,o=iT({typed:t}),s=iO({typed:t,equalScalar:n}),u=i_({typed:t,DenseMatrix:i}),l=iI({typed:t,matrix:r,concat:a});/**
   * Bitwise OR two values, `x | y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the lowest print base.
   *
   * Syntax:
   *
   *    math.bitOr(x, y)
   *
   * Examples:
   *
   *    math.bitOr(1, 2)               // returns number 3
   *
   *    math.bitOr([1, 2, 3], 4)       // returns Array [5, 6, 7]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitXor, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x First value to or
   * @param  {number | BigNumber | Array | Matrix} y Second value to or
   * @return {number | BigNumber | Array | Matrix} OR of `x` and `y`
   */return t(og,{"number, number":os,"BigNumber, BigNumber":a7},l({SS:s,DS:o,Ss:u}))}),ov=ta("matAlgo07xSSf",["typed","DenseMatrix"],e=>{var{typed:t,DenseMatrix:r}=e;/**
   * Iterates over SparseMatrix A and SparseMatrix B items (zero and nonzero) and invokes the callback function f(Aij, Bij).
   * Callback function invoked MxN times.
   *
   * C(i,j) = f(Aij, Bij)
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */return function(e,i,a){// sparse matrix arrays
var o,s,u,l=e._size,c=e._datatype,f=i._size,p=i._datatype;// validate dimensions
if(l.length!==f.length)throw new eH(l.length,f.length);// check rows & columns
if(l[0]!==f[0]||l[1]!==f[1])throw RangeError("Dimension mismatch. Matrix A ("+l+") must match Matrix B ("+f+")");// rows & columns
var m=l[0],d=l[1],h=0,g=a;// process data types
"string"==typeof c&&c===p&&(// datatype
o=c,// convert 0 to the same datatype
h=t.convert(0,o),// callback
g=t.find(a,[o,o]));// result arrays
var y=[];// initialize c
for(s=0;s<m;s++)y[s]=[];// workspaces
var v=[],x=[],b=[],N=[];// loop columns
for(u=0;u<d;u++){// columns mark
var w=u+1;// loop rows
for(// scatter the values of A(:,j) into workspace
n(e,u,b,v,w),// scatter the values of B(:,j) into workspace
n(i,u,N,x,w),s=0;s<m;s++){// matrix values @ i,j
var D=b[s]===w?v[s]:h,E=N[s]===w?x[s]:h;// invoke callback
y[s][u]=g(D,E)}}// return dense matrix
return new r({data:y,size:[m,d],datatype:o})};function n(e,t,r,n,i){// loop values in column j
for(var a=e._values,o=e._index,s=e._ptr,u=s[t],l=s[t+1];u<l;u++){// row
var c=o[u];// update workspace
r[c]=i,n[c]=a[u]}}}),ox="bitXor",ob=ta(ox,["typed","matrix","DenseMatrix","concat"],e=>{var{typed:t,matrix:r,DenseMatrix:n,concat:i}=e,a=i5({typed:t}),o=ov({typed:t,DenseMatrix:n}),s=i6({typed:t,DenseMatrix:n}),u=iI({typed:t,matrix:r,concat:i});/**
   * Bitwise XOR two values, `x ^ y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.bitXor(x, y)
   *
   * Examples:
   *
   *    math.bitXor(1, 2)               // returns number 3
   *
   *    math.bitXor([2, 3, 4], 4)       // returns Array [6, 7, 0]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitOr, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x First value to xor
   * @param  {number | BigNumber | Array | Matrix} y Second value to xor
   * @return {number | BigNumber | Array | Matrix} XOR of `x` and `y`
   */return t(ox,{"number, number":ou,"BigNumber, BigNumber":ot},u({SS:o,DS:a,Ss:s}))}),oN="boolean",ow=ta(oN,["typed"],e=>{var{typed:t}=e;/**
   * Create a boolean or convert a string or number to a boolean.
   * In case of a number, `true` is returned for non-zero numbers, and `false` in
   * case of zero.
   * Strings can be `'true'` or `'false'`, or can contain a number.
   * When value is a matrix, all elements will be converted to boolean.
   *
   * Syntax:
   *
   *    math.boolean(x)
   *
   * Examples:
   *
   *    math.boolean(0)     // returns false
   *    math.boolean(1)     // returns true
   *    math.boolean(-3)     // returns true
   *    math.boolean('true')     // returns true
   *    math.boolean('false')     // returns false
   *    math.boolean([1, 0, 1, 1])     // returns [true, false, true, true]
   *
   * See also:
   *
   *    bignumber, complex, index, matrix, string, unit
   *
   * @param {string | number | boolean | Array | Matrix | null} value  A value of any type
   * @return {boolean | Array | Matrix} The boolean value
   */return t(oN,{"":function(){return!1},boolean:function(e){return e},number:function(e){return!!e},null:function(e){return!1},BigNumber:function(e){return!e.isZero()},string:function(e){// try case insensitive
var t=e.toLowerCase();if("true"===t)return!0;if("false"===t)return!1;// test whether value is a valid number
var r=Number(e);if(""!==e&&!isNaN(r))return!!r;throw Error('Cannot convert "'+e+'" to a boolean')},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),oD="catalan",oE=ta(oD,["typed","addScalar","divideScalar","multiplyScalar","combinations","isNegative","isInteger"],e=>{var{typed:t,addScalar:r,divideScalar:n,multiplyScalar:i,combinations:a,isNegative:o,isInteger:s}=e;/**
   * The Catalan Numbers enumerate combinatorial structures of many different types.
   * catalan only takes integer arguments.
   * The following condition must be enforced: n >= 0
   *
   * Syntax:
   *
   *   math.catalan(n)
   *
   * Examples:
   *
   *    math.catalan(3) // returns 5
   *    math.catalan(8) // returns 1430
   *
   * See also:
   *
   *    bellNumbers
   *
   * @param {Number | BigNumber} n    nth Catalan number
   * @return {Number | BigNumber}     Cn(n)
   */return t(oD,{"number | BigNumber":function(e){if(!s(e)||o(e))throw TypeError("Non-negative integer value expected in function catalan");return n(a(i(e,2),e),r(e,1))}})}),oA="cbrt",oS=ta(oA,["config","typed","isNegative","unaryMinus","matrix","Complex","BigNumber","Fraction"],e=>{var{config:t,typed:r,isNegative:n,unaryMinus:i,matrix:a,Complex:o,BigNumber:s,Fraction:u}=e;/**
   * Calculate the cubic root of a value.
   *
   * To avoid confusion with the matrix cube root, this function does not
   * apply to matrices. For a matrix, to take the cube root elementwise,
   * see the examples.
   *
   * Syntax:
   *
   *    math.cbrt(x)
   *    math.cbrt(x, allRoots)
   *
   * Examples:
   *
   *    math.cbrt(27)                  // returns 3
   *    math.cube(3)                   // returns 27
   *    math.cbrt(-64)                 // returns -4
   *    math.cbrt(math.unit('27 m^3')) // returns Unit 3 m
   *    math.map([27, 64, 125], x => math.cbrt(x))       // returns [3, 4, 5]
   *
   *    const x = math.complex('8i')
   *    math.cbrt(x)                   // returns Complex 1.7320508075689 + i
   *    math.cbrt(x, true)             // returns Matrix [
   *                                    //    1.7320508075689 + i
   *                                    //   -1.7320508075689 + i
   *                                    //   -2i
   *                                    // ]
   *
   * See also:
   *
   *    square, sqrt, cube
   *
   * @param {number | BigNumber | Complex | Unit} x
   *            Value for which to calculate the cubic root.
   * @param {boolean} [allRoots]  Optional, false by default. Only applicable
   *            when `x` is a number or complex number. If true, all complex
   *            roots are returned, if false (default) the principal root is
   *            returned.
   * @return {number | BigNumber | Complex | Unit}
   *            Returns the cubic root of `x`
   */return r(oA,{number:n0,// note: signature 'number, boolean' is also supported,
//       created by typed as it knows how to convert number to Complex
Complex:l,"Complex, boolean":l,BigNumber:function(e){return e.cbrt()},Unit:/**
   * Calculate the cubic root for a Unit
   * @param {Unit} x
   * @return {Unit} Returns the cubic root of x
   * @private
   */function(e){if(e.value&&f(e.value)){var t=e.clone();return t.value=1,(t=t.pow(1/3)).value=l(e.value),t}var r,a=n(e.value);a&&(e.value=i(e.value)),r=c(e.value)?new s(1).div(3):p(e.value)?new u(1,3):1/3;var o=e.pow(r);return a&&(o.value=i(o.value)),o}});/**
   * Calculate the cubic root for a complex number
   * @param {Complex} x
   * @param {boolean} [allRoots]   If true, the function will return an array
   *                               with all three roots. If false or undefined,
   *                               the principal root is returned.
   * @returns {Complex | Array.<Complex> | Matrix.<Complex>} Returns the cubic root(s) of x
   * @private
   */function l(e,r){// https://www.wikiwand.com/en/Cube_root#/Complex_numbers
var n=e.arg()/3,i=e.abs(),s=new o(n0(i),0).mul(new o(0,n).exp());if(!r)return s;var u=[s,new o(n0(i),0).mul(new o(0,n+2*Math.PI/3).exp()),new o(n0(i),0).mul(new o(0,n-2*Math.PI/3).exp())];return"Array"===t.matrix?u:a(u)}});/**
 * Compares two BigNumbers.
 * @param {BigNumber} x       First value to compare
 * @param {BigNumber} y       Second value to compare
 * @param {number} [epsilon]  The maximum relative difference between x and y
 *                            If epsilon is undefined or null, the function will
 *                            test whether x and y are exactly equal.
 * @return {boolean} whether the two numbers are nearly equal
 */function oC(e,t,r){// if epsilon is null or undefined, test whether x and y are exactly equal
if(null==r)return e.eq(t);// use "==" operator, handles infinities
if(e.eq(t))return!0;// NaN
if(e.isNaN()||t.isNaN())return!1;// at this point x and y should be finite
if(e.isFinite()&&t.isFinite()){// check numbers are very close, needed when comparing numbers near zero
var n=e.minus(t).abs();if(n.isZero())return!0;// use relative error
var i=e.constructor.max(e.abs(),t.abs());return n.lte(i.times(r))}// Infinite and Number or negative Infinite and positive Infinite cases
return!1}var oM="ceil",oF=ta(oM,["typed","config","round"],e=>{var{typed:t,config:r,round:n}=e;return t(oM,{number:function(e){return eB(e,n(e),r.epsilon)?n(e):Math.ceil(e)},"number, number":function(e,t){if(eB(e,n(e,t),r.epsilon))return n(e,t);var[i,a]="".concat(e,"e").split("e"),o=Math.ceil(Number("".concat(i,"e").concat(Number(a)+t)));return[i,a]="".concat(o,"e").split("e"),Number("".concat(i,"e").concat(Number(a)-t))}})}),oB=ta(oM,["typed","config","round","matrix","equalScalar","zeros","DenseMatrix"],t=>{var{typed:r,config:n,round:i,matrix:a,equalScalar:o,zeros:s,DenseMatrix:u}=t,l=iL({typed:r,equalScalar:o}),c=i6({typed:r,DenseMatrix:u}),f=iq({typed:r}),p=oF({typed:r,config:n,round:i});/**
   * Round a value towards plus infinity
   * If `x` is complex, both real and imaginary part are rounded towards plus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.ceil(x)
   *    math.ceil(x, n)
   *
   * Examples:
   *
   *    math.ceil(3.2)               // returns number 4
   *    math.ceil(3.8)               // returns number 4
   *    math.ceil(-4.2)              // returns number -4
   *    math.ceil(-4.7)              // returns number -4
   *
   *    math.ceil(3.212, 2)          // returns number 3.22
   *    math.ceil(3.288, 2)          // returns number 3.29
   *    math.ceil(-4.212, 2)         // returns number -4.21
   *    math.ceil(-4.782, 2)         // returns number -4.78
   *
   *    const c = math.complex(3.24, -2.71)
   *    math.ceil(c)                 // returns Complex 4 - 2i
   *    math.ceil(c, 1)              // returns Complex 3.3 - 2.7i
   *
   *    math.ceil([3.2, 3.8, -4.7])  // returns Array [4, 4, -4]
   *    math.ceil([3.21, 3.82, -4.71], 1)  // returns Array [3.3, 3.9, -4.7]
   *
   * See also:
   *
   *    floor, fix, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
   */return r("ceil",{number:p.signatures.number,"number,number":p.signatures["number,number"],Complex:function(e){return e.ceil()},"Complex, number":function(e,t){return e.ceil(t)},"Complex, BigNumber":function(e,t){return e.ceil(t.toNumber())},BigNumber:function(e){return oC(e,i(e),n.epsilon)?i(e):e.ceil()},"BigNumber, BigNumber":function(t,r){return oC(t,i(t,r),n.epsilon)?i(t,r):t.toDecimalPlaces(r.toNumber(),/*@__PURE__*/e(a3).ROUND_CEIL)},Fraction:function(e){return e.ceil()},"Fraction, number":function(e,t){return e.ceil(t)},"Fraction, BigNumber":function(e,t){return e.ceil(t.toNumber())},"Array | Matrix":r.referToSelf(e=>t=>tq(t,e,!0)),"Array, number | BigNumber":r.referToSelf(e=>(t,r)=>tq(t,t=>e(t,r),!0)),"SparseMatrix, number | BigNumber":r.referToSelf(e=>(t,r)=>l(t,r,e,!1)),"DenseMatrix, number | BigNumber":r.referToSelf(e=>(t,r)=>f(t,r,e,!1)),"number | Complex | Fraction | BigNumber, Array":r.referToSelf(e=>(t,r)=>f(a(r),t,e,!0).valueOf()),"number | Complex | Fraction | BigNumber, Matrix":r.referToSelf(e=>(t,r)=>o(t,0)?s(r.size(),r.storage()):"dense"===r.storage()?f(r,t,e,!0):c(r,t,e,!0))})}),oT="clone",oO=ta(oT,["typed"],e=>{var{typed:t}=e;/**
   * Clone an object. Will make a deep copy of the data.
   *
   * Syntax:
   *
   *     math.clone(x)
   *
   * Examples:
   *
   *    math.clone(3.5)                   // returns number 3.5
   *    math.clone(math.complex('2-4i'))  // returns Complex 2 - 4i
   *    math.clone(math.unit(45, 'deg'))  // returns Unit 45 deg
   *    math.clone([[1, 2], [3, 4]])      // returns Array [[1, 2], [3, 4]]
   *    math.clone("hello world")         // returns string "hello world"
   *
   * @param {*} x   Object to be cloned
   * @return {*} A clone of object x
   */return t(oT,{any:J})});/** @param {number} i
 *  @param {number} n
 *  @returns {number} product of i to n
 */function o_(e,t){if(t<e)return 1;if(t===e)return t;var r=t+e>>1;// divide (n + i) by 2 and truncate to integer
return o_(e,r)*o_(r+1,t)}function oz(e,t){if(!eh(e)||e<0||!eh(t)||t<0)throw TypeError("Positive integer value expected in function combinations");if(t>e)throw TypeError("k must be less than or equal to n");// balance multiplications and divisions to try to keep intermediate values
// in exact-integer range as long as possible
for(var r=e-t,n=1,i=t<r?r+1:t+1,a=2,o=t<r?t:r,s=i;s<=e;++s)for(n*=s;a<=o&&n%a==0;)n/=a,++a;return a<=o&&(n/=o_(a,o)),n}oz.signature="number, number";var oq="combinations",ok=ta(oq,["typed"],e=>{var{typed:t}=e;/**
   * Compute the number of ways of picking `k` unordered outcomes from `n`
   * possibilities.
   *
   * Combinations only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   * Syntax:
   *
   *     math.combinations(n, k)
   *
   * Examples:
   *
   *    math.combinations(7, 5) // returns 21
   *
   * See also:
   *
   *    combinationsWithRep, permutations, factorial
   *
   * @param {number | BigNumber} n    Total number of objects in the set
   * @param {number | BigNumber} k    Number of objects in the subset
   * @return {number | BigNumber}     Number of possible combinations.
   */return t(oq,{"number, number":oz,"BigNumber, BigNumber":function(e,t){var r,n,i=e.constructor,a=e.minus(t),o=new i(1);if(!oI(e)||!oI(t))throw TypeError("Positive integer value expected in function combinations");if(t.gt(e))throw TypeError("k must be less than n in function combinations");if(r=o,t.lt(a))for(n=o;n.lte(a);n=n.plus(o))r=r.times(t.plus(n)).dividedBy(n);else for(n=o;n.lte(t);n=n.plus(o))r=r.times(a.plus(n)).dividedBy(n);return r}})});/**
 * Test whether BigNumber n is a positive integer
 * @param {BigNumber} n
 * @returns {boolean} isPositiveInteger
 */function oI(e){return e.isInteger()&&e.gte(0)}var oR="combinationsWithRep",oP=ta(oR,["typed"],e=>{var{typed:t}=e;/**
   * Compute the number of ways of picking `k` unordered outcomes from `n`
   * possibilities, allowing individual outcomes to be repeated more than once.
   *
   * CombinationsWithRep only takes integer arguments.
   * The following condition must be enforced: k <= n + k -1.
   *
   * Syntax:
   *
   *     math.combinationsWithRep(n, k)
   *
   * Examples:
   *
   *    math.combinationsWithRep(7, 5) // returns 462
   *
   * See also:
   *
   *    combinations, permutations, factorial
   *
   * @param {number | BigNumber} n    Total number of objects in the set
   * @param {number | BigNumber} k    Number of objects in the subset
   * @return {number | BigNumber}     Number of possible combinations with replacement.
   */return t(oR,{"number, number":function(e,t){if(!eh(e)||e<0||!eh(t)||t<0)throw TypeError("Positive integer value expected in function combinationsWithRep");if(e<1)throw TypeError("k must be less than or equal to n + k - 1");return t<e-1?o_(e,e+t-1)/o_(1,t):o_(t+1,e+t-1)/o_(1,e-1)},"BigNumber, BigNumber":function(e,t){var r,n,i=new e.constructor(1),a=e.minus(i);if(!oj(e)||!oj(t))throw TypeError("Positive integer value expected in function combinationsWithRep");if(e.lt(i))throw TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");if(r=i,t.lt(a))for(n=i;n.lte(a);n=n.plus(i))r=r.times(t.plus(n)).dividedBy(n);else for(n=i;n.lte(t);n=n.plus(i))r=r.times(a.plus(n)).dividedBy(n);return r}})});/**
 * Test whether BigNumber n is a positive integer
 * @param {BigNumber} n
 * @returns {boolean} isPositiveInteger
 */function oj(e){return e.isInteger()&&e.gte(0)}var oU=ta("matAlgo05xSfSf",["typed","equalScalar"],e=>{var{typed:t,equalScalar:r}=e;/**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
   * Callback function invoked MAX(NNZA, NNZB) times
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 || B(i,j) !== 0
   * C(i,j) = ┤
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */return function(e,n,i){// sparse matrix arrays
var a,o,s,u,l,c=e._values,f=e._index,p=e._ptr,m=e._size,d=e._datatype,h=n._values,g=n._index,y=n._ptr,v=n._size,x=n._datatype;// validate dimensions
if(m.length!==v.length)throw new eH(m.length,v.length);// check rows & columns
if(m[0]!==v[0]||m[1]!==v[1])throw RangeError("Dimension mismatch. Matrix A ("+m+") must match Matrix B ("+v+")");// rows & columns
var b=m[0],N=m[1],w=r,D=0,E=i;"string"==typeof d&&d===x&&(// datatype
a=d,// find signature that matches (dt, dt)
w=t.find(r,[a,a]),// convert 0 to the same datatype
D=t.convert(0,a),// callback
E=t.find(i,[a,a]));// result arrays
var A=c&&h?[]:void 0,S=[],C=[],M=A?[]:void 0,F=A?[]:void 0,B=[],T=[];// loop columns
for(s=0;s<N;s++){// update cptr
C[s]=S.length;// columns mark
var O=s+1;// loop values A(:,j)
for(u=p[s],l=p[s+1];u<l;u++)// row
o=f[u],// push index
S.push(o),// update workspace
B[o]=O,M&&(M[o]=c[u]);// loop values B(:,j)
for(u=y[s],l=y[s+1];u<l;u++)B[// row
o=g[u]]!==O&&S.push(o),// update workspace
T[o]=O,F&&(F[o]=h[u]);// check we need to process values (non pattern matrix)
if(A)// loop index in j
for(// initialize first index in j
u=C[s];u<S.length;){// marks
var _=B[// row
o=S[u]],z=T[o];// check Aij or Bij are nonzero
if(_===O||z===O){// Cij
var q=E(_===O?M[o]:D,z===O?F[o]:D);// check for zero
w(q,D)?S.splice(u,1):(// push value
A.push(q),// increment pointer
u++)}}}// return sparse matrix
return(// update cptr
C[N]=S.length,e.createSparseMatrix({values:A,index:S,ptr:C,size:[b,N],datatype:a}))}}),oL=ta("compareUnits",["typed"],e=>{var{typed:t}=e;return{"Unit, Unit":t.referToSelf(e=>(r,n)=>{if(!r.equalBase(n))throw Error("Cannot compare units with different base");return t.find(e,[r.valueType(),n.valueType()])(r.value,n.value)})}}),o$="compare",oH=ta(o$,["typed","config","matrix","equalScalar","BigNumber","Fraction","DenseMatrix","concat"],e=>{var{typed:t,config:r,equalScalar:n,matrix:i,BigNumber:a,Fraction:o,DenseMatrix:s,concat:u}=e,l=i5({typed:t}),c=oU({typed:t,equalScalar:n}),f=i6({typed:t,DenseMatrix:s}),p=iI({typed:t,matrix:i,concat:u}),m=oL({typed:t});/**
   * Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.
   *
   * x and y are considered equal when the relative difference between x and y
   * is smaller than the configured epsilon. The function cannot be used to
   * compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.compare(x, y)
   *
   * Examples:
   *
   *    math.compare(6, 1)           // returns 1
   *    math.compare(2, 3)           // returns -1
   *    math.compare(7, 7)           // returns 0
   *    math.compare('10', '2')      // returns 1
   *    math.compare('1000', '1e3')  // returns 0
   *
   *    const a = math.unit('5 cm')
   *    const b = math.unit('40 mm')
   *    math.compare(a, b)           // returns 1
   *
   *    math.compare(2, [1, 2, 3])   // returns [1, 0, -1]
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, larger, largerEq, compareNatural, compareText
   *
   * @param  {number | BigNumber | Fraction | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | Unit | string | Array | Matrix} y Second value to compare
   * @return {number | BigNumber | Fraction | Array | Matrix} Returns the result of the comparison:
   *                                                          1 when x > y, -1 when x < y, and 0 when x == y.
   */return t(o$,oZ({typed:t,config:r}),{"boolean, boolean":function(e,t){return e===t?0:e>t?1:-1},"BigNumber, BigNumber":function(e,t){return new a(oC(e,t,r.epsilon)?0:e.cmp(t))},"Fraction, Fraction":function(e,t){return new o(e.compare(t))},"Complex, Complex":function(){throw TypeError("No ordering relation is defined for complex numbers")}},m,p({SS:c,DS:l,Ss:f}))}),oZ=ta(o$,["typed","config"],e=>{var{typed:t,config:r}=e;return t(o$,{"number, number":function(e,t){return eB(e,t,r.epsilon)?0:e>t?1:-1}})}),oG={};/*
 * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
 * Author: Jim Palmer (based on chunking idea from Dave Koelle)
 *//*jshint unused:false */oG=function e(t,r){var n,i,a=/(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,o=/(^[ ]*|[ ]*$)/g,s=/(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,u=/^0x[0-9a-f]+$/i,l=/^0/,c=function(t){return e.insensitive&&(""+t).toLowerCase()||""+t},f=c(t).replace(o,"")||"",p=c(r).replace(o,"")||"",m=f.replace(a,"\x00$1\x00").replace(/\0$/,"").replace(/^\0/,"").split("\x00"),d=p.replace(a,"\x00$1\x00").replace(/\0$/,"").replace(/^\0/,"").split("\x00"),h=parseInt(f.match(u),16)||1!==m.length&&f.match(s)&&Date.parse(f),g=parseInt(p.match(u),16)||h&&p.match(s)&&Date.parse(p)||null;// first try and sort Hex codes or Dates
if(g){if(h<g)return -1;if(h>g)return 1}// natural sorting through split numeric strings and default strings
for(var y=0,v=Math.max(m.length,d.length);y<v;y++){// handle numeric vs string comparison - number < string - (Kyle Adams)
if(// find floats not starting with '0', string or 0 if not defined (Clint Priest)
n=!(m[y]||"").match(l)&&parseFloat(m[y])||m[y]||0,i=!(d[y]||"").match(l)&&parseFloat(d[y])||d[y]||0,isNaN(n)!==isNaN(i))return isNaN(n)?1:-1;if(typeof n!=typeof i&&(n+="",i+=""),n<i)return -1;if(n>i)return 1}return 0};var oV="compareNatural",oW=ta(oV,["typed","compare"],t=>{var{typed:r,compare:n}=t,i=n.signatures["boolean,boolean"];/**
   * Compare two values of any type in a deterministic, natural way.
   *
   * For numeric values, the function works the same as `math.compare`.
   * For types of values that can't be compared mathematically,
   * the function compares in a natural way.
   *
   * For numeric values, x and y are considered equal when the relative
   * difference between x and y is smaller than the configured epsilon.
   * The function cannot be used to compare values smaller than
   * approximately 2.22e-16.
   *
   * For Complex numbers, first the real parts are compared. If equal,
   * the imaginary parts are compared.
   *
   * Strings are compared with a natural sorting algorithm, which
   * orders strings in a "logic" way following some heuristics.
   * This differs from the function `compare`, which converts the string
   * into a numeric value and compares that. The function `compareText`
   * on the other hand compares text lexically.
   *
   * Arrays and Matrices are compared value by value until there is an
   * unequal pair of values encountered. Objects are compared by sorted
   * keys until the keys or their values are unequal.
   *
   * Syntax:
   *
   *    math.compareNatural(x, y)
   *
   * Examples:
   *
   *    math.compareNatural(6, 1)              // returns 1
   *    math.compareNatural(2, 3)              // returns -1
   *    math.compareNatural(7, 7)              // returns 0
   *
   *    math.compareNatural('10', '2')         // returns 1
   *    math.compareText('10', '2')            // returns -1
   *    math.compare('10', '2')                // returns 1
   *
   *    math.compareNatural('Answer: 10', 'Answer: 2') // returns 1
   *    math.compareText('Answer: 10', 'Answer: 2')    // returns -1
   *    math.compare('Answer: 10', 'Answer: 2')
   *        // Error: Cannot convert "Answer: 10" to a number
   *
   *    const a = math.unit('5 cm')
   *    const b = math.unit('40 mm')
   *    math.compareNatural(a, b)              // returns 1
   *
   *    const c = math.complex('2 + 3i')
   *    const d = math.complex('2 + 4i')
   *    math.compareNatural(c, d)              // returns -1
   *
   *    math.compareNatural([1, 2, 4], [1, 2, 3]) // returns 1
   *    math.compareNatural([1, 2, 3], [1, 2])    // returns 1
   *    math.compareNatural([1, 5], [1, 2, 3])    // returns 1
   *    math.compareNatural([1, 2], [1, 2])       // returns 0
   *
   *    math.compareNatural({a: 2}, {a: 4})       // returns -1
   *
   * See also:
   *
   *    compare, compareText
   *
   * @param  {*} x First value to compare
   * @param  {*} y Second value to compare
   * @return {number} Returns the result of the comparison:
   *                  1 when x > y, -1 when x < y, and 0 when x == y.
   */return r(oV,{"any, any":function t(r,o){var s,u=Y(r),l=Y(o);// numeric types
if(("number"===u||"BigNumber"===u||"Fraction"===u)&&("number"===l||"BigNumber"===l||"Fraction"===l))return"0"!==(s=n(r,o)).toString()?s>0?1:-1:/*@__PURE__*/e(oG)(u,l);// matrix types
var c=["Array","DenseMatrix","SparseMatrix"];if(c.includes(u)||c.includes(l))return 0!==(s=/**
   * Compare mixed matrix/array types, by converting to same-shaped array.
   * This comparator is non-deterministic regarding input types.
   * @param {Array | SparseMatrix | DenseMatrix | *} x
   * @param {Array | SparseMatrix | DenseMatrix | *} y
   * @returns {number} Returns the comparison result: -1, 0, or 1
   */function e(t,r,n){return x(r)&&x(n)?a(t,r.toJSON().values,n.toJSON().values):x(r)?e(t,r.toArray(),n):x(n)?e(t,r,n.toArray()):v(r)?e(t,r.toJSON().data,n):v(n)?e(t,r,n.toJSON().data):Array.isArray(r)?Array.isArray(n)?a(t,r,n):e(t,r,[n]):e(t,[r],n)}(t,r,o))?s:/*@__PURE__*/e(oG)(u,l);// in case of different types, order by name of type, i.e. 'BigNumber' < 'Complex'
if(u!==l)return /*@__PURE__*/e(oG)(u,l);if("Complex"===u)return r.re>o.re?1:r.re<o.re?-1:r.im>o.im?1:r.im<o.im?-1:0;if("Unit"===u)return r.equalBase(o)?t(r.value,o.value):a(t,r.formatUnits(),o.formatUnits());if("boolean"===u)return i(r,o);if("string"===u)return /*@__PURE__*/e(oG)(r,o);if("Object"===u)return(/**
   * Compare two objects
   *
   * - First, compare sorted property names
   * - Next, compare the property values
   *
   * @param {Object} x
   * @param {Object} y
   * @returns {number} Returns the comparison result: -1, 0, or 1
   */function(t,r,n){var i=Object.keys(r),o=Object.keys(n);// compare keys
i.sort(/*@__PURE__*/e(oG)),o.sort(/*@__PURE__*/e(oG));var s=a(t,i,o);if(0!==s)return s;// compare values
for(var u=0;u<i.length;u++){var l=t(r[i[u]],n[o[u]]);if(0!==l)return l}return 0}(t,r,o));if("null"===u||"undefined"===u)return 0;// this should not occur...
throw TypeError('Unsupported type of value "'+u+'"')}});// just to check # args
/**
   * Compare two Arrays
   *
   * - First, compares value by value
   * - Next, if all corresponding values are equal,
   *   look at the length: longest array will be considered largest
   *
   * @param {Array} x
   * @param {Array} y
   * @returns {number} Returns the comparison result: -1, 0, or 1
   */function a(e,t,r){// compare each value
for(var n=0,i=Math.min(t.length,r.length);n<i;n++){var a=e(t[n],r[n]);if(0!==a)return a}return(// compare the size of the arrays
t.length>r.length?1:t.length<r.length?-1:0)}}),oY="compareText";e$.signature="any, any";var oJ=ta(oY,["typed","matrix","concat"],e=>{var{typed:t,matrix:r,concat:n}=e,i=iI({typed:t,matrix:r,concat:n});/**
   * Compare two strings lexically. Comparison is case sensitive.
   * Returns 1 when x > y, -1 when x < y, and 0 when x == y.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.compareText(x, y)
   *
   * Examples:
   *
   *    math.compareText('B', 'A')     // returns 1
   *    math.compareText('2', '10')    // returns 1
   *    math.compare('2', '10')        // returns -1
   *    math.compareNatural('2', '10') // returns -1
   *
   *    math.compareText('B', ['A', 'B', 'C']) // returns [1, 0, -1]
   *
   * See also:
   *
   *    equal, equalText, compare, compareNatural
   *
   * @param  {string | Array | DenseMatrix} x First string to compare
   * @param  {string | Array | DenseMatrix} y Second string to compare
   * @return {number | Array | DenseMatrix} Returns the result of the comparison:
   *                                        1 when x > y, -1 when x < y, and 0 when x == y.
   */return t(oY,e$,i({elop:e$,Ds:!0}))}),oX=ta("complex",["typed","Complex"],e=>{var{typed:t,Complex:r}=e;/**
   * Create a complex value or convert a value to a complex value.
   *
   * Syntax:
   *
   *     math.complex()                           // creates a complex value with zero
   *                                              // as real and imaginary part.
   *     math.complex(re : number, im : string)   // creates a complex value with provided
   *                                              // values for real and imaginary part.
   *     math.complex(re : number)                // creates a complex value with provided
   *                                              // real value and zero imaginary part.
   *     math.complex(complex : Complex)          // clones the provided complex value.
   *     math.complex(arg : string)               // parses a string into a complex value.
   *     math.complex(array : Array)              // converts the elements of the array
   *                                              // or matrix element wise into a
   *                                              // complex value.
   *     math.complex({re: number, im: number})   // creates a complex value with provided
   *                                              // values for real an imaginary part.
   *     math.complex({r: number, phi: number})   // creates a complex value with provided
   *                                              // polar coordinates
   *
   * Examples:
   *
   *    const a = math.complex(3, -4)     // a = Complex 3 - 4i
   *    a.re = 5                          // a = Complex 5 - 4i
   *    const i = a.im                    // Number -4
   *    const b = math.complex('2 + 6i')  // Complex 2 + 6i
   *    const c = math.complex()          // Complex 0 + 0i
   *    const d = math.add(a, b)          // Complex 5 + 2i
   *
   * See also:
   *
   *    bignumber, boolean, index, matrix, number, string, unit
   *
   * @param {* | Array | Matrix} [args]
   *            Arguments specifying the real and imaginary part of the complex number
   * @return {Complex | Array | Matrix} Returns a complex value
   */return t("complex",{"":function(){return r.ZERO},number:function(e){return new r(e,0)},"number, number":function(e,t){return new r(e,t)},// TODO: this signature should be redundant
"BigNumber, BigNumber":function(e,t){return new r(e.toNumber(),t.toNumber())},Fraction:function(e){return new r(e.valueOf(),0)},Complex:function(e){return e.clone()},string:function(e){return r(e);// for example '2 + 3i'
},null:function(e){return r(0)},Object:function(e){if("re"in e&&"im"in e)return new r(e.re,e.im);if("r"in e&&"phi"in e||"abs"in e&&"arg"in e)return new r(e);throw Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)")},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),oQ={};!/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **//**
 *
 * This class allows the manipulation of complex numbers.
 * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.
 *
 * Object form
 * { re: <real>, im: <imaginary> }
 * { arg: <angle>, abs: <radius> }
 * { phi: <angle>, r: <radius> }
 *
 * Array / Vector form
 * [ real, imaginary ]
 *
 * Double form
 * 99.3 - Single double value
 *
 * String form
 * '23.1337' - Simple real number
 * '15+3i' - a simple complex number
 * '3-i' - a simple complex number
 *
 * Example:
 *
 * var c = new Complex('99.3+8i');
 * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);
 *
 */function(e){var t=Math.cosh||function(e){return 1e-9>Math.abs(e)?1-e:(Math.exp(e)+Math.exp(-e))*.5},r=Math.sinh||function(e){return 1e-9>Math.abs(e)?e:(Math.exp(e)-Math.exp(-e))*.5},n=function(e){var t=Math.PI/4;if(-t>e||e>t)return Math.cos(e)-1;/* Calculate horner form of polynomial of taylor series in Q
    var fac = 1, alt = 1, pol = {};
    for (var i = 0; i <= 16; i++) {
      fac*= i || 1;
      if (i % 2 == 0) {
        pol[i] = new Fraction(1, alt * fac);
        alt = -alt;
      }
    }
    console.log(new Polynomial(pol).toHorner()); // (((((((1/20922789888000x^2-1/87178291200)x^2+1/479001600)x^2-1/3628800)x^2+1/40320)x^2-1/720)x^2+1/24)x^2-1/2)x^2+1
    */var r=e*e;return r*(r*(r*(r*(r*(r*(r*(r/20922789888e3-1/87178291200)+1/479001600)-1/3628800)+1/40320)-1/720)+1/24)-.5)},i=function(e,t){var r=Math.abs(e),n=Math.abs(t);return r<3e3&&n<3e3?Math.sqrt(r*r+n*n):(r<n?(r=n,n=e/t):n=t/e,r*Math.sqrt(1+n*n))},a=function(){throw SyntaxError("Invalid Param")};/**
   * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows
   *
   * @param {number} a
   * @param {number} b
   * @returns {number}
   */function o(e,t){var r=Math.abs(e),n=Math.abs(t);return 0===e?Math.log(n):0===t?Math.log(r):r<3e3&&n<3e3?.5*Math.log(e*e+t*t):.5*Math.log(/* I got 4 ideas to compute this property without overflow:
     *
     * Testing 1000000 times with random samples for a,b ∈ [1, 1000000000] against a big decimal library to get an error estimate
     *
     * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)

     Math.log(a * a + b * b) / 2

     *
     *
     * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)

     var fn = function(a, b) {
     a = Math.abs(a);
     b = Math.abs(b);
     var t = Math.min(a, b);
     a = Math.max(a, b);
     t = t / a;

     return Math.log(a) + Math.log(1 + t * t) / 2;
     };

     * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)

     Math.log(a / Math.cos(Math.atan2(b, a)))

     * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)

     Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))

     */(e/=2)*e+(t/=2)*t)+Math.LN2}var s=function(e,t){var r={re:0,im:0};if(null==e)r.re=r.im=0;else if(void 0!==t)r.re=e,r.im=t;else switch(typeof e){case"object":if("im"in e&&"re"in e)r.re=e.re,r.im=e.im;else if("abs"in e&&"arg"in e){if(!Number.isFinite(e.abs)&&Number.isFinite(e.arg))return u.INFINITY;r.re=e.abs*Math.cos(e.arg),r.im=e.abs*Math.sin(e.arg)}else if("r"in e&&"phi"in e){if(!Number.isFinite(e.r)&&Number.isFinite(e.phi))return u.INFINITY;r.re=e.r*Math.cos(e.phi),r.im=e.r*Math.sin(e.phi)}else 2===e.length?(r.re=e[0],r.im=e[1]):a();break;case"string":r.im=/* void */r.re=0;var n=e.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g),i=1,o=0;null===n&&a();for(var s=0;s<n.length;s++){var l=n[s];" "===l||"	"===l||"\n"===l||("+"===l?i++:"-"===l?o++:("i"===l||"I"===l?(i+o===0&&a()," "===n[s+1]||isNaN(n[s+1])?r.im+=parseFloat((o%2?"-":"")+"1"):(r.im+=parseFloat((o%2?"-":"")+n[s+1]),s++)):((i+o===0||isNaN(l))&&a(),"i"===n[s+1]||"I"===n[s+1]?(r.im+=parseFloat((o%2?"-":"")+l),s++):r.re+=parseFloat((o%2?"-":"")+l)),i=o=0))}// Still something on the stack
i+o>0&&a();break;case"number":r.im=0,r.re=e;break;default:a()}return isNaN(r.re)||isNaN(r.im),r};/**
   * @constructor
   * @returns {Complex}
   */function u(e,t){if(!(this instanceof u))return new u(e,t);var r=s(e,t);this.re=r.re,this.im=r.im}u.prototype={re:0,im:0,/**
     * Calculates the sign of a complex number, which is a normalized complex
     *
     * @returns {Complex}
     */sign:function(){var e=this.abs();return new u(this.re/e,this.im/e)},/**
     * Adds two complex numbers
     *
     * @returns {Complex}
     */add:function(e,t){var r=new u(e,t);return(// Infinity + Infinity = NaN
this.isInfinite()&&r.isInfinite()?u.NAN:this.isInfinite()||r.isInfinite()?u.INFINITY:new u(this.re+r.re,this.im+r.im))},/**
     * Subtracts two complex numbers
     *
     * @returns {Complex}
     */sub:function(e,t){var r=new u(e,t);return(// Infinity - Infinity = NaN
this.isInfinite()&&r.isInfinite()?u.NAN:this.isInfinite()||r.isInfinite()?u.INFINITY:new u(this.re-r.re,this.im-r.im))},/**
     * Multiplies two complex numbers
     *
     * @returns {Complex}
     */mul:function(e,t){var r=new u(e,t);return(// Infinity * 0 = NaN
this.isInfinite()&&r.isZero()||this.isZero()&&r.isInfinite()?u.NAN:this.isInfinite()||r.isInfinite()?u.INFINITY:0===r.im&&0===this.im?new u(this.re*r.re,0):new u(this.re*r.re-this.im*r.im,this.re*r.im+this.im*r.re))},/**
     * Divides two complex numbers
     *
     * @returns {Complex}
     */div:function(e,t){var r,n,i=new u(e,t);// 0 / 0 = NaN and Infinity / Infinity = NaN
if(this.isZero()&&i.isZero()||this.isInfinite()&&i.isInfinite())return u.NAN;// Infinity / 0 = Infinity
if(this.isInfinite()||i.isZero())return u.INFINITY;// 0 / Infinity = 0
if(this.isZero()||i.isInfinite())return u.ZERO;e=this.re,t=this.im;var a=i.re,o=i.im;return 0===o?new u(e/a,t/a):Math.abs(a)<Math.abs(o)?(n=a/o,r=a*n+o,new u((e*n+t)/r,(t*n-e)/r)):(n=o/a,r=o*n+a,new u((e+t*n)/r,(t-e*n)/r))},/**
     * Calculate the power of two complex numbers
     *
     * @returns {Complex}
     */pow:function(e,t){var r=new u(e,t);if(e=this.re,t=this.im,r.isZero())return u.ONE;// If the exponent is real
if(0===r.im){if(0===t&&e>0)return new u(Math.pow(e,r.re),0);if(0===e)switch((r.re%4+4)%4){case 0:return new u(Math.pow(t,r.re),0);case 1:return new u(0,Math.pow(t,r.re));case 2:return new u(-Math.pow(t,r.re),0);case 3:return new u(0,-Math.pow(t,r.re))}}/* I couldn't find a good formula, so here is a derivation and optimization
       *
       * z_1^z_2 = (a + bi)^(c + di)
       *         = exp((c + di) * log(a + bi)
       *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
       * =>...
       * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
       * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
       *
       * =>...
       * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
       * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
       *
       * =>
       * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
       * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
       *
       */if(0===e&&0===t&&r.re>0&&r.im>=0)return u.ZERO;var n=Math.atan2(t,e),i=o(e,t);return new u((e=Math.exp(r.re*i-r.im*n))*Math.cos(t=r.im*i+r.re*n),e*Math.sin(t))},/**
     * Calculate the complex square root
     *
     * @returns {Complex}
     */sqrt:function(){var e,t,r=this.re,n=this.im,i=this.abs();if(r>=0){if(0===n)return new u(Math.sqrt(r),0);e=.5*Math.sqrt(2*(i+r))}else e=Math.abs(n)/Math.sqrt(2*(i-r));return t=r<=0?.5*Math.sqrt(2*(i-r)):Math.abs(n)/Math.sqrt(2*(i+r)),new u(e,n<0?-t:t)},/**
     * Calculate the complex exponent
     *
     * @returns {Complex}
     */exp:function(){var e=Math.exp(this.re);return this.im,new u(e*Math.cos(this.im),e*Math.sin(this.im))},/**
     * Calculate the complex exponent and subtracts one.
     *
     * This may be more accurate than `Complex(x).exp().sub(1)` if
     * `x` is small.
     *
     * @returns {Complex}
     */expm1:function(){/**
       * exp(a + i*b) - 1
       = exp(a) * (cos(b) + j*sin(b)) - 1
       = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)
       */var e=this.re,t=this.im;return new u(Math.expm1(e)*Math.cos(t)+n(t),Math.exp(e)*Math.sin(t))},/**
     * Calculate the natural log
     *
     * @returns {Complex}
     */log:function(){var e=this.re,t=this.im;return new u(o(e,t),Math.atan2(t,e))},/**
     * Calculate the magnitude of the complex number
     *
     * @returns {number}
     */abs:function(){return i(this.re,this.im)},/**
     * Calculate the angle of the complex number
     *
     * @returns {number}
     */arg:function(){return Math.atan2(this.im,this.re)},/**
     * Calculate the sine of the complex number
     *
     * @returns {Complex}
     */sin:function(){// sin(z) = ( e^iz - e^-iz ) / 2i 
//        = sin(a)cosh(b) + i cos(a)sinh(b)
var e=this.re,n=this.im;return new u(Math.sin(e)*t(n),Math.cos(e)*r(n))},/**
     * Calculate the cosine
     *
     * @returns {Complex}
     */cos:function(){// cos(z) = ( e^iz + e^-iz ) / 2 
//        = cos(a)cosh(b) - i sin(a)sinh(b)
var e=this.re,n=this.im;return new u(Math.cos(e)*t(n),-Math.sin(e)*r(n))},/**
     * Calculate the tangent
     *
     * @returns {Complex}
     */tan:function(){// tan(z) = sin(z) / cos(z) 
//        = ( e^iz - e^-iz ) / ( i( e^iz + e^-iz ) )
//        = ( e^2iz - 1 ) / i( e^2iz + 1 )
//        = ( sin(2a) + i sinh(2b) ) / ( cos(2a) + cosh(2b) )
var e=2*this.re,n=2*this.im,i=Math.cos(e)+t(n);return new u(Math.sin(e)/i,r(n)/i)},/**
     * Calculate the cotangent
     *
     * @returns {Complex}
     */cot:function(){// cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))
var e=2*this.re,n=2*this.im,i=Math.cos(e)-t(n);return new u(-Math.sin(e)/i,r(n)/i)},/**
     * Calculate the secant
     *
     * @returns {Complex}
     */sec:function(){// sec(c) = 2 / (e^(ci) + e^(-ci))
var e=this.re,n=this.im,i=.5*t(2*n)+.5*Math.cos(2*e);return new u(Math.cos(e)*t(n)/i,Math.sin(e)*r(n)/i)},/**
     * Calculate the cosecans
     *
     * @returns {Complex}
     */csc:function(){// csc(c) = 2i / (e^(ci) - e^(-ci))
var e=this.re,n=this.im,i=.5*t(2*n)-.5*Math.cos(2*e);return new u(Math.sin(e)*t(n)/i,-Math.cos(e)*r(n)/i)},/**
     * Calculate the complex arcus sinus
     *
     * @returns {Complex}
     */asin:function(){// asin(c) = -i * log(ci + sqrt(1 - c^2))
var e=this.re,t=this.im,r=new u(t*t-e*e+1,-2*e*t).sqrt(),n=new u(r.re-t,r.im+e).log();return new u(n.im,-n.re)},/**
     * Calculate the complex arcus cosinus
     *
     * @returns {Complex}
     */acos:function(){// acos(c) = i * log(c - i * sqrt(1 - c^2))
var e=this.re,t=this.im,r=new u(t*t-e*e+1,-2*e*t).sqrt(),n=new u(r.re-t,r.im+e).log();return new u(Math.PI/2-n.im,n.re)},/**
     * Calculate the complex arcus tangent
     *
     * @returns {Complex}
     */atan:function(){// atan(c) = i / 2 log((i + x) / (i - x))
var e=this.re,t=this.im;if(0===e){if(1===t)return new u(0,1/0);if(-1===t)return new u(0,-1/0)}var r=e*e+(1-t)*(1-t),n=new u((1-t*t-e*e)/r,-2*e/r).log();return new u(-.5*n.im,.5*n.re)},/**
     * Calculate the complex arcus cotangent
     *
     * @returns {Complex}
     */acot:function(){// acot(c) = i / 2 log((c - i) / (c + i))
var e=this.re,t=this.im;if(0===t)return new u(Math.atan2(1,e),0);var r=e*e+t*t;return 0!==r?new u(e/r,-t/r).atan():new u(0!==e?e/0:0,0!==t?-t/0:0).atan()},/**
     * Calculate the complex arcus secant
     *
     * @returns {Complex}
     */asec:function(){// asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))
var e=this.re,t=this.im;if(0===e&&0===t)return new u(0,1/0);var r=e*e+t*t;return 0!==r?new u(e/r,-t/r).acos():new u(0!==e?e/0:0,0!==t?-t/0:0).acos()},/**
     * Calculate the complex arcus cosecans
     *
     * @returns {Complex}
     */acsc:function(){// acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))
var e=this.re,t=this.im;if(0===e&&0===t)return new u(Math.PI/2,1/0);var r=e*e+t*t;return 0!==r?new u(e/r,-t/r).asin():new u(0!==e?e/0:0,0!==t?-t/0:0).asin()},/**
     * Calculate the complex sinh
     *
     * @returns {Complex}
     */sinh:function(){// sinh(c) = (e^c - e^-c) / 2
var e=this.re,n=this.im;return new u(r(e)*Math.cos(n),t(e)*Math.sin(n))},/**
     * Calculate the complex cosh
     *
     * @returns {Complex}
     */cosh:function(){// cosh(c) = (e^c + e^-c) / 2
var e=this.re,n=this.im;return new u(t(e)*Math.cos(n),r(e)*Math.sin(n))},/**
     * Calculate the complex tanh
     *
     * @returns {Complex}
     */tanh:function(){// tanh(c) = (e^c - e^-c) / (e^c + e^-c)
var e=2*this.re,n=2*this.im,i=t(e)+Math.cos(n);return new u(r(e)/i,Math.sin(n)/i)},/**
     * Calculate the complex coth
     *
     * @returns {Complex}
     */coth:function(){// coth(c) = (e^c + e^-c) / (e^c - e^-c)
var e=2*this.re,n=2*this.im,i=t(e)-Math.cos(n);return new u(r(e)/i,-Math.sin(n)/i)},/**
     * Calculate the complex coth
     *
     * @returns {Complex}
     */csch:function(){// csch(c) = 2 / (e^c - e^-c)
var e=this.re,n=this.im,i=Math.cos(2*n)-t(2*e);return new u(-2*r(e)*Math.cos(n)/i,2*t(e)*Math.sin(n)/i)},/**
     * Calculate the complex sech
     *
     * @returns {Complex}
     */sech:function(){// sech(c) = 2 / (e^c + e^-c)
var e=this.re,n=this.im,i=Math.cos(2*n)+t(2*e);return new u(2*t(e)*Math.cos(n)/i,-2*r(e)*Math.sin(n)/i)},/**
     * Calculate the complex asinh
     *
     * @returns {Complex}
     */asinh:function(){// asinh(c) = log(c + sqrt(c^2 + 1))
var e=this.im;this.im=-this.re,this.re=e;var t=this.asin();return this.re=-this.im,this.im=e,e=t.re,t.re=-t.im,t.im=e,t},/**
     * Calculate the complex acosh
     *
     * @returns {Complex}
     */acosh:function(){// acosh(c) = log(c + sqrt(c^2 - 1))
var e=this.acos();if(e.im<=0){var t=e.re;e.re=-e.im,e.im=t}else{var t=e.im;e.im=-e.re,e.re=t}return e},/**
     * Calculate the complex atanh
     *
     * @returns {Complex}
     */atanh:function(){// atanh(c) = log((1+c) / (1-c)) / 2
var e=this.re,t=this.im,r=1-e,n=1+e,i=r*r+t*t,a=0!==i?new u((n*r-t*t)/i,(t*r+n*t)/i):new u(-1!==e?e/0:0,0!==t?t/0:0),s=a.re;return a.re=o(a.re,a.im)/2,a.im=Math.atan2(a.im,s)/2,e>1&&0===t&&(a.im=-a.im),a},/**
     * Calculate the complex acoth
     *
     * @returns {Complex}
     */acoth:function(){// acoth(c) = log((c+1) / (c-1)) / 2
var e=this.re,t=this.im;if(0===e&&0===t)return new u(0,Math.PI/2);var r=e*e+t*t;return 0!==r?new u(e/r,-t/r).atanh():new u(0!==e?e/0:0,0!==t?-t/0:0).atanh()},/**
     * Calculate the complex acsch
     *
     * @returns {Complex}
     */acsch:function(){// acsch(c) = log((1+sqrt(1+c^2))/c)
var e=this.re,t=this.im;if(0===t)return new u(0!==e?Math.log(e+Math.sqrt(e*e+1)):1/0,0);var r=e*e+t*t;return 0!==r?new u(e/r,-t/r).asinh():new u(0!==e?e/0:0,0!==t?-t/0:0).asinh()},/**
     * Calculate the complex asech
     *
     * @returns {Complex}
     */asech:function(){// asech(c) = log((1+sqrt(1-c^2))/c)
var e=this.re,t=this.im;if(this.isZero())return u.INFINITY;var r=e*e+t*t;return 0!==r?new u(e/r,-t/r).acosh():new u(0!==e?e/0:0,0!==t?-t/0:0).acosh()},/**
     * Calculate the complex inverse 1/z
     *
     * @returns {Complex}
     */inverse:function(){// 1 / 0 = Infinity and 1 / Infinity = 0
if(this.isZero())return u.INFINITY;if(this.isInfinite())return u.ZERO;var e=this.re,t=this.im,r=e*e+t*t;return new u(e/r,-t/r)},/**
     * Returns the complex conjugate
     *
     * @returns {Complex}
     */conjugate:function(){return new u(this.re,-this.im)},/**
     * Gets the negated complex number
     *
     * @returns {Complex}
     */neg:function(){return new u(-this.re,-this.im)},/**
     * Ceils the actual complex number
     *
     * @returns {Complex}
     */ceil:function(e){return e=Math.pow(10,e||0),new u(Math.ceil(this.re*e)/e,Math.ceil(this.im*e)/e)},/**
     * Floors the actual complex number
     *
     * @returns {Complex}
     */floor:function(e){return e=Math.pow(10,e||0),new u(Math.floor(this.re*e)/e,Math.floor(this.im*e)/e)},/**
     * Ceils the actual complex number
     *
     * @returns {Complex}
     */round:function(e){return e=Math.pow(10,e||0),new u(Math.round(this.re*e)/e,Math.round(this.im*e)/e)},/**
     * Compares two complex numbers
     *
     * **Note:** new Complex(Infinity).equals(Infinity) === false
     *
     * @returns {boolean}
     */equals:function(e,t){var r=new u(e,t);return Math.abs(r.re-this.re)<=u.EPSILON&&Math.abs(r.im-this.im)<=u.EPSILON},/**
     * Clones the actual object
     *
     * @returns {Complex}
     */clone:function(){return new u(this.re,this.im)},/**
     * Gets a string of the actual complex number
     *
     * @returns {string}
     */toString:function(){var e=this.re,t=this.im,r="";return this.isNaN()?"NaN":this.isInfinite()?"Infinity":(Math.abs(e)<u.EPSILON&&(e=0),Math.abs(t)<u.EPSILON&&(t=0),0===t)?r+e:(0!==e?(r+=e+" ",t<0?(t=-t,r+="-"):r+="+",r+=" "):t<0&&(t=-t,r+="-"),1!==t&&(r+=t),r+"i")},/**
     * Returns the actual number as a vector
     *
     * @returns {Array}
     */toVector:function(){return[this.re,this.im]},/**
     * Returns the actual real value of the current object
     *
     * @returns {number|null}
     */valueOf:function(){return 0===this.im?this.re:null},/**
     * Determines whether a complex number is not on the Riemann sphere.
     *
     * @returns {boolean}
     */isNaN:function(){return isNaN(this.re)||isNaN(this.im)},/**
     * Determines whether or not a complex number is at the zero pole of the
     * Riemann sphere.
     *
     * @returns {boolean}
     */isZero:function(){return 0===this.im&&0===this.re},/**
     * Determines whether a complex number is not at the infinity pole of the
     * Riemann sphere.
     *
     * @returns {boolean}
     */isFinite:function(){return isFinite(this.re)&&isFinite(this.im)},/**
     * Determines whether or not a complex number is at the infinity pole of the
     * Riemann sphere.
     *
     * @returns {boolean}
     */isInfinite:function(){return!(this.isNaN()||this.isFinite())}},u.ZERO=new u(0,0),u.ONE=new u(1,0),u.I=new u(0,1),u.PI=new u(Math.PI,0),u.E=new u(Math.E,0),u.INFINITY=new u(1/0,1/0),u.NAN=new u(NaN,NaN),u.EPSILON=1e-15,"function"==typeof define&&define.amd?define([],function(){return u}):(Object.defineProperty(u,"__esModule",{value:!0}),u.default=u,u.Complex=u,oQ=u)}(0);var oK=ta("Complex",[],()=>(/**
   * Attach type information
   */Object.defineProperty(/*@__PURE__*/e(oQ),"name",{value:"Complex"}),/*@__PURE__*/e(oQ).prototype.constructor=/*@__PURE__*/e(oQ),/*@__PURE__*/e(oQ).prototype.type="Complex",/*@__PURE__*/e(oQ).prototype.isComplex=!0,/*@__PURE__*/e(oQ).prototype.toJSON=function(){return{mathjs:"Complex",re:this.re,im:this.im}},/*@__PURE__*/e(oQ).prototype.toPolar=function(){return{r:this.abs(),phi:this.arg()}},/*@__PURE__*/e(oQ).prototype.format=function(e){var t=this.im,r=this.re,n=eD(this.re,e),i=eD(this.im,e),a=l(e)?e:e?e.precision:null;if(null!==a){var o=Math.pow(10,-a);Math.abs(r/t)<o&&(r=0),Math.abs(t/r)<o&&(t=0)}return 0===t?n:0===r?1===t?"i":-1===t?"-i":i+"i":t<0?-1===t?n+" - i":n+" - "+i.substring(1)+"i":1===t?n+" + i":n+" + "+i+"i"},/*@__PURE__*/e(oQ).fromPolar=function(t){switch(arguments.length){case 1:var r=arguments[0];if("object"==typeof r)return /*@__PURE__*/e(oQ)(r);throw TypeError("Input has to be an object with r and phi keys.");case 2:var n=arguments[0],i=arguments[1];if(l(n)){if(m(i)&&i.hasBase("ANGLE")&&(i=i.toNumber("rad")),l(i))return new/*@__PURE__*/(e(oQ))({r:n,phi:i});throw TypeError("Phi is not a number nor an angle unit.")}throw TypeError("Radius r is not a number.");default:throw SyntaxError("Wrong number of arguments in function fromPolar")}},/*@__PURE__*/e(oQ).prototype.valueOf=/*@__PURE__*/e(oQ).prototype.toString,/*@__PURE__*/e(oQ).fromJSON=function(t){return new/*@__PURE__*/(e(oQ))(t)},/*@__PURE__*/e(oQ).compare=function(e,t){return e.re>t.re?1:e.re<t.re?-1:e.im>t.im?1:e.im<t.im?-1:0},/*@__PURE__*/e(oQ)),{isClass:!0}),o0="composition",o1=ta(o0,["typed","addScalar","combinations","isNegative","isPositive","isInteger","larger"],e=>{var{typed:t,addScalar:r,combinations:n,isPositive:i,isNegative:a,isInteger:o,larger:s}=e;/**
   * The composition counts of n into k parts.
   *
   * composition only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   * Syntax:
   *
   *   math.composition(n, k)
   *
   * Examples:
   *
   *    math.composition(5, 3) // returns 6
   *
   * See also:
   *
   *    combinations
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @param {Number | BigNumber} k    Number of objects in the subset
   * @return {Number | BigNumber}     Returns the composition counts of n into k parts.
   */return t(o0,{"number | BigNumber, number | BigNumber":function(e,t){if(o(e)&&i(e)&&o(t)&&i(t)){if(s(t,e))throw TypeError("k must be less than or equal to n in function composition")}else throw TypeError("Positive integer value expected in function composition");return n(r(e,-1),r(t,-1))}})}),o2="conj",o3=ta(o2,["typed"],e=>{var{typed:t}=e;/**
   * Compute the complex conjugate of a complex value.
   * If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.conj(x)
   *
   * Examples:
   *
   *    math.conj(math.complex('2 + 3i'))  // returns Complex 2 - 3i
   *    math.conj(math.complex('2 - 3i'))  // returns Complex 2 + 3i
   *    math.conj(math.complex('-5.2i'))  // returns Complex 5.2i
   *
   * See also:
   *
   *    re, im, arg, abs
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            The complex conjugate of x
   */return t(o2,{"number | BigNumber | Fraction":e=>e,Complex:e=>e.conjugate(),"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),o4="corr",o5=ta(o4,["typed","matrix","mean","sqrt","sum","add","subtract","multiply","pow","divide"],e=>{var{typed:t,matrix:r,sqrt:n,sum:i,add:a,subtract:o,multiply:s,pow:u,divide:l}=e;/**
   * Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.
   *
   * Syntax:
   *
   *     math.corr(A, B)
   *
   * Examples:
   *
   *     math.corr([1, 2, 3, 4, 5], [4, 5, 6, 7, 8])     // returns 1
   *     math.corr([1, 2.2, 3, 4.8, 5], [4, 5.3, 6.6, 7, 8])     //returns 0.9569941688503644
   *     math.corr([[1, 2.2, 3, 4.8, 5], [4, 5.3, 6.6, 7, 8]],[[1, 2.2, 3, 4.8, 5], [4, 5.3, 6.6, 7, 8]])   // returns [1,1]
   *
   * See also:
   *
   *     median, mean, min, max, sum, prod, std, variance
   *
   * @param {Array | Matrix} A The first array or matrix to compute correlation coefficient
   * @param {Array | Matrix} B The second array or matrix to compute correlation coefficient
   * @return {*} The correlation coefficient
   */return t(o4,{"Array, Array":function(e,t){return c(e,t)},"Matrix, Matrix":function(e,t){var n=c(e.toArray(),t.toArray());return Array.isArray(n)?r(n):n}});/**
   * Calculate the correlation coefficient between two arrays or matrices.
   * @param {Array | Matrix} A
   * @param {Array | Matrix} B
   * @return {*} correlation coefficient
   * @private
   */function c(e,t){var r=[];if(Array.isArray(e[0])&&Array.isArray(t[0])){if(e.length!==t.length)throw SyntaxError("Dimension mismatch. Array A and B must have the same length.");for(var n=0;n<e.length;n++){if(e[n].length!==t[n].length)throw SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");r.push(f(e[n],t[n]))}return r}if(e.length!==t.length)throw SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");return f(e,t)}function f(e,t){var r=e.length,c=i(e),f=i(t),p=e.reduce((e,r,n)=>a(e,s(r,t[n])),0),m=i(e.map(e=>u(e,2))),d=i(t.map(e=>u(e,2)));return l(o(s(r,p),s(c,f)),n(s(o(s(r,m),u(c,2)),o(s(r,d),u(f,2)))))}}),o8=ta("trigUnit",["typed"],e=>{var{typed:t}=e;return{Unit:t.referToSelf(e=>r=>{if(!r.hasBase(r.constructor.BASE_UNITS.ANGLE))throw TypeError("Unit in function cot is no angle");return t.find(e,r.valueType())(r.value)})}}),o6=ta("cos",["typed"],e=>{var{typed:t}=e,r=o8({typed:t});/**
   * Calculate the cosine of a value.
   *
   * To avoid confusion with the matrix cosine, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.cos(x)
   *
   * Examples:
   *
   *    math.cos(2)                      // returns number -0.4161468365471422
   *    math.cos(math.pi / 4)            // returns number  0.7071067811865475
   *    math.cos(math.unit(180, 'deg'))  // returns number -1
   *    math.cos(math.unit(60, 'deg'))   // returns number  0.5
   *
   *    const angle = 0.2
   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number ~1
   *
   * See also:
   *
   *    cos, tan
   *
   * @param {number | BigNumber | Complex | Unit} x  Function input
   * @return {number | BigNumber | Complex} Cosine of x
   */return t("cos",{number:Math.cos,"Complex | BigNumber":e=>e.cos()},r)}),o7="cosh",o9=ta(o7,["typed"],e=>{var{typed:t}=e;/**
   * Calculate the hyperbolic cosine of a value,
   * defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
   *
   * To avoid confusion with the matrix hyperbolic cosine, this function does
   * not apply to matrices.
   *
   * Syntax:
   *
   *    math.cosh(x)
   *
   * Examples:
   *
   *    math.cosh(0.5)       // returns number 1.1276259652063807
   *
   * See also:
   *
   *    sinh, tanh
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic cosine of x
   */return t(o7,{number:ez,"Complex | BigNumber":e=>e.cosh()})}),se=ta("cot",["typed","BigNumber"],e=>{var{typed:t,BigNumber:r}=e,n=o8({typed:t});/**
   * Calculate the cotangent of a value. Defined as `cot(x) = 1 / tan(x)`.
   *
   * To avoid confusion with the matrix cotangent, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.cot(x)
   *
   * Examples:
   *
   *    math.cot(2)      // returns number -0.45765755436028577
   *    1 / math.tan(2)  // returns number -0.45765755436028577
   *
   * See also:
   *
   *    tan, sec, csc
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Cotangent of x
   */return t("cot",{number:id,Complex:e=>e.cot(),BigNumber:e=>new r(1).div(e.tan())},n)}),st="coth",sr=ta(st,["typed","BigNumber"],e=>{var{typed:t,BigNumber:r}=e;/**
   * Calculate the hyperbolic cotangent of a value,
   * defined as `coth(x) = 1 / tanh(x)`.
   *
   * To avoid confusion with the matrix hyperbolic cotangent, this function
   * does not apply to matrices.
   *
   * Syntax:
   *
   *    math.coth(x)
   *
   * Examples:
   *
   *    // coth(x) = 1 / tanh(x)
   *    math.coth(2)         // returns 1.0373147207275482
   *    1 / math.tanh(2)     // returns 1.0373147207275482
   *
   * See also:
   *
   *    sinh, tanh, cosh
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic cotangent of x
   */return t(st,{number:ih,Complex:e=>e.coth(),BigNumber:e=>new r(1).div(e.tanh())})}),sn="count",si=ta(sn,["typed","size","prod"],e=>{var{typed:t,size:r,prod:n}=e;/**
   * Count the number of elements of a matrix, array or string.
   *
   * Syntax:
   *
   *     math.count(x)
   *
   * Examples:
   *
   *     math.count('hello world')        // returns 11
   *     const A = [[1, 2, 3], [4, 5, 6]]
   *     math.count(A)                    // returns 6
   *     math.count(math.range(1,6))      // returns 5
   *
   * See also:
   *
   *     size
   *
   * @param {string | Array | Matrix} x  A matrix or string
   * @return {number} An integer with the elements in `x`.
   */return t(sn,{string:function(e){return e.length},"Matrix | Array":function(e){return n(r(e))}})}),sa="createUnit",so=ta(sa,["typed","Unit"],e=>{var{typed:t,Unit:r}=e;/**
   * Create a user-defined unit and register it with the Unit type.
   *
   * Syntax:
   *
   *     math.createUnit({
   *       baseUnit1: {
   *         aliases: [string, ...]
   *         prefixes: object
   *       },
   *       unit2: {
   *         definition: string,
   *         aliases: [string, ...]
   *         prefixes: object,
   *         offset: number
   *       },
   *       unit3: string    // Shortcut
   *     })
   *
   *     // Another shortcut:
   *     math.createUnit(string, unit : string, [object])
   *
   * Examples:
   *
   *     math.createUnit('foo')
   *     math.createUnit('knot', {definition: '0.514444444 m/s', aliases: ['knots', 'kt', 'kts']})
   *     math.createUnit('mph', '1 mile/hour')
   *     math.createUnit('km', math.unit(1000, 'm'))
   *
   * @param {string} name      The name of the new unit. Must be unique. Example: 'knot'
   * @param {string, UnitDefinition, Unit} definition      Definition of the unit in terms of existing units. For example, '0.514444444 m / s'.
   * @param {Object} options   (optional) An object containing any of the following properties:
   *     - `prefixes {string}` "none", "short", "long", "binary_short", or "binary_long". The default is "none".
   *     - `aliases {Array}` Array of strings. Example: ['knots', 'kt', 'kts']
   *     - `offset {Numeric}` An offset to apply when converting from the unit. For example, the offset for celsius is 273.15. Default is 0.
   *
   * See also:
   *
   *     unit
   *
   * @return {Unit} The new unit
   */return t(sa,{// General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
"Object, Object":function(e,t){return r.createUnit(e,t)},// Same as above but without the options.
Object:function(e){return r.createUnit(e,{})},// Shortcut method for creating one unit.
"string, Unit | string | Object, Object":function(e,t,n){var i={};return i[e]=t,r.createUnit(i,n)},// Same as above but without the options.
"string, Unit | string | Object":function(e,t){var n={};return n[e]=t,r.createUnit(n,{})},// Without a definition, creates a base unit.
string:function(e){var t={};return t[e]={},r.createUnit(t,{})}})}),ss="cross",su=ta(ss,["typed","matrix","subtract","multiply"],e=>{var{typed:t,matrix:r,subtract:n,multiply:i}=e;/**
   * Calculate the cross product for two vectors in three dimensional space.
   * The cross product of `A = [a1, a2, a3]` and `B = [b1, b2, b3]` is defined
   * as:
   *
   *    cross(A, B) = [
   *      a2 * b3 - a3 * b2,
   *      a3 * b1 - a1 * b3,
   *      a1 * b2 - a2 * b1
   *    ]
   *
   * If one of the input vectors has a dimension greater than 1, the output
   * vector will be a 1x3 (2-dimensional) matrix.
   *
   * Syntax:
   *
   *    math.cross(x, y)
   *
   * Examples:
   *
   *    math.cross([1, 1, 0],   [0, 1, 1])       // Returns [1, -1, 1]
   *    math.cross([3, -3, 1],  [4, 9, 2])       // Returns [-15, -2, 39]
   *    math.cross([2, 3, 4],   [5, 6, 7])       // Returns [-3, 6, -3]
   *    math.cross([[1, 2, 3]], [[4], [5], [6]]) // Returns [[-3, 6, -3]]
   *
   * See also:
   *
   *    dot, multiply
   *
   * @param  {Array | Matrix} x   First vector
   * @param  {Array | Matrix} y   Second vector
   * @return {Array | Matrix}     Returns the cross product of `x` and `y`
   */return t(ss,{"Matrix, Matrix":function(e,t){return r(a(e.toArray(),t.toArray()))},"Matrix, Array":function(e,t){return r(a(e.toArray(),t))},"Array, Matrix":function(e,t){return r(a(e,t.toArray()))},"Array, Array":a});/**
   * Calculate the cross product for two arrays
   * @param {Array} x  First vector
   * @param {Array} y  Second vector
   * @returns {Array} Returns the cross product of x and y
   * @private
   */function a(e,t){var r=Math.max(eG(e).length,eG(t).length);e=e1(e),t=e1(t);var a=eG(e),o=eG(t);if(1!==a.length||1!==o.length||3!==a[0]||3!==o[0])throw RangeError("Vectors with length 3 expected (Size A = ["+a.join(", ")+"], B = ["+o.join(", ")+"])");var s=[n(i(e[1],t[2]),i(e[2],t[1])),n(i(e[2],t[0]),i(e[0],t[2])),n(i(e[0],t[1]),i(e[1],t[0]))];return r>1?[s]:s}}),sl=ta("csc",["typed","BigNumber"],e=>{var{typed:t,BigNumber:r}=e,n=o8({typed:t});/**
   * Calculate the cosecant of a value, defined as `csc(x) = 1/sin(x)`.
   *
   * To avoid confusion with the matrix cosecant, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.csc(x)
   *
   * Examples:
   *
   *    math.csc(2)      // returns number 1.099750170294617
   *    1 / math.sin(2)  // returns number 1.099750170294617
   *
   * See also:
   *
   *    sin, sec, cot
   *
   * @param {number | BigNumber | Complex | Unit} x  Function input
   * @return {number | BigNumber | Complex} Cosecant of x
   */return t("csc",{number:ig,Complex:e=>e.csc(),BigNumber:e=>new r(1).div(e.sin())},n)}),sc="csch",sf=ta(sc,["typed","BigNumber"],e=>{var{typed:t,BigNumber:r}=e;/**
   * Calculate the hyperbolic cosecant of a value,
   * defined as `csch(x) = 1 / sinh(x)`.
   *
   * To avoid confusion with the matrix hyperbolic cosecant, this function
   * does not apply to matrices.
   *
   * Syntax:
   *
   *    math.csch(x)
   *
   * Examples:
   *
   *    // csch(x) = 1/ sinh(x)
   *    math.csch(0.5)       // returns 1.9190347513349437
   *    1 / math.sinh(0.5)   // returns 1.9190347513349437
   *
   * See also:
   *
   *    sinh, sech, coth
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic cosecant of x
   */return t(sc,{number:iy,Complex:e=>e.csch(),BigNumber:e=>new r(1).div(e.sinh())})}),sp="ctranspose",sm=ta(sp,["typed","transpose","conj"],e=>{var{typed:t,transpose:r,conj:n}=e;/**
   * Transpose and complex conjugate a matrix. All values of the matrix are
   * reflected over its main diagonal and then the complex conjugate is
   * taken. This is equivalent to complex conjugation for scalars and
   * vectors.
   *
   * Syntax:
   *
   *     math.ctranspose(x)
   *
   * Examples:
   *
   *     const A = [[1, 2, 3], [4, 5, math.complex(6,7)]]
   *     math.ctranspose(A)               // returns [[1, 4], [2, 5], [3, {re:6,im:7}]]
   *
   * See also:
   *
   *     transpose, diag, inv, subset, squeeze
   *
   * @param {Array | Matrix} x  Matrix to be ctransposed
   * @return {Array | Matrix}   The ctransposed matrix
   */return t(sp,{any:function(e){return n(r(e))}})}),sd="cube",sh=ta(sd,["typed"],e=>{var{typed:t}=e;/**
   * Compute the cube of a value, `x * x * x`.
   * To avoid confusion with `pow(M,3)`, this function does not apply to matrices.
   * If you wish to cube every entry of a matrix, see the examples.
   *
   * Syntax:
   *
   *    math.cube(x)
   *
   * Examples:
   *
   *    math.cube(2)            // returns number 8
   *    math.pow(2, 3)          // returns number 8
   *    math.cube(4)            // returns number 64
   *    4 * 4 * 4               // returns number 64
   *
   *    math.map([1, 2, 3, 4], math.cube) // returns Array [1, 8, 27, 64]
   *
   * See also:
   *
   *    multiply, square, pow, cbrt
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x  Number for which to calculate the cube
   * @return {number | BigNumber | Fraction | Complex | Unit} Cube of x
   */return t(sd,{number:n1,Complex:function(e){return e.mul(e).mul(e);// Is faster than pow(x, 3)
},BigNumber:function(e){return e.times(e).times(e)},Fraction:function(e){return e.pow(3);// Is faster than mul()mul()mul()
},Unit:function(e){return e.pow(3)}})}),sg="deepEqual",sy=ta(sg,["typed","equal"],e=>{var{typed:t,equal:r}=e;/**
   * Test element wise whether two matrices are equal.
   * The function accepts both matrices and scalar values.
   *
   * Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.deepEqual(x, y)
   *
   * Examples:
   *
   *    math.deepEqual(2, 4)   // returns false
   *
   *    a = [2, 5, 1]
   *    b = [2, 7, 1]
   *
   *    math.deepEqual(a, b)   // returns false
   *    math.equal(a, b)       // returns [true, false, true]
   *
   * See also:
   *
   *    equal, unequal
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First matrix to compare
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second matrix to compare
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
   *            Returns true when the input matrices have the same size and each of their elements is equal.
   */return t(sg,{"any, any":function(e,t){return(/**
   * Test whether two arrays have the same size and all elements are equal
   * @param {Array | *} x
   * @param {Array | *} y
   * @return {boolean} Returns true if both arrays are deep equal
   */function e(t,n){if(Array.isArray(t)){if(!Array.isArray(n))return!1;var i=t.length;if(i!==n.length)return!1;for(var a=0;a<i;a++)if(!e(t[a],n[a]))return!1;return!0}return!Array.isArray(n)&&r(t,n)}(e.valueOf(),t.valueOf()))}})});function sv(e){var{hasher:t,limit:r}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return r=null==r?Number.POSITIVE_INFINITY:r,t=null==t?JSON.stringify:t,function n(){if("object"!=typeof n.cache){var i,a,o,s,u,l,c;n.cache={values:new Map,lru:(i=r||Number.POSITIVE_INFINITY,a=0,o=1,s=Object.create(null),u=Object.create(null),l=0,c=function(e){var t=u[e];if(t&&(delete s[t],delete u[e],--a,o===t)){if(!a){l=0,o=1;return}for(;!Object.prototype.hasOwnProperty.call(s,++o););}},i=Math.abs(i),{hit:function(e){var t=u[e],r=++l;if(s[r]=e,u[e]=r,!t){if(++a<=i)return;return c(e=s[o]),e}if(delete s[t],o===t)for(;!Object.prototype.hasOwnProperty.call(s,++o););},delete:c,clear:function(){a=l=0,o=1,s=Object.create(null),u=Object.create(null)}})}}for(var f=[],p=0;p<arguments.length;p++)f[p]=arguments[p];var m=t(f);if(n.cache.values.has(m))return n.cache.lru.hit(m),n.cache.values.get(m);var d=e.apply(e,f);return n.cache.values.set(m,d),n.cache.values.delete(n.cache.lru.hit(m)),d}}function sx(e){return Object.keys(e.signatures||{}).reduce(function(e,t){return Math.max(e,(t.match(/,/g)||[]).length+1)},-1)}var sb=ta("DenseMatrix",["Matrix"],e=>{var{Matrix:t}=e;/**
   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
   * @class DenseMatrix
   * @enum {{ value, index: number[] }}
   */function r(e,t){if(!(this instanceof r))throw SyntaxError("Constructor must be called with the new operator");if(t&&!d(t))throw Error("Invalid datatype: "+t);if(g(e))// check data is a DenseMatrix
"DenseMatrix"===e.type?(// clone data & size
this._data=J(e._data),this._size=J(e._size)):(// build data from existing matrix
this._data=e.toArray(),this._size=e.size()),this._datatype=t||e._datatype;else if(e&&h(e.data)&&h(e.size))// initialize fields from JSON representation
this._data=e.data,this._size=e.size,eV(this._data,this._size),this._datatype=t||e.datatype;else if(h(e))// replace nested Matrices with Arrays
this._data=/**
   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and
   * Matrices. Clones all (nested) Arrays, and replaces all nested Matrices with Arrays
   * @memberof DenseMatrix
   * @param {Array | Matrix} data
   * @return {Array} data
   */function e(t){return g(t)?e(t.valueOf()):h(t)?t.map(e):t}(e),// get the dimensions of the array
this._size=eG(this._data),eV(this._data,this._size),// data type unknown
this._datatype=t;else if(e)throw TypeError("Unsupported type of data ("+Y(e)+")");else // nothing provided
this._data=[],this._size=[0],this._datatype=t}function n(e,t,r){// check size
if(0===t.length){// go deep
for(// first value in matrix
var n=e._data;h(n);)n=n[0];return n}// return matrix
return(// resize matrix
e._size=t.slice(0),e._data=eX(e._data,e._size,r),e)}/**
   * Enlarge the matrix when it is smaller than given size.
   * If the matrix is larger or equal sized, nothing is done.
   * @memberof DenseMatrix
   * @param {DenseMatrix} matrix           The matrix to be resized
   * @param {number[]} size
   * @param {*} defaultValue          Default value, filled in on new entries.
   * @private
   */function i(e,t,r){// add dimensions when needed
for(var i=e._size.slice(0),a=!1;i.length<t.length;)i.push(0),a=!0;// enlarge size when needed
for(var o=0,s=t.length;o<s;o++)t[o]>i[o]&&(i[o]=t[o],a=!0);a&&n(e,i,r)}return r.prototype=new t,/**
   * Create a new DenseMatrix
   */r.prototype.createDenseMatrix=function(e,t){return new r(e,t)},/**
   * Attach type information
   */Object.defineProperty(r,"name",{value:"DenseMatrix"}),r.prototype.constructor=r,r.prototype.type="DenseMatrix",r.prototype.isDenseMatrix=!0,/**
   * Get the matrix type
   *
   * Usage:
   *    const matrixType = matrix.getDataType()  // retrieves the matrix type
   *
   * @memberOf DenseMatrix
   * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
   */r.prototype.getDataType=function(){return tt(this._data,Y)},/**
   * Get the storage format used by the matrix.
   *
   * Usage:
   *     const format = matrix.storage()  // retrieve storage format
   *
   * @memberof DenseMatrix
   * @return {string}           The storage format.
   */r.prototype.storage=function(){return"dense"},/**
   * Get the datatype of the data stored in the matrix.
   *
   * Usage:
   *     const format = matrix.datatype()   // retrieve matrix datatype
   *
   * @memberof DenseMatrix
   * @return {string}           The datatype.
   */r.prototype.datatype=function(){return this._datatype},/**
   * Create a new DenseMatrix
   * @memberof DenseMatrix
   * @param {Array} data
   * @param {string} [datatype]
   */r.prototype.create=function(e,t){return new r(e,t)},/**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     const subset = matrix.subset(index)               // retrieve subset
   *     const value = matrix.subset(index, replacement)   // replace subset
   *
   * @memberof DenseMatrix
   * @param {Index} index
   * @param {Array | Matrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */r.prototype.subset=function(e,t,n){switch(arguments.length){case 1:return(/**
   * Get a submatrix of this matrix
   * @memberof DenseMatrix
   * @param {DenseMatrix} matrix
   * @param {Index} index   Zero-based index
   * @private
   */function(e,t){if(!N(t))throw TypeError("Invalid index");if(t.isScalar())return e.get(t.min());// validate dimensions
var n=t.size();if(n.length!==e._size.length)throw new eH(n.length,e._size.length);for(var i=t.min(),a=t.max(),o=0,s=e._size.length;o<s;o++)eY(i[o],e._size[o]),eY(a[o],e._size[o]);// retrieve submatrix
// TODO: more efficient when creating an empty matrix and setting _data and _size manually
return new r(/**
   * Recursively get a submatrix of a multi dimensional matrix.
   * Index is not checked for correct number or length of dimensions.
   * @memberof DenseMatrix
   * @param {Array} data
   * @param {Index} index
   * @param {number} dims   Total number of dimensions
   * @param {number} dim    Current dimension
   * @return {Array} submatrix
   * @private
   */function e(t,r,n,i){var a=i===n-1,o=r.dimension(i);return a?o.map(function(e){return eY(e,t.length),t[e]}).valueOf():o.map(function(a){return eY(a,t.length),e(t[a],r,n,i+1)}).valueOf()}(e._data,t,n.length,0),e._datatype)}(this,e));// intentional fall through
case 2:case 3:return(/**
   * Replace a submatrix in this matrix
   * Indexes are zero-based.
   * @memberof DenseMatrix
   * @param {DenseMatrix} matrix
   * @param {Index} index
   * @param {DenseMatrix | Array | *} submatrix
   * @param {*} defaultValue          Default value, filled in on new entries when
   *                                  the matrix is resized.
   * @return {DenseMatrix} matrix
   * @private
   */function(e,t,r,n){if(!t||!0!==t.isIndex)throw TypeError("Invalid index");// get index size and check whether the index contains a single value
var a,o=t.size(),s=t.isScalar();if(g(r)?(a=r.size(),r=r.valueOf()):a=eG(r),s){// set a scalar
// check whether submatrix is a scalar
if(0!==a.length)throw TypeError("Scalar expected");e.set(t.min(),r,n)}else{// set a submatrix
// broadcast submatrix
if(!Q(a,o))try{r=0===a.length?ti([r],o):ti(r,o),a=eG(r)}catch(e){}// validate dimensions
if(o.length<e._size.length)throw new eH(o.length,e._size.length,"<");if(a.length<o.length){for(// calculate number of missing outer dimensions
var u=0,l=0;1===o[u]&&1===a[u];)u++;for(;1===o[u];)l++,u++;// unsqueeze both outer and inner dimensions
r=e2(r,o.length,l,a)}// check whether the size of the submatrix matches the index size
if(!Q(o,a))throw new eH(o,a,">");i(e,t.max().map(function(e){return e+1}),n);// insert the sub matrix
var c=o.length;/**
   * Replace a submatrix of a multi dimensional matrix.
   * @memberof DenseMatrix
   * @param {Array} data
   * @param {Index} index
   * @param {Array} submatrix
   * @param {number} dims   Total number of dimensions
   * @param {number} dim
   * @private
   */(function e(t,r,n,i,a){var o=a===i-1,s=r.dimension(a);o?s.forEach(function(e,r){eY(e),t[e]=n[r[0]]}):s.forEach(function(o,s){eY(o),e(t[o],r,n[s[0]],i,a+1)})})(e._data,t,r,c,0)}return e}(this,e,t,n));default:throw SyntaxError("Wrong number of arguments")}},/**
   * Get a single element from the matrix.
   * @memberof DenseMatrix
   * @param {number[]} index   Zero-based index
   * @return {*} value
   */r.prototype.get=function(e){if(!h(e))throw TypeError("Array expected");if(e.length!==this._size.length)throw new eH(e.length,this._size.length);// check index
for(var t=0;t<e.length;t++)eY(e[t],this._size[t]);for(var r=this._data,n=0,i=e.length;n<i;n++){var a=e[n];eY(a,r.length),r=r[a]}return r},/**
   * Replace a single element in the matrix.
   * @memberof DenseMatrix
   * @param {number[]} index   Zero-based index
   * @param {*} value
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be left undefined.
   * @return {DenseMatrix} self
   */r.prototype.set=function(e,t,r){if(!h(e))throw TypeError("Array expected");if(e.length<this._size.length)throw new eH(e.length,this._size.length,"<");i(this,e.map(function(e){return e+1}),r);// traverse over the dimensions
var n,a,o,s=this._data;for(n=0,a=e.length-1;n<a;n++)eY(o=e[n],s.length),s=s[o];return eY(// set new value
o=e[e.length-1],s.length),s[o]=t,this},/**
   * Resize the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @memberof DenseMatrix
   * @param {number[] || Matrix} size The new size the matrix should have.
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix}                 The resized matrix
   */r.prototype.resize=function(e,t,r){// validate arguments
if(!y(e))throw TypeError("Array or Matrix expected");// SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector
var i=e.valueOf().map(e=>Array.isArray(e)&&1===e.length?e[0]:e);// resize matrix
return n(r?this.clone():this,i,t)},/**
   * Reshape the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (reshape in place).
   *
   * NOTE: This might be better suited to copy by default, instead of modifying
   *       in place. For now, it operates in place to remain consistent with
   *       resize().
   *
   * @memberof DenseMatrix
   * @param {number[]} size           The new size the matrix should have.
   * @param {boolean} [copy]          Return a reshaped copy of the matrix
   *
   * @return {Matrix}                 The reshaped matrix
   */r.prototype.reshape=function(e,t){var r=t?this.clone():this;r._data=eQ(r._data,e);var n=r._size.reduce((e,t)=>e*t);return r._size=eK(e,n),r},/**
   * Create a clone of the matrix
   * @memberof DenseMatrix
   * @return {DenseMatrix} clone
   */r.prototype.clone=function(){return new r({data:J(this._data),size:J(this._size),datatype:this._datatype})},/**
   * Retrieve the size of the matrix.
   * @memberof DenseMatrix
   * @returns {number[]} size
   */r.prototype.size=function(){return this._size.slice(0);// return a clone of _size
},/**
   * Create a new matrix with the results of the callback function executed on
   * each entry of the matrix.
   * @memberof DenseMatrix
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   *
   * @return {DenseMatrix} matrix
   */r.prototype.map=function(e){// matrix instance
var t=this,n=sx(e),i=function r(i,a){return h(i)?i.map(function(e,t){return r(e,a.concat(t))}):// invoke the callback function with the right number of arguments
1===n?e(i):2===n?e(i,a):e(i,a,t)}(this._data,[]),a=void 0!==this._datatype?tt(i,Y):void 0;return new r(i,a)},/**
   * Execute a callback function on each entry of the matrix.
   * @memberof DenseMatrix
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   */r.prototype.forEach=function(e){// matrix instance
var t=this;!function r(n,i){h(n)?n.forEach(function(e,t){r(e,i.concat(t))}):e(n,i,t)}(this._data,[])},/**
   * Iterate over the matrix elements
   * @return {Iterable<{ value, index: number[] }>}
   */r.prototype[Symbol.iterator]=function*(){var e=function* e(t,r){if(h(t))for(var n=0;n<t.length;n++)yield*e(t[n],r.concat(n));else yield{value:t,index:r}};yield*e(this._data,[])},/**
   * Returns an array containing the rows of a 2D matrix
   * @returns {Array<Matrix>}
   */r.prototype.rows=function(){var e=[];if(2!==this.size().length)throw TypeError("Rows can only be returned for a 2D matrix.");for(var t of this._data)e.push(new r([t],this._datatype));return e},/**
   * Returns an array containing the columns of a 2D matrix
   * @returns {Array<Matrix>}
   */r.prototype.columns=function(){var e=this,t=[],n=this.size();if(2!==n.length)throw TypeError("Rows can only be returned for a 2D matrix.");for(var i=this._data,a=function(n){var a=i.map(e=>[e[n]]);t.push(new r(a,e._datatype))},o=0;o<n[1];o++)a(o);return t},/**
   * Create an Array with a copy of the data of the DenseMatrix
   * @memberof DenseMatrix
   * @returns {Array} array
   */r.prototype.toArray=function(){return J(this._data)},/**
   * Get the primitive value of the DenseMatrix: a multidimensional array
   * @memberof DenseMatrix
   * @returns {Array} array
   */r.prototype.valueOf=function(){return this._data},/**
   * Get a string representation of the matrix, with optional formatting options.
   * @memberof DenseMatrix
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */r.prototype.format=function(e){return eP(this._data,e)},/**
   * Get a string representation of the matrix
   * @memberof DenseMatrix
   * @returns {string} str
   */r.prototype.toString=function(){return eP(this._data)},/**
   * Get a JSON representation of the matrix
   * @memberof DenseMatrix
   * @returns {Object}
   */r.prototype.toJSON=function(){return{mathjs:"DenseMatrix",data:this._data,size:this._size,datatype:this._datatype}},/**
   * Get the kth Matrix diagonal.
   *
   * @memberof DenseMatrix
   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
   *
   * @returns {Matrix}                     The matrix with the diagonal values.
   */r.prototype.diagonal=function(e){// validate k if any
if(e)// is must be an integer
{if(c(e)&&(e=e.toNumber()),!l(e)||!eh(e))throw TypeError("The parameter k must be an integer number")}else e=0;// loop rows
for(var t=e>0?e:0,n=e<0?-e:0,i=Math.min(this._size[0]-n,this._size[1]-t),a=[],o=0;o<i;o++)a[o]=this._data[o+n][o+t];// create DenseMatrix
return new r({data:a,size:[i],datatype:this._datatype})},/**
   * Create a diagonal matrix.
   *
   * @memberof DenseMatrix
   * @param {Array} size                     The matrix size.
   * @param {number | Matrix | Array } value The values for the diagonal.
   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.
   * @param {number} [defaultValue]          The default value for non-diagonal
   * @param {string} [datatype]              The datatype for the diagonal
   *
   * @returns {DenseMatrix}
   */r.diagonal=function(e,t,n,i){if(!h(e))throw TypeError("Array expected, size parameter");if(2!==e.length)throw Error("Only two dimensions matrix are supported");// validate k if any
if(// map size & validate
e=e.map(function(e){// validate arguments
if(c(e)&&(e=e.toNumber()),!l(e)||!eh(e)||e<1)throw Error("Size values must be positive integers");return e}),n)// is must be an integer
{if(c(n)&&(n=n.toNumber()),!l(n)||!eh(n))throw TypeError("The parameter k must be an integer number")}else n=0;var a,o=n>0?n:0,s=n<0?-n:0,u=e[0],f=e[1],p=Math.min(u-s,f-o);// check value
if(h(t)){// validate array
if(t.length!==p)throw Error("Invalid value array length");// define function
a=function(e){// return value @ i
return t[e]}}else if(g(t)){// matrix size
var m=t.size();// validate matrix
if(1!==m.length||m[0]!==p)throw Error("Invalid matrix length");// define function
a=function(e){// return value @ i
return t.get([e])}}else a=function(){// return value
return t};i||(i=c(a(0))?a(0).mul(0)// trick to create a BigNumber with value zero
:0);// empty array
var d=[];// check we need to resize array
if(e.length>0){// resize array
d=eX(d,e,i);// fill diagonal
for(var y=0;y<p;y++)d[y+s][y+o]=a(y)}// create DenseMatrix
return new r({data:d,size:[u,f]})},/**
   * Generate a matrix from a JSON object
   * @memberof DenseMatrix
   * @param {Object} json  An object structured like
   *                       `{"mathjs": "DenseMatrix", data: [], size: []}`,
   *                       where mathjs is optional
   * @returns {DenseMatrix}
   */r.fromJSON=function(e){return new r(e)},/**
   * Swap rows i and j in Matrix.
   *
   * @memberof DenseMatrix
   * @param {number} i       Matrix row index 1
   * @param {number} j       Matrix row index 2
   *
   * @return {Matrix}        The matrix reference
   */r.prototype.swapRows=function(e,t){// check index
if(!l(e)||!eh(e)||!l(t)||!eh(t))throw Error("Row index must be positive integers");// check dimensions
if(2!==this._size.length)throw Error("Only two dimensional matrix is supported");// return current instance
return eY(e,this._size[0]),eY(t,this._size[0]),// swap rows
r._swapRows(e,t,this._data),this},/**
   * Swap rows i and j in Dense Matrix data structure.
   *
   * @param {number} i       Matrix row index 1
   * @param {number} j       Matrix row index 2
   * @param {Array} data     Matrix data
   */r._swapRows=function(e,t,r){// swap values i <-> j
var n=r[e];r[e]=r[t],r[t]=n},r},{isClass:!0}),sN=ta("det",["typed","matrix","subtractScalar","multiply","divideScalar","isZero","unaryMinus"],e=>{var{typed:t,matrix:r,subtractScalar:n,multiply:i,divideScalar:a,isZero:o,unaryMinus:s}=e;/**
   * Calculate the determinant of a matrix.
   *
   * Syntax:
   *
   *    math.det(x)
   *
   * Examples:
   *
   *    math.det([[1, 2], [3, 4]]) // returns -2
   *
   *    const A = [
   *      [-2, 2, 3],
   *      [-1, 1, 3],
   *      [2, 0, -1]
   *    ]
   *    math.det(A) // returns 6
   *
   * See also:
   *
   *    inv
   *
   * @param {Array | Matrix} x  A matrix
   * @return {number} The determinant of `x`
   */return t("det",{any:function(e){return J(e)},"Array | Matrix":function(e){var t;switch((t=g(e)?e.size():Array.isArray(e)?(e=r(e)).size():[]).length){case 0:// scalar
return J(e);case 1:// vector
if(1===t[0])return J(e.valueOf()[0]);if(0===t[0])return 1;// det of an empty matrix is per definition 1
throw RangeError("Matrix must be square (size: "+eP(t)+")");case 2:// two-dimensional array
var u=t[0],l=t[1];if(u===l)return(/**
   * Calculate the determinant of a matrix
   * @param {Array[]} matrix  A square, two dimensional matrix
   * @param {number} rows     Number of rows of the matrix (zero-based)
   * @param {number} cols     Number of columns of the matrix (zero-based)
   * @returns {number} det
   * @private
   */function(e,t,r){if(1===t)return J(e[0][0]);if(2===t)// the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12
return n(i(e[0][0],e[1][1]),i(e[1][0],e[0][1]));for(var u=!1,l=Array(t).fill(0).map((e,t)=>t),c=0;c<t;c++){var f=l[c];if(o(e[f][c])){var p=void 0;for(p=c+1;p<t;p++)if(!o(e[l[p]][c])){f=l[p],l[p]=l[c],l[c]=f,u=!u;break}if(p===t)return e[f][c];// some zero of the type
}for(var m=e[f][c],d=0===c?1:e[l[c-1]][c-1],h=c+1;h<t;h++)for(var g=l[h],y=c+1;y<t;y++)e[g][y]=a(n(i(e[g][y],m),i(e[g][c],e[f][y])),d)}// Bareiss algorithm
// this algorithm have same complexity as LUP decomposition (O(n^3))
// but it preserve precision of floating point more relative to the LUP decomposition
var v=e[l[t-1]][t-1];return u?s(v):v}(e.clone().valueOf(),u,0));if(0===l)return 1;// det of an empty matrix is per definition 1
throw RangeError("Matrix must be square (size: "+eP(t)+")");default:// multi dimensional array
throw RangeError("Matrix must be two dimensional (size: "+eP(t)+")")}}})}),sw="diag",sD=ta(sw,["typed","matrix","DenseMatrix","SparseMatrix"],e=>{var{typed:t,matrix:r,DenseMatrix:n,SparseMatrix:i}=e;/**
   * Create a diagonal matrix or retrieve the diagonal of a matrix
   *
   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
   * When k is positive, the values are placed on the super diagonal.
   * When k is negative, the values are placed on the sub diagonal.
   *
   * Syntax:
   *
   *     math.diag(X)
   *     math.diag(X, format)
   *     math.diag(X, k)
   *     math.diag(X, k, format)
   *
   * Examples:
   *
   *     // create a diagonal matrix
   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]
   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]
   *
   *    // retrieve the diagonal from a matrix
   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
   *    math.diag(a)   // returns [1, 5, 9]
   *
   * See also:
   *
   *     ones, zeros, identity
   *
   * @param {Matrix | Array} x          A two dimensional matrix or a vector
   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled
   *                                    in or retrieved.
   * @param {string} [format='dense']   The matrix storage format.
   *
   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.
   */return t(sw,{// FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
Array:function(e){return a(e,0,eG(e),null)},"Array, number":function(e,t){return a(e,t,eG(e),null)},"Array, BigNumber":function(e,t){return a(e,t.toNumber(),eG(e),null)},"Array, string":function(e,t){return a(e,0,eG(e),t)},"Array, number, string":function(e,t,r){return a(e,t,eG(e),r)},"Array, BigNumber, string":function(e,t,r){return a(e,t.toNumber(),eG(e),r)},Matrix:function(e){return a(e,0,e.size(),e.storage())},"Matrix, number":function(e,t){return a(e,t,e.size(),e.storage())},"Matrix, BigNumber":function(e,t){return a(e,t.toNumber(),e.size(),e.storage())},"Matrix, string":function(e,t){return a(e,0,e.size(),t)},"Matrix, number, string":function(e,t,r){return a(e,t,e.size(),r)},"Matrix, BigNumber, string":function(e,t,r){return a(e,t.toNumber(),e.size(),r)}});/**
   * Creeate diagonal matrix from a vector or vice versa
   * @param {Array | Matrix} x
   * @param {number} k
   * @param {string} format Storage format for matrix. If null,
   *                          an Array is returned
   * @returns {Array | Matrix}
   * @private
   */function a(e,t,a,o){if(!eh(t))throw TypeError("Second parameter in function diag must be an integer");var s=t>0?t:0,u=t<0?-t:0;// check dimensions
switch(a.length){case 1:return function(e,t,r,a,o,s){// matrix size
var u=[a+o,a+s];if(r&&"sparse"!==r&&"dense"!==r)throw TypeError("Unknown matrix type ".concat(r,'"'));// create diagonal matrix
var l="sparse"===r?i.diagonal(u,e,t):n.diagonal(u,e,t);// check we need to return a matrix
return null!==r?l:l.valueOf()}(e,t,o,a[0],u,s);case 2:return function(e,t,n,i,a,o){// check x is a Matrix
if(g(e)){// get diagonal matrix
var s=e.diagonal(t);return(// check we need to return a matrix
null!==n?// check we need to change matrix format
n!==s.storage()?r(s,n):s:s.valueOf())}// loop diagonal
for(var u=Math.min(i[0]-a,i[1]-o),l=[],c=0;c<u;c++)l[c]=e[c+a][c+o];// check we need to return a matrix
return null!==n?r(l):l}(e,t,o,a,u,s)}throw RangeError("Matrix for function diag must be 2 dimensional")}}),sE="distance",sA=ta(sE,["typed","addScalar","subtractScalar","divideScalar","multiplyScalar","deepEqual","sqrt","abs"],e=>{var{typed:t,addScalar:r,subtractScalar:n,multiplyScalar:i,divideScalar:a,deepEqual:o,sqrt:s,abs:u}=e;/**
    * Calculates:
    *    The eucledian distance between two points in N-dimensional spaces.
    *    Distance between point and a line in 2 and 3 dimensional spaces.
    *    Pairwise distance between a set of 2D or 3D points
    * NOTE:
    *    When substituting coefficients of a line(a, b and c), use ax + by + c = 0 instead of ax + by = c
    *    For parametric equation of a 3D line, x0, y0, z0, a, b, c are from: (x−x0, y−y0, z−z0) = t(a, b, c)
    *
    * Syntax:
    *
    *    math.distance([x1,y1], [x2,y2])
    *    math.distance({pointOneX, pointOneY}, {pointTwoX, pointTwoY})
    *    math.distance([x1,y1,z1], [x2,y2,z2])
    *    math.distance({pointOneX, pointOneY, pointOneZ}, {pointTwoX, pointTwoY, pointTwoZ})
    *    math.distance([x1,y1,z1,a1], [x2,y2,z2,a2])
    *    math.distance([[x1,y1], [x2,y2], [x3,y3]])
    *    math.distance([[x1,y1,z1], [x2,y2,z2], [x3,y3,z3]])
    *    math.distance([pointX,pointY], [a,b,c])
    *    math.distance([pointX,pointY], [lineOnePtX,lineOnePtY], [lineTwoPtX,lineTwoPtY])
    *    math.distance({pointX, pointY}, {lineOnePtX, lineOnePtY}, {lineTwoPtX, lineTwoPtY})
    *    math.distance([pointX,pointY,pointZ], [x0, y0, z0, a, b, c])
    *    math.distance({pointX, pointY, pointZ}, {x0, y0, z0, a, b, c})
    *
    * Examples:
    *    math.distance([0,0], [4,4])                     // Returns 5.656854249492381
    *    math.distance(
    *     {pointOneX: 0, pointOneY: 0},
    *     {pointTwoX: 10, pointTwoY: 10})                // Returns 14.142135623730951
    *    math.distance([1, 0, 1], [4, -2, 2])            // Returns 3.7416573867739413
    *    math.distance(
    *     {pointOneX: 4, pointOneY: 5, pointOneZ: 8},
    *     {pointTwoX: 2, pointTwoY: 7, pointTwoZ: 9})    // Returns 3
    *    math.distance([1, 0, 1, 0], [0, -1, 0, -1])     // Returns 2
    *    math.distance([[1, 2], [1, 2], [1, 3]])         // Returns [0, 1, 1]
    *    math.distance([[1,2,4], [1,2,6], [8,1,3]])      // Returns [2, 7.14142842854285, 7.681145747868608]
    *    math.distance([10, 10], [8, 1, 3])              // Returns 11.535230316796387
    *    math.distance([0, 0], [3, 0], [0, 4])        // Returns 2.4
    *    math.distance(
    *     {pointX: 0, pointY: 0},
    *     {lineOnePtX: 3, lineOnePtY: 0},
    *     {lineTwoPtX: 0, lineTwoPtY: 4})                // Returns 2.4
    *    math.distance([2, 3, 1], [1, 1, 2, 5, 0, 1])    // Returns 2.3204774044612857
    *    math.distance(
    *     {pointX: 2, pointY: 3, pointZ: 1},
    *     {x0: 1, y0: 1, z0: 2, a: 5, b: 0, c: 1})       // Returns 2.3204774044612857
    *
    * @param {Array | Matrix | Object} x    Co-ordinates of first point
    * @param {Array | Matrix | Object} y    Co-ordinates of second point
    * @return {Number | BigNumber} Returns the distance from two/three points
  */return t(sE,{"Array, Array, Array":function(e,t,r){// Point to Line 2D (x=Point, y=LinePoint1, z=LinePoint2)
if(2===e.length&&2===t.length&&2===r.length){if(!f(e))throw TypeError("Array with 2 numbers or BigNumbers expected for first argument");if(!f(t))throw TypeError("Array with 2 numbers or BigNumbers expected for second argument");if(!f(r))throw TypeError("Array with 2 numbers or BigNumbers expected for third argument");if(o(t,r))throw TypeError("LinePoint1 should not be same with LinePoint2");var a=n(r[1],t[1]),s=n(t[0],r[0]),u=n(i(r[0],t[1]),i(t[0],r[1]));return g(e[0],e[1],a,s,u)}throw TypeError("Invalid Arguments: Try again")},"Object, Object, Object":function(e,t,r){if(2===Object.keys(e).length&&2===Object.keys(t).length&&2===Object.keys(r).length){if(!f(e))throw TypeError("Values of pointX and pointY should be numbers or BigNumbers");if(!f(t))throw TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");if(!f(r))throw TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");if(o(h(t),h(r)))throw TypeError("LinePoint1 should not be same with LinePoint2");if("pointX"in e&&"pointY"in e&&"lineOnePtX"in t&&"lineOnePtY"in t&&"lineTwoPtX"in r&&"lineTwoPtY"in r){var a=n(r.lineTwoPtY,t.lineOnePtY),s=n(t.lineOnePtX,r.lineTwoPtX),u=n(i(r.lineTwoPtX,t.lineOnePtY),i(t.lineOnePtX,r.lineTwoPtY));return g(e.pointX,e.pointY,a,s,u)}throw TypeError("Key names do not match")}throw TypeError("Invalid Arguments: Try again")},"Array, Array":function(e,t){// Point to Line 2D (x=[pointX, pointY], y=[x-coeff, y-coeff, const])
if(2===e.length&&3===t.length){if(!f(e))throw TypeError("Array with 2 numbers or BigNumbers expected for first argument");if(!p(t))throw TypeError("Array with 3 numbers or BigNumbers expected for second argument");return g(e[0],e[1],t[0],t[1],t[2])}if(3===e.length&&6===t.length){// Point to Line 3D
if(!p(e))throw TypeError("Array with 3 numbers or BigNumbers expected for first argument");if(!d(t))throw TypeError("Array with 6 numbers or BigNumbers expected for second argument");return y(e[0],e[1],e[2],t[0],t[1],t[2],t[3],t[4],t[5])}if(e.length===t.length&&e.length>0){// Point to Point N-dimensions
if(!m(e)||!m(t))throw TypeError("All values of an array should be numbers or BigNumbers");return v(e,t)}throw TypeError("Invalid Arguments: Try again")},"Object, Object":function(e,t){if(2===Object.keys(e).length&&3===Object.keys(t).length){if(!f(e))throw TypeError("Values of pointX and pointY should be numbers or BigNumbers");if(!p(t))throw TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");if("pointX"in e&&"pointY"in e&&"xCoeffLine"in t&&"yCoeffLine"in t&&"constant"in t)return g(e.pointX,e.pointY,t.xCoeffLine,t.yCoeffLine,t.constant);throw TypeError("Key names do not match")}if(3===Object.keys(e).length&&6===Object.keys(t).length){// Point to Line 3D
if(!p(e))throw TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");if(!d(t))throw TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");if("pointX"in e&&"pointY"in e&&"x0"in t&&"y0"in t&&"z0"in t&&"a"in t&&"b"in t&&"c"in t)return y(e.pointX,e.pointY,e.pointZ,t.x0,t.y0,t.z0,t.a,t.b,t.c);throw TypeError("Key names do not match")}if(2===Object.keys(e).length&&2===Object.keys(t).length){// Point to Point 2D
if(!f(e))throw TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");if(!f(t))throw TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");if("pointOneX"in e&&"pointOneY"in e&&"pointTwoX"in t&&"pointTwoY"in t)return v([e.pointOneX,e.pointOneY],[t.pointTwoX,t.pointTwoY]);throw TypeError("Key names do not match")}if(3===Object.keys(e).length&&3===Object.keys(t).length){// Point to Point 3D
if(!p(e))throw TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");if(!p(t))throw TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");if("pointOneX"in e&&"pointOneY"in e&&"pointOneZ"in e&&"pointTwoX"in t&&"pointTwoY"in t&&"pointTwoZ"in t)return v([e.pointOneX,e.pointOneY,e.pointOneZ],[t.pointTwoX,t.pointTwoY,t.pointTwoZ]);throw TypeError("Key names do not match")}throw TypeError("Invalid Arguments: Try again")},Array:function(e){if(!function(e){// checks for valid arguments passed to _distancePairwise(Array)
if(2===e[0].length&&l(e[0][0])&&l(e[0][1])){if(e.some(e=>2!==e.length||!l(e[0])||!l(e[1])))return!1}else if(!(3===e[0].length&&l(e[0][0])&&l(e[0][1])&&l(e[0][2])))return!1;else if(e.some(e=>3!==e.length||!l(e[0])||!l(e[1])||!l(e[2])))return!1;return!0}(e))throw TypeError("Incorrect array format entered for pairwise distance calculation");return function(e){for(var t=[],r=[],n=[],i=0;i<e.length-1;i++)for(var a=i+1;a<e.length;a++)2===e[0].length?(r=[e[i][0],e[i][1]],n=[e[a][0],e[a][1]]):3===e[0].length&&(r=[e[i][0],e[i][1],e[i][2]],n=[e[a][0],e[a][1],e[a][2]]),t.push(v(r,n));return t}(e)}});function l(e){// distance supports numbers and bignumbers
return"number"==typeof e||c(e)}function f(e){return e.constructor!==Array&&(e=h(e)),l(e[0])&&l(e[1])}function p(e){return e.constructor!==Array&&(e=h(e)),l(e[0])&&l(e[1])&&l(e[2])}function m(e){return Array.isArray(e)||(e=h(e)),e.every(l)}function d(e){return e.constructor!==Array&&(e=h(e)),l(e[0])&&l(e[1])&&l(e[2])&&l(e[3])&&l(e[4])&&l(e[5])}function h(e){for(var t=Object.keys(e),r=[],n=0;n<t.length;n++)r.push(e[t[n]]);return r}function g(e,t,n,o,l){return a(u(r(r(i(n,e),i(o,t)),l)),s(r(i(n,n),i(o,o))))}function y(e,t,o,u,l,c,f,p,m){var d=[n(i(n(l,t),m),i(n(c,o),p)),n(i(n(c,o),f),i(n(u,e),m)),n(i(n(u,e),p),i(n(l,t),f))];return a(d=s(r(r(i(d[0],d[0]),i(d[1],d[1])),i(d[2],d[2]))),s(r(r(i(f,f),i(p,p)),i(m,m))))}function v(e,t){for(var a=e.length,o=0,u=0,l=0;l<a;l++)o=r(i(u=n(e[l],t[l]),u),o);return s(o)}}),sS=ta("divide",["typed","matrix","multiply","equalScalar","divideScalar","inv"],e=>{var{typed:t,matrix:r,multiply:n,equalScalar:i,divideScalar:a,inv:o}=e,s=iL({typed:t,equalScalar:i}),u=iq({typed:t});/**
   * Divide two values, `x / y`.
   * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
   *
   * Syntax:
   *
   *    math.divide(x, y)
   *
   * Examples:
   *
   *    math.divide(2, 3)            // returns number 0.6666666666666666
   *
   *    const a = math.complex(5, 14)
   *    const b = math.complex(4, 1)
   *    math.divide(a, b)            // returns Complex 2 + 3i
   *
   *    const c = [[7, -6], [13, -4]]
   *    const d = [[1, 2], [4, 3]]
   *    math.divide(c, d)            // returns Array [[-9, 4], [-11, 6]]
   *
   *    const e = math.unit('18 km')
   *    math.divide(e, 4.5)          // returns Unit 4 km
   *
   * See also:
   *
   *    multiply
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x   Numerator
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} y          Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                      Quotient, `x / y`
   */return t("divide",X({// we extend the signatures of divideScalar with signatures dealing with matrices
"Array | Matrix, Array | Matrix":function(e,t){// TODO: implement matrix right division using pseudo inverse
// https://www.mathworks.nl/help/matlab/ref/mrdivide.html
// https://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html
// https://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour
return n(e,o(t))},"DenseMatrix, any":function(e,t){return u(e,t,a,!1)},"SparseMatrix, any":function(e,t){return s(e,t,a,!1)},"Array, any":function(e,t){// use matrix implementation
return u(r(e),t,a,!1).valueOf()},"any, Array | Matrix":function(e,t){return n(e,o(t))}},a.signatures))}),sC="divideScalar",sM=ta(sC,["typed","numeric"],e=>{var{typed:t,numeric:r}=e;/**
   * Divide two scalar values, `x / y`.
   * This function is meant for internal use: it is used by the public functions
   * `divide` and `inv`.
   *
   * This function does not support collections (Array or Matrix).
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   Numerator
   * @param  {number | BigNumber | Fraction | Complex} y          Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit}     Quotient, `x / y`
   * @private
   */return t(sC,{"number, number":function(e,t){return e/t},"Complex, Complex":function(e,t){return e.div(t)},"BigNumber, BigNumber":function(e,t){return e.div(t)},"Fraction, Fraction":function(e,t){return e.div(t)},"Unit, number | Complex | Fraction | BigNumber | Unit":(e,t)=>e.divide(t),"number | Fraction | Complex | BigNumber, Unit":(e,t)=>t.divideInto(e)})}),sF=ta("dot",["typed","addScalar","multiplyScalar","conj","size"],e=>{var{typed:t,addScalar:r,multiplyScalar:n,conj:i,size:a}=e;/**
   * Calculate the dot product of two vectors. The dot product of
   * `A = [a1, a2, ..., an]` and `B = [b1, b2, ..., bn]` is defined as:
   *
   *    dot(A, B) = conj(a1) * b1 + conj(a2) * b2 + ... + conj(an) * bn
   *
   * Syntax:
   *
   *    math.dot(x, y)
   *
   * Examples:
   *
   *    math.dot([2, 4, 1], [2, 2, 3])       // returns number 15
   *    math.multiply([2, 4, 1], [2, 2, 3])  // returns number 15
   *
   * See also:
   *
   *    multiply, cross
   *
   * @param  {Array | Matrix} x     First vector
   * @param  {Array | Matrix} y     Second vector
   * @return {number}               Returns the dot product of `x` and `y`
   */return t("dot",{"Array | DenseMatrix, Array | DenseMatrix":function(e,a){var u=o(e,a),l=g(e)?e._data:e,c=g(e)?e._datatype:void 0,f=g(a)?a._data:a,p=g(a)?a._datatype:void 0,m=2===s(e).length,d=2===s(a).length,h=r,y=n;// both vectors 1-dimensional
if(c&&p&&c===p&&"string"==typeof c&&(// find signatures that matches (dt, dt)
h=t.find(r,[c,c]),y=t.find(n,[c,c])),!m&&!d){for(var v=y(i(l[0]),f[0]),x=1;x<u;x++)v=h(v,y(i(l[x]),f[x]));return v}// a is 1-dim, b is column
if(!m&&d){for(var b=y(i(l[0]),f[0][0]),N=1;N<u;N++)b=h(b,y(i(l[N]),f[N][0]));return b}// a is column, b is 1-dim
if(m&&!d){for(var w=y(i(l[0][0]),f[0]),D=1;D<u;D++)w=h(w,y(i(l[D][0]),f[D]));return w}// both vectors are column
if(m&&d){for(var E=y(i(l[0][0]),f[0][0]),A=1;A<u;A++)E=h(E,y(i(l[A][0]),f[A][0]));return E}},"SparseMatrix, SparseMatrix":function(e,t){o(e,t);for(var i=e._index,a=e._values,s=t._index,u=t._values,l=0,c=0,f=0;c<i.length&&f<s.length;){var p=i[c],m=s[f];if(p<m){c++;continue}if(p>m){f++;continue}p===m&&(l=r(l,n(a[c],u[f])),c++,f++)}return l}});function o(e,t){var r,n,i=s(e),a=s(t);if(1===i.length)r=i[0];else if(2===i.length&&1===i[1])r=i[0];else throw RangeError("Expected a column vector, instead got a matrix of size ("+i.join(", ")+")");if(1===a.length)n=a[0];else if(2===a.length&&1===a[1])n=a[0];else throw RangeError("Expected a column vector, instead got a matrix of size ("+a.join(", ")+")");if(r!==n)throw RangeError("Vectors must have equal length ("+r+" != "+n+")");if(0===r)throw RangeError("Cannot calculate the dot product of empty vectors");return r}// TODO remove this once #1771 is fixed
function s(e){return g(e)?e.size():a(e)}}),sB="dotDivide",sT=ta(sB,["typed","matrix","equalScalar","divideScalar","DenseMatrix","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,divideScalar:i,DenseMatrix:a,concat:o}=e,s=iU({typed:t,equalScalar:n}),u=i5({typed:t}),l=ov({typed:t,DenseMatrix:a}),c=iL({typed:t,equalScalar:n}),f=i6({typed:t,DenseMatrix:a}),p=iI({typed:t,matrix:r,concat:o});/**
   * Divide two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotDivide(x, y)
   *
   * Examples:
   *
   *    math.dotDivide(2, 4)   // returns 0.5
   *
   *    a = [[9, 5], [6, 1]]
   *    b = [[3, 2], [5, 2]]
   *
   *    math.dotDivide(a, b)   // returns [[3, 2.5], [1.2, 0.5]]
   *    math.divide(a, b)      // returns [[1.75, 0.75], [-1.75, 2.25]]
   *
   * See also:
   *
   *    divide, multiply, dotMultiply
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Numerator
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Quotient, `x ./ y`
   */return t(sB,p({elop:i,SS:l,DS:u,SD:s,Ss:c,sS:f}))}),sO="dotMultiply",s_=ta(sO,["typed","matrix","equalScalar","multiplyScalar","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,multiplyScalar:i,concat:a}=e,o=iU({typed:t,equalScalar:n}),s=i8({typed:t,equalScalar:n}),u=iL({typed:t,equalScalar:n}),l=iI({typed:t,matrix:r,concat:a});/**
   * Multiply two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotMultiply(x, y)
   *
   * Examples:
   *
   *    math.dotMultiply(2, 4) // returns 8
   *
   *    a = [[9, 5], [6, 1]]
   *    b = [[3, 2], [5, 2]]
   *
   *    math.dotMultiply(a, b) // returns [[27, 10], [30, 2]]
   *    math.multiply(a, b)    // returns [[52, 28], [23, 14]]
   *
   * See also:
   *
   *    multiply, divide, dotDivide
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Left hand value
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Right hand value
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Multiplication of `x` and `y`
   */return t(sO,l({elop:i,SS:s,DS:o,Ss:u}))}),sz="dotPow",sq=ta(sz,["typed","equalScalar","matrix","pow","DenseMatrix","concat"],e=>{var{typed:t,equalScalar:r,matrix:n,pow:i,DenseMatrix:a,concat:o}=e,s=i5({typed:t}),u=ov({typed:t,DenseMatrix:a}),l=iL({typed:t,equalScalar:r}),c=i6({typed:t,DenseMatrix:a}),f=iI({typed:t,matrix:n,concat:o}),p={};for(var m in i.signatures)!Object.prototype.hasOwnProperty.call(i.signatures,m)||m.includes("Matrix")||m.includes("Array")||(p[m]=i.signatures[m]);var d=t(p);/**
   * Calculates the power of x to y element wise.
   *
   * Syntax:
   *
   *    math.dotPow(x, y)
   *
   * Examples:
   *
   *    math.dotPow(2, 3)            // returns number 8
   *
   *    const a = [[1, 2], [4, 3]]
   *    math.dotPow(a, 2)            // returns Array [[1, 4], [16, 9]]
   *    math.pow(a, 2)               // returns Array [[9, 8], [16, 17]]
   *
   * See also:
   *
   *    pow, sqrt, multiply
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y  The exponent
   * @return {number | BigNumber | Complex | Unit | Array | Matrix}                     The value of `x` to the power `y`
   */return t(sz,f({elop:d,SS:u,DS:s,Ss:l,sS:c}))}),sk=sv(function(e){return new e(1).exp()},{hasher:sj}),sI=sv(function(e){return new e(1).plus(new e(5).sqrt()).div(2)},{hasher:sj}),sR=sv(function(e){return e.acos(-1)},{hasher:sj}),sP=sv(function(e){return sR(e).times(2)},{hasher:sj});/**
 * Create a hash for a BigNumber constructor function. The created has is
 * the configured precision
 * @param {Array} args         Supposed to contain a single entry with
 *                             a BigNumber constructor
 * @return {number} precision
 * @private
 */function sj(e){return e[0].precision}var sU=Math.PI,sL=2*Math.PI,s$=Math.E,sH=ta("true",[],()=>!0),sZ=ta("false",[],()=>!1),sG=ta("null",[],()=>null),sV=/* #__PURE__ */s6("Infinity",["config","?BigNumber"],e=>{var{config:t,BigNumber:r}=e;return"BigNumber"===t.number?new r(1/0):1/0}),sW=/* #__PURE__ */s6("NaN",["config","?BigNumber"],e=>{var{config:t,BigNumber:r}=e;return"BigNumber"===t.number?new r(NaN):NaN}),sY=/* #__PURE__ */s6("pi",["config","?BigNumber"],e=>{var{config:t,BigNumber:r}=e;return"BigNumber"===t.number?sR(r):sU}),sJ=/* #__PURE__ */s6("tau",["config","?BigNumber"],e=>{var{config:t,BigNumber:r}=e;return"BigNumber"===t.number?sP(r):sL}),sX=/* #__PURE__ */s6("e",["config","?BigNumber"],e=>{var{config:t,BigNumber:r}=e;return"BigNumber"===t.number?sk(r):s$}),sQ=/* #__PURE__ */s6("phi",["config","?BigNumber"],e=>{var{config:t,BigNumber:r}=e;return"BigNumber"===t.number?sI(r):1.618033988749895}),sK=/* #__PURE__ */s6("LN2",["config","?BigNumber"],e=>{var{config:t,BigNumber:r}=e;return"BigNumber"===t.number?new r(2).ln():Math.LN2}),s0=/* #__PURE__ */s6("LN10",["config","?BigNumber"],e=>{var{config:t,BigNumber:r}=e;return"BigNumber"===t.number?new r(10).ln():Math.LN10}),s1=/* #__PURE__ */s6("LOG2E",["config","?BigNumber"],e=>{var{config:t,BigNumber:r}=e;return"BigNumber"===t.number?new r(1).div(new r(2).ln()):Math.LOG2E}),s2=/* #__PURE__ */s6("LOG10E",["config","?BigNumber"],e=>{var{config:t,BigNumber:r}=e;return"BigNumber"===t.number?new r(1).div(new r(10).ln()):Math.LOG10E}),s3=/* #__PURE__ */s6("SQRT1_2",["config","?BigNumber"],e=>{var{config:t,BigNumber:r}=e;return"BigNumber"===t.number?new r("0.5").sqrt():Math.SQRT1_2}),s4=/* #__PURE__ */s6("SQRT2",["config","?BigNumber"],e=>{var{config:t,BigNumber:r}=e;return"BigNumber"===t.number?new r(2).sqrt():Math.SQRT2}),s5=/* #__PURE__ */s6("i",["Complex"],e=>{var{Complex:t}=e;return t.I}),s8=ta("version",[],()=>"12.1.0");// helper function to create a factory with a flag recreateOnConfigChange
// idea: allow passing optional properties to be attached to the factory function as 4th argument?
function s6(e,t,r){return ta(e,t,r,{recreateOnConfigChange:!0})}var s7=ta("eigs",["config","typed","matrix","addScalar","equal","subtract","abs","atan","cos","sin","multiplyScalar","divideScalar","inv","bignumber","multiply","add","larger","column","flatten","number","complex","sqrt","diag","size","reshape","qr","usolve","usolveAll","im","re","smaller","matrixFromColumns","dot"],t=>{var{config:r,typed:n,matrix:i,addScalar:a,subtract:s,equal:u,abs:m,atan:d,cos:h,sin:g,multiplyScalar:y,divideScalar:v,inv:x,bignumber:b,multiply:N,add:w,larger:D,column:E,flatten:A,number:S,complex:C,sqrt:M,diag:F,size:B,reshape:T,qr:O,usolve:_,usolveAll:z,im:q,re:k,smaller:I,matrixFromColumns:R,dot:P}=t,j=function(e){var{config:t,addScalar:r,subtract:n,abs:i,atan:a,cos:o,sin:s,multiplyScalar:u,inv:l,bignumber:c,multiply:f,add:p}=e;// get max off-diagonal value from Upper Diagonal
function m(e){for(var t=e.length,r=0,n=[0,1],i=0;i<t;i++)for(var a=i+1;a<t;a++)Math.abs(r)<Math.abs(e[i][a])&&(r=Math.abs(e[i][a]),n=[i,a]);return[n,r]}// get max off-diagonal value from Upper Diagonal
function d(e){for(var t=e.length,r=0,n=[0,1],a=0;a<t;a++)for(var o=a+1;o<t;o++)i(r)<i(e[a][o])&&(r=i(e[a][o]),n=[a,o]);return[n,r]}// sort results
function h(e,t,r){var n,a=e.length,o=Array(a);if(r){n=Array(a);for(var s=0;s<a;s++)n[s]=Array(a)}for(var u=0;u<a;u++){for(var l=0,c=e[0],f=0;f<e.length;f++)i(e[f])<i(c)&&(c=e[l=f]);if(o[u]=e.splice(l,1)[0],r)for(var p=0;p<a;p++)n[u][p]=t[p][l],t[p].splice(l,1)}if(!r)return{values:o};var m=n.map((e,t)=>({value:o[t],vector:e}));return{values:o,eigenvectors:m}}return(/**
   * @param {number[] | BigNumber[]} arr
   * @param {number} N
   * @param {number} prec
   * @param {'number' | 'BigNumber'} type
   */function(e,g){var y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.epsilon,v=arguments.length>3?arguments[3]:void 0,x=arguments.length>4?arguments[4]:void 0;if("number"===v)return(// diagonalization implementation for number (efficient)
function(e,r,n){var i,a,o=e.length,s=Math.abs(r/o);if(n){a=Array(o);// Sij is Identity Matrix
for(var u=0;u<o;u++)a[u]=Array(o).fill(0),a[u][u]=1}for(// initial error
var l=m(e);Math.abs(l[1])>=Math.abs(s);){var c,f,p,d=l[0][0],g=l[0][1];c=e[d][d],f=e[g][g],p=e[d][g],e=// update matrix
function(e,t,r,n){// 0  to i
for(var i=e.length,a=Math.cos(t),o=Math.sin(t),s=a*a,u=o*o,l=Array(i).fill(0),c=Array(i).fill(0),f=s*e[r][r]-2*a*o*e[r][n]+u*e[n][n],p=u*e[r][r]+2*a*o*e[r][n]+s*e[n][n],m=0;m<i;m++)l[m]=a*e[r][m]-o*e[n][m],c[m]=o*e[r][m]+a*e[n][m];// Modify Hij
e[r][r]=f,e[n][n]=p,e[r][n]=0,e[n][r]=0;// 0  to i
for(var d=0;d<i;d++)d!==r&&d!==n&&(e[r][d]=l[d],e[d][r]=l[d],e[n][d]=c[d],e[d][n]=c[d]);return e}(e,i=Math.abs(f-c)<=t.epsilon?Math.PI/4:.5*Math.atan(2*p/(f-c)),d,g),n&&(a=// update eigvec
function(e,t,r,n){for(var i=e.length,a=Math.cos(t),o=Math.sin(t),s=Array(i).fill(0),u=Array(i).fill(0),l=0;l<i;l++)s[l]=a*e[l][r]-o*e[l][n],u[l]=o*e[l][r]+a*e[l][n];for(var c=0;c<i;c++)e[c][r]=s[c],e[c][n]=u[c];return e}(a,i,d,g)),l=m(e)}for(var y=Array(o).fill(0),v=0;v<o;v++)y[v]=e[v][v];return h(J(y),a,n)}(e,y,x));if("BigNumber"===v)return(// diagonalization implementation for bigNumber
function(e,m,g){var y,v,x=e.length,b=i(m/x);if(g){v=Array(x);// Sij is Identity Matrix
for(var N=0;N<x;N++)v[N]=Array(x).fill(0),v[N][N]=1}for(// initial error
var w=d(e);i(w[1])>=i(b);){var D=w[0][0],E=w[0][1];y=// get angle
function(e,r,o){var s=n(r,e);return i(s)<=t.epsilon?c(-1).acos().div(4):u(.5,a(f(2,o,l(s))))}(e[D][D],e[E][E],e[D][E]),e=// update matrix
function(e,t,i,a){// 0  to i
for(var l=e.length,m=c(o(t)),d=c(s(t)),h=u(m,m),g=u(d,d),y=Array(l).fill(c(0)),v=Array(l).fill(c(0)),x=f(c(2),m,d,e[i][a]),b=r(n(u(h,e[i][i]),x),u(g,e[a][a])),N=p(u(g,e[i][i]),x,u(h,e[a][a])),w=0;w<l;w++)y[w]=n(u(m,e[i][w]),u(d,e[a][w])),v[w]=r(u(d,e[i][w]),u(m,e[a][w]));// Modify Hij
e[i][i]=b,e[a][a]=N,e[i][a]=c(0),e[a][i]=c(0);// 0  to i
for(var D=0;D<l;D++)D!==i&&D!==a&&(e[i][D]=y[D],e[D][i]=y[D],e[a][D]=v[D],e[D][a]=v[D]);return e}(e,y,D,E),g&&(v=// update eigvec for overlap
function(e,t,i,a){for(var l=e.length,f=o(t),p=s(t),m=Array(l).fill(c(0)),d=Array(l).fill(c(0)),h=0;h<l;h++)m[h]=n(u(f,e[h][i]),u(p,e[h][a])),d[h]=r(u(p,e[h][i]),u(f,e[h][a]));for(var g=0;g<l;g++)e[g][i]=m[g],e[g][a]=d[g];return e}(v,y,D,E)),w=d(e)}for(var A=Array(x).fill(0),S=0;S<x;S++)A[S]=e[S][S];// return [clone(Ei), clone(Sij)]
return h(J(A),v,g)}(e,y,x));throw TypeError("Unsupported data type: "+v)})}({config:r,addScalar:a,subtract:s,column:E,flatten:A,equal:u,abs:m,atan:d,cos:h,sin:g,multiplyScalar:y,inv:x,bignumber:b,complex:C,multiply:N,add:w}),U=function(e){var{addScalar:t,subtract:r,flatten:n,multiply:i,multiplyScalar:a,divideScalar:o,sqrt:s,abs:u,bignumber:l,diag:c,size:f,reshape:p,inv:m,qr:d,usolve:h,usolveAll:g,equal:y,complex:v,larger:x,smaller:b,matrixFromColumns:N,dot:w}=e;/**
   * Enlarge the matrix from nxn to NxN, setting the new
   * elements to 1 on diagonal and 0 elsewhere
   */function D(e,t){// add columns
for(var r=0;r<e.length;r++)e[r].push(...Array(t-e[r].length).fill(0));// add rows
for(var n=e.length;n<t;n++)e.push(Array(t).fill(0)),e[n][n]=1;return e}/**
   * Project vector v to the orthogonal complement of an array of vectors
   */function E(e,t){var n=f(e);for(var a of t)// v := v − (w, v)/|w|^2 w
e=r(e,i(o(w(a=p(a,n),e),w(a,a)),a));return e}/**
   * Calculate the norm of a vector.
   * We can't use math.norm because factory can't handle circular dependency.
   * Seriously, I'm really fed up with factory.
   */function A(e){return u(s(w(e,e)))}/**
   * Normalize a vector
   * @template T
   * @param {T[]} v
   * @param {'number'|'BigNumber'|'Complex'} type
   * @returns {T[]} normalized vec
   */function S(e,t){return i(o("BigNumber"===t?l(1):"Complex"===t?v(1):1,A(e)),e)}return(/**
   * @param {number[][]} arr the matrix to find eigenvalues of
   * @param {number} N size of the matrix
   * @param {number|BigNumber} prec precision, anything lower will be considered zero
   * @param {'number'|'BigNumber'|'Complex'} type
   * @param {boolean} findVectors should we find eigenvectors?
   *
   * @returns {{ values: number[], vectors: number[][] }}
   */function(e,f,p,N){var w=!(arguments.length>4)||void 0===arguments[4]||arguments[4],C=/**
   * @param {number[][]} arr
   * @param {number} N
   * @param {number} prec
   * @param {'number'|'BigNumber'|'Complex'} type
   * @returns {number[][]}
   */function(e,r,n,i,s){var f,p="BigNumber"===i,m=p?l(0):0,d=p?l(1):"Complex"===i?v(1):1,h=p?l(1):1,g=p?l(10):2,N=a(g,g);s&&(f=Array(r).fill(d));for(// this isn't the only time we loop thru the matrix...
var w=!1;!w;){// ...haha I'm joking! unless...
w=!0;for(var D=0;D<r;D++){for(var E=m,A=m,S=0;S<r;S++)D!==S&&(E=t(E,u(e[S][D])),A=t(A,u(e[D][S])));if(!y(E,0)&&!y(A,0)){for(// find integer power closest to balancing the matrix
// (we want to scale only by integer powers of radix,
// so that we don't lose any precision due to round-off)
var C=h,M=E,F=o(A,g),B=a(A,g);b(M,F);)M=a(M,N),C=a(C,g);for(;x(M,B);)M=o(M,N),C=o(C,g);// apply balancing similarity transformation
if(b(o(t(M,A),C),a(t(E,A),.95))){// we should loop once again to check whether
// another rebalancing is needed
w=!1;for(var T=o(1,C),O=0;O<r;O++)D!==O&&(e[D][O]=a(e[D][O],T),e[O][D]=a(e[O][D],C));// keep track of transformations
s&&(f[D]=a(f[D],T))}}}}// return the diagonal row transformation matrix
return s?c(f):null}(e,f,0,N,w);// R is the row transformation matrix
// arr = A' = R A R^-1, A is the original matrix
// (if findVectors is false, R is undefined)
// (And so to return to original matrix: A = R^-1 arr R)
// TODO if magnitudes of elements vary over many orders,
// move greatest elements to the top left corner
// using similarity transformations, reduce the matrix
// to Hessenberg form (upper triangular plus one subdiagonal row)
// updates the transformation matrix R with new row operationsq
// MODIFIES arr by side effect!
!/**
   * @param {number[][]} arr
   * @param {number} N
   * @param {number} prec
   * @param {'number'|'BigNumber'|'Complex'} type
   * @param {boolean} findVectors
   * @param {number[][]} R the row transformation matrix that will be modified
   */function(e,n,i,s,c,f){var p="BigNumber"===s,m=p?l(0):"Complex"===s?v(0):0;p&&(i=l(i));for(var d=0;d<n-2;d++){for(var h=0,g=m,y=d+1;y<n;y++){var x=e[y][d];b(u(g),u(x))&&(g=x,h=y)}// This col is pivoted, no need to do anything
if(!b(u(g),i)){if(h!==d+1){// Interchange maxIndex-th and (i+1)-th row
var N=e[h];e[h]=e[d+1],e[d+1]=N;// Interchange maxIndex-th and (i+1)-th column
for(var w=0;w<n;w++){var D=e[w][h];e[w][h]=e[w][d+1],e[w][d+1]=D}// keep track of transformations
if(c){var E=f[h];f[h]=f[d+1],f[d+1]=E}}// Reduce following rows and columns
for(var A=d+2;A<n;A++){var S=o(e[A][d],g);if(0!==S){// from j-th row subtract n-times (i+1)th row
for(var C=0;C<n;C++)e[A][C]=r(e[A][C],a(S,e[d+1][C]));// to (i+1)th column add n-times j-th column
for(var M=0;M<n;M++)e[M][d+1]=t(e[M][d+1],a(S,e[M][A]));// keep track of transformations
if(c)for(var F=0;F<n;F++)f[A][F]=r(f[A][F],a(S,f[d+1][F]))}}}}}(e,f,p,N,w,C);// still true that original A = R^-1 arr R)
// find eigenvalues
var{values:M,C:F}=/**
   * @returns {{values: values, C: Matrix}}
   * @see Press, Wiliams: Numerical recipes in Fortran 77
   * @see https://en.wikipedia.org/wiki/QR_algorithm
   */function(e,n,o,f,p){var m="BigNumber"===f,h="Complex"===f,g=m?l(1):h?v(1):1;m&&(o=l(o));for(// The Francis Algorithm
// The core idea of this algorithm is that doing successive
// A' = QtAQ transformations will eventually converge to block-
// upper-triangular with diagonal blocks either 1x1 or 2x2.
// The Q here is the one from the QR decomposition, A = QR.
// Since the eigenvalues of a block-upper-triangular matrix are
// the eigenvalues of its diagonal blocks and we know how to find
// eigenvalues of a 2x2 matrix, we know the eigenvalues of A.
var y=J(e),N=[],w=n,E=[],A=p?c(Array(n).fill(g)):void 0,S=p?c(Array(w).fill(g)):void 0,C=0;C<=100;){C+=1;// old-fashioned choice; ideally set close to an eigenvalue, or
// perhaps better yet switch to the implicit QR version that is sometimes
// specifically called the "Francis algorithm" that is alluded to
// in the following TODO. (Or perhaps we switch to an independently
// optimized third-party package for the linear algebra operations...)
for(var M=y[w-1][w-1],F=0;F<w;F++)y[F][F]=r(y[F][F],M);// TODO if the convergence is slow, do something clever
// Perform the factorization
var{Q:B,R:T}=d(y);// TODO this is apparently a somewhat
y=i(T,B);for(var O=0;O<w;O++)y[O][O]=t(y[O][O],M);// The rightmost diagonal element converged to an eigenvalue
if(p&&(S=i(S,B)),1===w||b(u(y[w-1][w-2]),o)){C=0,N.push(y[w-1][w-1]),p&&(E.unshift([[1]]),D(S,n),A=i(A,S),w>1&&(S=c(Array(w-1).fill(g)))),// reduce the matrix size
w-=1,y.pop();for(var _=0;_<w;_++)y[_].pop();// The rightmost diagonal 2x2 block converged
}else if(2===w||b(u(y[w-2][w-3]),o)){C=0;var z=/**
   * Compute the eigenvalues of an 2x2 matrix
   * @return {[number,number]}
   */function(e,n,i,o){// lambda_+- = 1/2 trA +- 1/2 sqrt( tr^2 A - 4 detA )
var u=t(e,o),l=r(a(e,o),a(n,i)),c=a(u,.5),f=a(s(r(a(u,u),a(4,l))),.5);return[t(c,f),r(c,f)]}(y[w-2][w-2],y[w-2][w-1],y[w-1][w-2],y[w-1][w-1]);N.push(...z),p&&(E.unshift(/**
   * For an 2x2 matrix compute the transformation matrix S,
   * so that SAS^-1 is an upper triangular matrix
   * @return {[[number,number],[number,number]]}
   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf
   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
   */function(e,t,n,i,a,o,s,c){var f="BigNumber"===c,p="Complex"===c,m=f?l(0):p?v(0):0,d=f?l(1):p?v(1):1;// matrix is already upper triangular
// return an identity matrix
if(b(u(n),s))return[[d,m],[m,d]];// matrix is diagonalizable
// return its eigenvectors as columns
if(x(u(r(a,o)),s))return[[r(a,i),r(o,i)],[n,n]];// matrix is not diagonalizable
// compute diagonal elements of N = A - lambdaI
var h=r(e,a),g=r(i,a);return(// col(N,2) = 0  implies  S = ( col(N,1), e_1 )
// col(N,2) != 0 implies  S = ( col(N,2), e_2 )
b(u(t),s)&&b(u(g),s)?[[h,d],[n,m]]:[[t,m],[g,d]])}(y[w-2][w-2],y[w-2][w-1],y[w-1][w-2],y[w-1][w-1],z[0],z[1],o,f)),D(S,n),A=i(A,S),w>2&&(S=c(Array(w-2).fill(g)))),// reduce the matrix size
w-=2,y.pop(),y.pop();for(var q=0;q<w;q++)y[q].pop(),y[q].pop()}if(0===w)break}// the algorithm didn't converge
if(// standard sorting
N.sort((e,t)=>+r(u(e),u(t))),C>100){var k=Error("The eigenvalues failed to converge. Only found these eigenvalues: "+N.join(", "));throw k.values=N,k.vectors=[],k}return{values:N,C:p?i(A,/**
   * Create a block-diagonal matrix with the given square matrices on the diagonal
   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal
   * @param {number} N the size of the resulting matrix
   */function(e,t){for(var r=[],n=0;n<t;n++)r[n]=Array(t).fill(0);var i=0;for(var a of e){for(var o=a.length,s=0;s<o;s++)for(var u=0;u<o;u++)r[i+s][i+u]=a[s][u];i+=o}return r}(E,n)):void 0}}(e,f,p,N,w);// values is the list of eigenvalues, C is the column
// transformation matrix that transforms arr, the hessenberg
// matrix, to upper triangular
// (So U = C^-1 arr C and the relationship between current arr
// and original A is unchanged.)
if(w){var B=/**
   * @param {Matrix} A hessenberg-form matrix
   * @param {number} N size of A
   * @param {Matrix} C column transformation matrix that turns A into upper triangular
   * @param {Matrix} R similarity that turns original matrix into A
   * @param {number[]} values array of eigenvalues of A
   * @param {'number'|'BigNumber'|'Complex'} type
   * @returns {number[][]} eigenvalues
   */function(e,t,a,o,s,u,f){var p=i(m(a),e,a),d="BigNumber"===f,N="Complex"===f,w=d?l(0):N?v(0):0,D=d?l(1):N?v(1):1,C=[],M=[];for(var F of s){var B=/**
   * Finds the index of an element in an array using a custom equality function
   * @template T
   * @param {Array<T>} arr array in which to search
   * @param {T} el the element to find
   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`
   * @returns {number} the index of `el`, or -1 when it's not in `arr`
   */function(e,t,r){for(var n=0;n<e.length;n++)if(r(e[n],t))return n;return -1}(C,F,y);-1===B?(C.push(F),M.push(1)):M[B]+=1}for(var T=[],O=C.length,_=Array(t).fill(w),z=c(Array(t).fill(D)),q=0;q<O;q++)!function(){var e=C[q],s=r(p,i(e,z)),c=g(s,_);// looks like we missed something, try inverse iteration
// But if that fails, just presume that the original matrix truly
// was defective.
for(c.shift();c.length<M[q];){var d=/**
   * Provided a near-singular upper-triangular matrix A and a list of vectors,
   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal
   * to each vector in the list
   * @template T
   * @param {T[][]} A near-singular square matrix
   * @param {number} N dimension
   * @param {T[][]} orthog list of vectors
   * @param {number} prec epsilon
   * @param {'number'|'BigNumber'|'Complex'} type
   * @return {T[] | null} eigenvector
   *
   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration
   */function(e,t,r,n,i){for(var a,o="BigNumber"===i?l(1e3):1e3,s=0;s<5;++s){a=/**
   * Generates a random unit vector of dimension N, orthogonal to each vector in the list
   * @template T
   * @param {number} N dimension
   * @param {T[][]} orthog list of vectors
   * @param {'number'|'BigNumber'|'Complex'} type
   * @returns {T[]} random vector
   */function(e,t,r){var n="BigNumber"===r,i="Complex"===r,a=Array(e).fill(0).map(e=>2*Math.random()-1);// normalize
return n&&(a=a.map(e=>l(e))),i&&(a=a.map(e=>v(e))),S(// project to orthogonal complement
a=E(a,t),r)}(t,r,i);try{a=h(e,a)}catch(e){continue}if(x(A(a),o))break}if(s>=5)return null;// couldn't find any orthogonal vector in the image
for(// you better converge before I count to ten
s=0;;){var u=h(e,a);if(b(A(E(a,[u])),n))break;if(++s>=10)return null;a=S(u)}return a}(s,t,c,u,f);if(null===d)break;// no more vectors were found
c.push(d)}// Transform back into original array coordinates
var y=i(m(o),a);c=c.map(e=>i(y,e)),T.push(...c.map(t=>({value:e,vector:n(t)})))}();return T}(e,f,F,C,M,p,N);return{values:M,eigenvectors:B}}return{values:M}})}({config:r,addScalar:a,subtract:s,multiply:N,multiplyScalar:y,flatten:A,divideScalar:v,sqrt:M,abs:m,bignumber:b,diag:F,size:B,reshape:T,qr:O,inv:x,usolve:_,usolveAll:z,equal:u,complex:C,larger:D,smaller:I,matrixFromColumns:R,dot:P});/**
   * Compute eigenvalues and optionally eigenvectors of a square matrix.
   * The eigenvalues are sorted by their absolute value, ascending, and
   * returned as a vector in the `values` property of the returned project.
   * An eigenvalue with algebraic multiplicity k will be listed k times, so
   * that the returned `values` vector always has length equal to the size
   * of the input matrix.
   *
   * The `eigenvectors` property of the return value provides the eigenvectors.
   * It is an array of plain objects: the `value` property of each gives the
   * associated eigenvalue, and the `vector` property gives the eigenvector
   * itself. Note that the same `value` property will occur as many times in
   * the list provided by `eigenvectors` as the geometric multiplicity of
   * that value.
   *
   * If the algorithm fails to converge, it will throw an error –
   * in that case, however, you may still find useful information
   * in `err.values` and `err.vectors`.
   *
   * Note that the 'precision' option does not directly specify the _accuracy_
   * of the returned eigenvalues. Rather, it determines how small an entry
   * of the iterative approximations to an upper triangular matrix must be
   * in order to be considered zero. The actual accuracy of the returned
   * eigenvalues may be greater or less than the precision, depending on the
   * conditioning of the matrix and how far apart or close the actual
   * eigenvalues are. Note that currently, relatively simple, "traditional"
   * methods of eigenvalue computation are being used; this is not a modern,
   * high-precision eigenvalue computation. That said, it should typically
   * produce fairly reasonable results.
   *
   * Syntax:
   *
   *     math.eigs(x, [prec])
   *     math.eigs(x, {options})
   *
   * Examples:
   *
   *     const { eigs, multiply, column, transpose, matrixFromColumns } = math
   *     const H = [[5, 2.3], [2.3, 1]]
   *     const ans = eigs(H) // returns {values: [E1,E2...sorted], eigenvectors: [{value: E1, vector: v2}, {value: e, vector: v2}, ...]
   *     const E = ans.values
   *     const V = ans.eigenvectors
   *     multiply(H, V[0].vector)) // returns multiply(E[0], V[0].vector))
   *     const U = matrixFromColumns(...V.map(obj => obj.vector))
   *     const UTxHxU = multiply(transpose(U), H, U) // diagonalizes H if possible
   *     E[0] == UTxHxU[0][0]  // returns true always
   *
   *     // Compute only approximate eigenvalues:
   *     const {values} = eigs(H, {eigenvectors: false, precision: 1e-6})
   *
   * See also:
   *
   *     inv
   *
   * @param {Array | Matrix} x  Matrix to be diagonalized
   *
   * @param {number | BigNumber | OptsObject} [opts] Object with keys `precision`, defaulting to config.epsilon, and `eigenvectors`, defaulting to true and specifying whether to compute eigenvectors. If just a number, specifies precision.
   * @return {{values: Array|Matrix, eigenvectors?: Array<EVobj>}} Object containing an array of eigenvalues and an array of {value: number|BigNumber, vector: Array|Matrix} objects. The eigenvectors property is undefined if eigenvectors were not requested.
   *
   */return n("eigs",{// The conversion to matrix in the first two implementations,
// just to convert back to an array right away in
// computeValuesAndVectors, is unfortunate, and should perhaps be
// streamlined. It is done because the Matrix object carries some
// type information about its entries, and so constructing the matrix
// is a roundabout way of doing type detection.
Array:function(e){return L(i(e))},"Array, number|BigNumber":function(e,t){return L(i(e),{precision:t})},"Array, Object":(e,t)=>L(i(e),t),Matrix:function(e){return L(e,{matricize:!0})},"Matrix, number|BigNumber":function(e,t){return L(e,{precision:t,matricize:!0})},"Matrix, Object":function(t,r){var n={matricize:!0};return /*@__PURE__*/e(o)(n,r),L(t,n)}});function L(e){var t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=!("eigenvectors"in n)||n.eigenvectors,o=function(e,t,r){var n=e.toArray(),i=e.size();// NOTE: arr is guaranteed to be unaliased
if(2!==i.length||i[0]!==i[1])throw RangeError("Matrix must be square (size: ".concat(eP(i),")"));var a=i[0];if(/** @return {boolean} */function(e,t,r){for(var n=0;n<t;n++)for(var i=0;i<t;i++)// TODO proper comparison of bignum and frac
if(D(b(m(q(e[n][i]))),r))return!1;return!0}(n,a,t)&&(function(e,t){for(var r=0;r<t;r++)for(var n=0;n<t;n++)e[r][n]=k(e[r][n])}(n,a),/** @return {boolean} */function(e,t,r){for(var n=0;n<t;n++)for(var i=n;i<t;i++)// TODO proper comparison of bignum and frac
if(D(b(m(s(e[n][i],e[i][n]))),r))return!1;return!0}(n,a,t))){var o=$(e,n,a);// modifies arr by side effect
return j(n,a,t,o,r)}var u=$(e,n,a);// modifies arr by side effect
return U(n,a,t,u,r)}(e,null!==(t=n.precision)&&void 0!==t?t:r.epsilon,a);return n.matricize&&(o.values=i(o.values),a&&(o.eigenvectors=o.eigenvectors.map(e=>{var{value:t,vector:r}=e;return{value:t,vector:i(r)}}))),a&&Object.defineProperty(o,"vectors",{enumerable:!1,// to make sure that the eigenvectors can still be
// converted to string.
get:()=>{throw Error("eigs(M).vectors replaced with eigs(M).eigenvectors")}}),o}/** @return {'number' | 'BigNumber' | 'Complex'} */function $(e,t,r){/** @type {string} */var n=e.datatype();if("number"===n||"BigNumber"===n||"Complex"===n)return n;for(var i=!1,a=!1,o=!1,s=0;s<r;s++)for(var u=0;u<r;u++){var m=t[s][u];if(l(m)||p(m))i=!0;else if(c(m))a=!0;else if(f(m))o=!0;else throw TypeError("Unsupported type in Matrix: "+Y(m))}if(a&&o&&console.warn("Complex BigNumbers not supported, this operation will lose precission."),o){for(var d=0;d<r;d++)for(var h=0;h<r;h++)t[d][h]=C(t[d][h]);return"Complex"}if(a){for(var g=0;g<r;g++)for(var y=0;y<r;y++)t[g][y]=b(t[g][y]);return"BigNumber"}if(i){for(var v=0;v<r;v++)for(var x=0;x<r;x++)t[v][x]=S(t[v][x]);return"number"}throw TypeError("Matrix contains unsupported types only.")}}),s9="equal",ue=ta(s9,["typed","matrix","equalScalar","DenseMatrix","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,DenseMatrix:i,concat:a}=e,o=i5({typed:t}),s=ov({typed:t,DenseMatrix:i}),u=i6({typed:t,DenseMatrix:i}),l=iI({typed:t,matrix:r,concat:a});/**
   * Test whether two values are equal.
   *
   * The function tests whether the relative difference between x and y is
   * smaller than the configured epsilon. The function cannot be used to
   * compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * In case of complex numbers, x.re must equal y.re, and x.im must equal y.im.
   *
   * Values `null` and `undefined` are compared strictly, thus `null` is only
   * equal to `null` and nothing else, and `undefined` is only equal to
   * `undefined` and nothing else. Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.equal(x, y)
   *
   * Examples:
   *
   *    math.equal(2 + 2, 3)         // returns false
   *    math.equal(2 + 2, 4)         // returns true
   *
   *    const a = math.unit('50 cm')
   *    const b = math.unit('5 m')
   *    math.equal(a, b)             // returns true
   *
   *    const c = [2, 5, 1]
   *    const d = [2, 7, 1]
   *
   *    math.equal(c, d)             // returns [true, false, true]
   *    math.deepEqual(c, d)         // returns false
   *
   *    math.equal("1000", "1e3")    // returns true
   *    math.equal(0, null)          // returns false
   *
   * See also:
   *
   *    unequal, smaller, smallerEq, larger, largerEq, compare, deepEqual, equalText
   *
   * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the compared values are equal, else returns false
   */return t(s9,ut({typed:t,equalScalar:n}),l({elop:n,SS:s,DS:o,Ss:u}))}),ut=ta(s9,["typed","equalScalar"],e=>{var{typed:t,equalScalar:r}=e;return t(s9,{"any, any":function(e,t){return(// strict equality for null and undefined?
null===e?null===t:null===t?null===e:void 0===e?void 0===t:void 0===t?void 0===e:r(e,t))}})}),ur="equalScalar",un=ta(ur,["typed","config"],e=>{var{typed:t,config:r}=e,n=oL({typed:t});/**
   * Test whether two scalar values are nearly equal.
   *
   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit} x   First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Complex} y          Second value to compare
   * @return {boolean}                                                  Returns true when the compared values are equal, else returns false
   * @private
   */return t(ur,{"boolean, boolean":function(e,t){return e===t},"number, number":function(e,t){return eB(e,t,r.epsilon)},"BigNumber, BigNumber":function(e,t){return e.eq(t)||oC(e,t,r.epsilon)},"Fraction, Fraction":function(e,t){return e.equals(t)},"Complex, Complex":function(e,t){var n;return n=r.epsilon,eB(e.re,t.re,n)&&eB(e.im,t.im,n)}},n)});ta(ur,["typed","config"],e=>{var{typed:t,config:r}=e;return t(ur,{"number, number":function(e,t){return eB(e,t,r.epsilon)}})});var ui="equalText",ua=ta(ui,["typed","compareText","isZero"],e=>{var{typed:t,compareText:r,isZero:n}=e;/**
   * Check equality of two strings. Comparison is case sensitive.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.equalText(x, y)
   *
   * Examples:
   *
   *    math.equalText('Hello', 'Hello')     // returns true
   *    math.equalText('a', 'A')             // returns false
   *    math.equal('2e3', '2000')            // returns true
   *    math.equalText('2e3', '2000')        // returns false
   *
   *    math.equalText('B', ['A', 'B', 'C']) // returns [false, true, false]
   *
   * See also:
   *
   *    equal, compareText, compare, compareNatural
   *
   * @param  {string | Array | DenseMatrix} x First string to compare
   * @param  {string | Array | DenseMatrix} y Second string to compare
   * @return {number | Array | DenseMatrix} Returns true if the values are equal, and false if not.
   */return t(ui,{"any, any":function(e,t){return n(r(e,t))}})}),uo=ta("erf",["typed"],e=>{var{typed:t}=e;/**
   * Compute the erf function of a value using a rational Chebyshev
   * approximations for different intervals of x.
   *
   * This is a translation of W. J. Cody's Fortran implementation from 1987
   * ( https://www.netlib.org/specfun/erf ). See the AMS publication
   * "Rational Chebyshev Approximations for the Error Function" by W. J. Cody
   * for an explanation of this process.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.erf(x)
   *
   * Examples:
   *
   *    math.erf(0.2)    // returns 0.22270258921047847
   *    math.erf(-0.5)   // returns -0.5204998778130465
   *    math.erf(4)      // returns 0.9999999845827421
   *
   * See also:
   *    zeta
   *
   * @param {number | Array | Matrix} x   A real number
   * @return {number | Array | Matrix}    The erf of `x`
   */return t("name",{number:function(e){var t=Math.abs(e);return t>=uf?eg(e):t<=us?eg(e)*/**
   * Approximates the error function erf() for x <= 0.46875 using this function:
   *               n
   * erf(x) = x * sum (p_j * x^(2j)) / (q_j * x^(2j))
   *              j=0
   */function(e){var t,r=e*e,n=ul[0][4]*r,i=r;for(t=0;t<3;t+=1)n=(n+ul[0][t])*r,i=(i+uc[0][t])*r;return e*(n+ul[0][3])/(i+uc[0][3])}(t):t<=4?eg(e)*(1-/**
   * Approximates the complement of the error function erfc() for
   * 0.46875 <= x <= 4.0 using this function:
   *                       n
   * erfc(x) = e^(-x^2) * sum (p_j * x^j) / (q_j * x^j)
   *                      j=0
   */function(e){var t,r=ul[1][8]*e,n=e;for(t=0;t<7;t+=1)r=(r+ul[1][t])*e,n=(n+uc[1][t])*e;var i=(r+ul[1][7])/(n+uc[1][7]),a=parseInt(16*e)/16;return Math.exp(-a*a)*Math.exp(-((e-a)*(e+a)))*i}(t)):eg(e)*(1-/**
   * Approximates the complement of the error function erfc() for x > 4.0 using
   * this function:
   *
   * erfc(x) = (e^(-x^2) / x) * [ 1/sqrt(pi) +
   *               n
   *    1/(x^2) * sum (p_j * x^(-2j)) / (q_j * x^(-2j)) ]
   *              j=0
   */function(e){var t,r=1/(e*e),n=ul[2][5]*r,i=r;for(t=0;t<4;t+=1)n=(n+ul[2][t])*r,i=(i+uc[2][t])*r;var a=r*(n+ul[2][4])/(i+uc[2][4]);a=(uu-a)/e,r=parseInt(16*e)/16;var o=(e-r)*(e+r);return Math.exp(-r*r)*Math.exp(-o)*a}(t))},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),us=.46875,uu=.5641895835477563,ul=[[3.1611237438705655,113.86415415105016,377.485237685302,3209.3775891384694,.18577770618460315],[.5641884969886701,8.883149794388377,66.11919063714163,298.6351381974001,881.952221241769,1712.0476126340707,2051.0783778260716,1230.3393547979972,21531153547440383e-24],[.30532663496123236,.36034489994980445,.12578172611122926,.016083785148742275,6587491615298378e-19,.016315387137302097]],uc=[[23.601290952344122,244.02463793444417,1282.6165260773723,2844.236833439171],[15.744926110709835,117.6939508913125,537.1811018620099,1621.3895745666903,3290.7992357334597,4362.619090143247,3439.3676741437216,1230.3393548037495],[2.568520192289822,1.8729528499234604,.5279051029514285,.06051834131244132,.0023352049762686918]],uf=9007199254740992,up=ta("exp",["typed"],e=>{var{typed:t}=e;/**
   * Calculate the exponential of a value.
   * For matrices, if you want the matrix exponential of square matrix, use
   * the `expm` function; if you want to take the exponential of each element,
   * see the examples.
   *
   * Syntax:
   *
   *    math.exp(x)
   *
   * Examples:
   *
   *    math.exp(2)                  // returns number 7.3890560989306495
   *    math.pow(math.e, 2)          // returns number 7.3890560989306495
   *    math.log(math.exp(2))        // returns number 2
   *
   *    math.map([1, 2, 3], math.exp)
   *    // returns Array [
   *    //   2.718281828459045,
   *    //   7.3890560989306495,
   *    //   20.085536923187668
   *    // ]
   *
   * See also:
   *
   *    expm1, expm, log, pow
   *
   * @param {number | BigNumber | Complex} x  A number to exponentiate
   * @return {number | BigNumber | Complex} Exponential of `x`
   */return t("exp",{number:n2,Complex:function(e){return e.exp()},BigNumber:function(e){return e.exp()}})}),um="expm",ud=ta(um,["typed","abs","add","identity","inv","multiply"],e=>{var{typed:t,abs:r,add:n,identity:i,inv:a,multiply:o}=e;/**
   * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.
   * Not to be confused with exp(a), which performs element-wise
   * exponentiation.
   *
   * The exponential is calculated using the Padé approximant with scaling and
   * squaring; see "Nineteen Dubious Ways to Compute the Exponential of a
   * Matrix," by Moler and Van Loan.
   *
   * Syntax:
   *
   *     math.expm(x)
   *
   * Examples:
   *
   *     const A = [[0,2],[0,0]]
   *     math.expm(A)        // returns [[1,2],[0,1]]
   *
   * See also:
   *
   *     exp
   *
   * @param {Matrix} x  A square Matrix
   * @return {Matrix}   The exponential of x
   */return t(um,{Matrix:function(e){// Check matrix size
var t=e.size();if(2!==t.length||t[0]!==t[1])throw RangeError("Matrix must be square (size: "+eP(t)+")");for(var s=t[0],u=/**
   * Find the best parameters for the Pade approximant given
   * the matrix norm and desired accuracy. Returns the first acceptable
   * combination in order of increasing computational load.
   */function(e,t){for(var r=0;r<30;r++)for(var n=0;n<=r;n++){var i=r-n;if(1e-15>/**
   * Returns the estimated error of the Pade approximant for the given
   * parameters.
   */function(e,t,r){for(var n=1,i=2;i<=t;i++)n*=i;for(var a=n,o=t+1;o<=2*t;o++)a*=o;var s=a*(2*t+1);return 8*Math.pow(e/Math.pow(2,r),2*t)*n*n/(a*s)}(e,n,i))return{q:n,j:i}}throw Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)")}(function(e){for(var t=e.size()[0],n=0,i=0;i<t;i++){for(var a=0,o=0;o<t;o++)a+=r(e.get([i,o]));n=Math.max(a,n)}return n}(e),0),l=u.q,c=u.j,f=o(e,Math.pow(2,-c)),p=i(s),m=i(s),d=1,h=f,g=-1,y=1;y<=l;y++)y>1&&(h=o(h,f),g=-g),p=n(p,o(d=d*(l-y+1)/((2*l-y+1)*y),h)),m=n(m,o(d*g,h));// Square j times
for(var v=o(a(m),p),b=0;b<c;b++)v=o(v,v);return x(e)?e.createSparseMatrix(v):v}})}),uh="expm1",ug=ta(uh,["typed","Complex"],e=>{var{typed:t,Complex:r}=e;/**
   * Calculate the value of subtracting 1 from the exponential value.
   * This function is more accurate than `math.exp(x)-1` when `x` is near 0
   * To avoid ambiguity with the matrix exponential `expm`, this function
   * does not operate on matrices; if you wish to apply it elementwise, see
   * the examples.
   *
   * Syntax:
   *
   *    math.expm1(x)
   *
   * Examples:
   *
   *    math.expm1(2)                      // returns number 6.38905609893065
   *    math.pow(math.e, 2) - 1            // returns number 6.3890560989306495
   *    math.expm1(1e-8)                   // returns number 1.0000000050000001e-8
   *    math.exp(1e-8) - 1                 // returns number 9.9999999392253e-9
   *    math.log(math.expm1(2) + 1)        // returns number 2
   *
   *    math.map([1, 2, 3], math.expm1)
   *    // returns Array [
   *    //   1.718281828459045,
   *    //   6.3890560989306495,
   *    //   19.085536923187668
   *    // ]
   *
   * See also:
   *
   *    exp, expm, log, pow
   *
   * @param {number | BigNumber | Complex} x  The number to exponentiate
   * @return {number | BigNumber | Complex} Exponential of `x`, minus one
   */return t(uh,{number:n3,Complex:function(e){var t=Math.exp(e.re);return new r(t*Math.cos(e.im)-1,t*Math.sin(e.im))},BigNumber:function(e){return e.exp().minus(1)}})}),uy="factorial",uv=ta(uy,["typed","gamma"],e=>{var{typed:t,gamma:r}=e;/**
   * Compute the factorial of a value
   *
   * Factorial only supports an integer value as argument.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.factorial(n)
   *
   * Examples:
   *
   *    math.factorial(5)    // returns 120
   *    math.factorial(3)    // returns 6
   *
   * See also:
   *
   *    combinations, combinationsWithRep, gamma, permutations
   *
   * @param {number | BigNumber | Array | Matrix} n   An integer number
   * @return {number | BigNumber | Array | Matrix}    The factorial of `n`
   */return t(uy,{number:function(e){if(e<0)throw Error("Value must be non-negative");return r(e+1)},BigNumber:function(e){if(e.isNegative())throw Error("Value must be non-negative");return r(e.plus(1))},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),ux=ta("fft",["typed","matrix","addScalar","multiplyScalar","divideScalar","exp","tau","i","dotDivide","conj","pow","ceil","log2"],e=>{var{typed:t,matrix:r,addScalar:n,multiplyScalar:i,divideScalar:a,exp:o,tau:s,i:u,dotDivide:l,conj:c,pow:f,ceil:p,log2:m}=e;/**
   * Calculate N-dimensional fourier transform
   *
   * Syntax:
   *
   *     math.fft(arr)
   *
   * Examples:
   *
   *    math.fft([[1, 0], [1, 0]]) // returns [[{re:2, im:0}, {re:2, im:0}], [{re:0, im:0}, {re:0, im:0}]]
   *
   *
   * See Also:
   *
   *      ifft
   *
   * @param {Array | Matrix} arr    An array or matrix
   * @return {Array | Matrix}       N-dimensional fourier transformation of the array
   */return t("fft",{Array:d,Matrix:function(e){return e.create(d(e.toArray()))}});/**
   * Perform an N-dimensional Fourier transform
   *
   * @param {Array} arr      The array
   * @return {Array}         resulting array
   */function d(e){var t=eG(e);return 1===t.length?h(e,t[0]):/**
   * Perform an 1-dimensional Fourier transform
   *
   * @param {Array} arr      The array
   * @param {number} dim     dimension of the array to perform on
   * @return {Array}         resulting array
   */function e(t,r){var n=eG(t);if(0!==r)return Array(n[0]).fill(0).map((n,i)=>e(t[i],r-1));if(1===n.length)return h(t);function i(e){// Swap first 2 dimensions
var t=eG(e);return Array(t[1]).fill(0).map((r,n)=>Array(t[0]).fill(0).map((t,r)=>e[r][n]))}return i(e(i(t),1))}(e.map(e=>d(e,t.slice(1))),0)}/**
   * Perform an 1-dimensional Fourier transform
   *
   * @param {Array} arr      The array
   * @return {Array}         resulting array
   */function h(e){var t=e.length;if(1===t)return[e[0]];if(t%2!=0)return(/**
   * Perform an 1-dimensional non-power-of-2 Fourier transform using Chirp-Z Transform
   *
   * @param {Array} arr      The array
   * @return {Array}         resulting array
   */function(e){for(var t=e.length,r=o(a(i(-1,i(u,s)),t)),n=[],g=1-t;g<t;g++)n.push(f(r,a(f(g,2),2)));for(var y=f(2,p(m(t+t-1))),v=[...Array(t).fill(0).map((r,a)=>i(e[a],n[t-1+a])),...Array(y-t).fill(0)],x=[...Array(t+t-1).fill(0).map((e,t)=>a(1,n[t])),...Array(y-(t+t-1)).fill(0)],b=h(v),N=h(x),w=l(c(d(c(Array(y).fill(0).map((e,t)=>i(b[t],N[t]))))),y),D=[],E=t-1;E<t+t-1;E++)D.push(i(w[E],n[E]));return D}(e));for(var r=[...h(e.filter((e,t)=>t%2==0),t/2),...h(e.filter((e,t)=>t%2==1),t/2)],g=0;g<t/2;g++){var y=r[g],v=i(r[g+t/2],o(i(i(s,u),a(-g,t))));r[g]=n(y,v),r[g+t/2]=n(y,i(-1,v))}return r;// throw new Error('Can only calculate FFT of power-of-two size')
}}),ub=ta("FibonacciHeap",["smaller","larger"],e=>{var{smaller:t,larger:r}=e,n=1/Math.log((1+Math.sqrt(5))/2);/**
   * Fibonacci Heap implementation, used interally for Matrix math.
   * @class FibonacciHeap
   * @constructor FibonacciHeap
   */function i(){if(!(this instanceof i))throw SyntaxError("Constructor must be called with the new operator");// initialize fields
this._minimum=null,this._size=0}/**
   * The reverse of the link operation: removes node from the child list of parent.
   * This method assumes that min is non-null. Running time: O(1).
   * @memberof FibonacciHeap
   */function a(e,t,r){// remove node from parent children and decrement Degree[parent]
t.left.right=t.right,t.right.left=t.left,r.degree--,r.child===t&&(r.child=t.right),0===r.degree&&(r.child=null),// add node to root list of heap
t.left=e,t.right=e.right,e.right=t,t.right.left=t,// set parent[node] to null
t.parent=null,// set mark[node] to false
t.mark=!1}/**
   * Attach type information
   */i.prototype.type="FibonacciHeap",i.prototype.isFibonacciHeap=!0,/**
   * Inserts a new data element into the heap. No heap consolidation is
   * performed at this time, the new node is simply inserted into the root
   * list of this heap. Running time: O(1) actual.
   * @memberof FibonacciHeap
   */i.prototype.insert=function(e,r){// create node
var n={key:e,value:r,degree:0};// check we have a node in the minimum
if(this._minimum){// minimum node
var i=this._minimum;// update left & right of node
n.left=i,n.right=i.right,i.right=n,n.right.left=n,t(e,i.key)&&(this._minimum=n)}else // set left & right
n.left=n,n.right=n,// this is the first node
this._minimum=n;// return node
return(// increment number of nodes in heap
this._size++,n)},/**
   * Returns the number of nodes in heap. Running time: O(1) actual.
   * @memberof FibonacciHeap
   */i.prototype.size=function(){return this._size},/**
   * Removes all elements from this heap.
   * @memberof FibonacciHeap
   */i.prototype.clear=function(){this._minimum=null,this._size=0},/**
   * Returns true if the heap is empty, otherwise false.
   * @memberof FibonacciHeap
   */i.prototype.isEmpty=function(){return 0===this._size},/**
   * Extracts the node with minimum key from heap. Amortized running
   * time: O(log n).
   * @memberof FibonacciHeap
   */i.prototype.extractMinimum=function(){// node to remove
var e=this._minimum;// check we have a minimum
if(null===e)return e;// for each child of node do...
for(// current minimum
var i=this._minimum,a=e.degree,s=e.child;a>0;){// store node in right side
var u=s.right;// remove x from child list
s.left.right=s.right,s.right.left=s.left,// add x to root list of heap
s.left=i,s.right=i.right,i.right=s,s.right.left=s,// set Parent[x] to null
s.parent=null,s=u,a--}// return node
return(// remove node from root list of heap
e.left.right=e.right,e.right.left=e.left,i=e===e.right?null:function(e,i){// to find trees of the same degree efficiently we use an array of length O(log n) in which we keep a pointer to one root of each degree
var a,s=Math.floor(Math.log(i)*n)+1,u=Array(s),l=0,c=e;if(c)for(l++,c=c.right;c!==e;)l++,c=c.right;// For each node in root list do...
for(;l>0;){// check if there is a node already in array with the same degree
for(// access this node's degree..
var f=c.degree,p=c.right;// get node with the same degree is any
a=u[f];){// make one node with the same degree a child of the other, do this based on the key value.
if(r(c.key,a.key)){var m=a;a=c,c=m}// make y a child of x
o(a,c),// we have handled this degree, go to next one.
u[f]=null,f++}// save this node for later when we might encounter another of the same degree.
u[f]=c,// move forward through list.
c=p,l--}// Set min to null (effectively losing the root list) and reconstruct the root list from the array entries in array[].
e=null;// loop nodes in array
for(var d=0;d<s;d++)// get current node
(a=u[d])&&(e?(// First remove node from root list.
a.left.right=a.right,a.right.left=a.left,// now add to root list, again.
a.left=e,a.right=e.right,e.right=a,a.right.left=a,t(a.key,e.key)&&(e=a)):e=a);return e}(// update minimum
i=e.right,this._size),// decrement size of heap
this._size--,// update minimum
this._minimum=i,e)},/**
   * Removes a node from the heap given the reference to the node. The trees
   * in the heap will be consolidated, if necessary. This operation may fail
   * to remove the correct element if there are nodes with key value -Infinity.
   * Running time: O(log n) amortized.
   * @memberof FibonacciHeap
   */i.prototype.remove=function(e){var r,n;// decrease key value
this._minimum=(r=this._minimum,// set node key
e.key=-1,(n=e.parent)&&t(e.key,n.key)&&(// remove node from parent
a(r,e,n),// remove all nodes from parent to the root parent
/**
   * Performs a cascading cut operation. This cuts node from its parent and then
   * does the same for its parent, and so on up the tree.
   * Running time: O(log n); O(1) excluding the recursion.
   * @memberof FibonacciHeap
   */function e(t,r){// store parent node
var n=r.parent;// if there's a parent...
n&&(r.mark?(// it's marked, cut it from parent
a(t,r,n),// cut its parent as well
e(n)):r.mark=!0)}(r,n)),t(e.key,r.key)&&(r=e),r),// remove the smallest
this.extractMinimum()};/**
   * Make the first node a child of the second one. Running time: O(1) actual.
   * @memberof FibonacciHeap
   */var o=function(e,t){// remove node from root list of heap
e.left.right=e.right,e.right.left=e.left,// make node a Child of parent
e.parent=t,t.child?(e.left=t.child,e.right=t.child.right,t.child.right=e,e.right.left=e):(t.child=e,e.right=e,e.left=e),// increase degree[parent]
t.degree++,// set mark[node] false
e.mark=!1};return i},{isClass:!0}),uN=ta("filter",["typed"],e=>{var{typed:t}=e;/**
   * Filter the items in an array or one dimensional matrix.
   *
   * Syntax:
   *
   *    math.filter(x, test)
   *
   * Examples:
   *
   *    function isPositive (x) {
   *      return x > 0
   *    }
   *    math.filter([6, -2, -1, 4, 3], isPositive) // returns [6, 4, 3]
   *
   *    math.filter(["23", "foo", "100", "55", "bar"], /[0-9]+/) // returns ["23", "100", "55"]
   *
   * See also:
   *
   *    forEach, map, sort
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to filter
   * @param {Function | RegExp} test
   *        A function or regular expression to test items.
   *        All entries for which `test` returns true are returned.
   *        When `test` is a function, it is invoked with three parameters:
   *        the value of the element, the index of the element, and the
   *        matrix/array being traversed. The function must return a boolean.
   * @return {Matrix | Array} Returns the filtered matrix.
   */return t("filter",{"Array, function":uw,"Matrix, function":function(e,t){return e.create(uw(e.toArray(),t))},"Array, RegExp":e6,"Matrix, RegExp":function(e,t){return e.create(e6(e.toArray(),t))}})});/**
 * Filter values in a callback given a callback function
 * @param {Array} x
 * @param {Function} callback
 * @return {Array} Returns the filtered array
 * @private
 */function uw(e,t){return e8(e,function(e,r,n){// invoke the callback function with the right number of arguments
return rd(t,e,[r],n,"filter")})}var uD=ta("fix",["typed","ceil","floor"],e=>{var{typed:t,ceil:r,floor:n}=e;return t("fix",{number:function(e){return e>0?n(e):r(e)},"number, number":function(e,t){return e>0?n(e,t):r(e,t)}})}),uE=ta("fix",["typed","Complex","matrix","ceil","floor","equalScalar","zeros","DenseMatrix"],e=>{var{typed:t,Complex:r,matrix:n,ceil:i,floor:a,equalScalar:o,zeros:s,DenseMatrix:u}=e,l=i6({typed:t,DenseMatrix:u}),c=iq({typed:t}),f=uD({typed:t,ceil:i,floor:a});/**
   * Round a value towards zero.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.fix(x)
   *    math.fix(x,n)
   *
   * Examples:
   *
   *    math.fix(3.2)                // returns number 3
   *    math.fix(3.8)                // returns number 3
   *    math.fix(-4.2)               // returns number -4
   *    math.fix(-4.7)               // returns number -4
   *
   *    math.fix(3.12, 1)                // returns number 3.1
   *    math.fix(3.18, 1)                // returns number 3.1
   *    math.fix(-4.12, 1)               // returns number -4.1
   *    math.fix(-4.17, 1)               // returns number -4.1
   *
   *    const c = math.complex(3.22, -2.78)
   *    math.fix(c)                  // returns Complex 3 - 2i
   *    math.fix(c, 1)               // returns Complex 3.2 -2.7i
   *
   *    math.fix([3.2, 3.8, -4.7])      // returns Array [3, 3, -4]
   *    math.fix([3.2, 3.8, -4.7], 1)   // returns Array [3.2, 3.8, -4.7]
   *
   * See also:
   *
   *    ceil, floor, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x    Number to be rounded
   * @param  {number | BigNumber | Array} [n=0]                             Number of decimals
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}     Rounded value
   */return t("fix",{number:f.signatures.number,"number, number | BigNumber":f.signatures["number,number"],Complex:function(e){return new r(e.re>0?Math.floor(e.re):Math.ceil(e.re),e.im>0?Math.floor(e.im):Math.ceil(e.im))},"Complex, number":function(e,t){return new r(e.re>0?a(e.re,t):i(e.re,t),e.im>0?a(e.im,t):i(e.im,t))},"Complex, BigNumber":function(e,t){var n=t.toNumber();return new r(e.re>0?a(e.re,n):i(e.re,n),e.im>0?a(e.im,n):i(e.im,n))},BigNumber:function(e){return e.isNegative()?i(e):a(e)},"BigNumber, number | BigNumber":function(e,t){return e.isNegative()?i(e,t):a(e,t)},Fraction:function(e){return e.s<0?e.ceil():e.floor()},"Fraction, number | BigNumber":function(e,t){return e.s<0?i(e,t):a(e,t)},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e,!0)),"Array | Matrix, number | BigNumber":t.referToSelf(e=>(t,r)=>tq(t,t=>e(t,r),!0)),"number | Complex | Fraction | BigNumber, Array":t.referToSelf(e=>(t,r)=>c(n(r),t,e,!0).valueOf()),"number | Complex | Fraction | BigNumber, Matrix":t.referToSelf(e=>(t,r)=>o(t,0)?s(r.size(),r.storage()):"dense"===r.storage()?c(r,t,e,!0):l(r,t,e,!0))})}),uA="flatten",uS=ta(uA,["typed","matrix"],e=>{var{typed:t,matrix:r}=e;/**
   * Flatten a multidimensional matrix into a single dimensional matrix.
   * A new matrix is returned, the original matrix is left untouched.
   *
   * Syntax:
   *
   *    math.flatten(x)
   *
   * Examples:
   *
   *    math.flatten([[1,2], [3,4]])   // returns [1, 2, 3, 4]
   *
   * See also:
   *
   *    concat, resize, size, squeeze
   *
   * @param {Matrix | Array} x   Matrix to be flattened
   * @return {Matrix | Array} Returns the flattened matrix
   */return t(uA,{Array:function(e){return e3(e)},Matrix:function(e){// TODO: return the same matrix type as x (Dense or Sparse Matrix)
return r(e3(e.toArray()))}})}),uC="floor",uM=ta(uC,["typed","config","round"],e=>{var{typed:t,config:r,round:n}=e;return t(uC,{number:function(e){return eB(e,n(e),r.epsilon)?n(e):Math.floor(e)},"number, number":function(e,t){if(eB(e,n(e,t),r.epsilon))return n(e,t);var[i,a]="".concat(e,"e").split("e"),o=Math.floor(Number("".concat(i,"e").concat(Number(a)+t)));return[i,a]="".concat(o,"e").split("e"),Number("".concat(i,"e").concat(Number(a)-t))}})}),uF=ta(uC,["typed","config","round","matrix","equalScalar","zeros","DenseMatrix"],t=>{var{typed:r,config:n,round:i,matrix:a,equalScalar:o,zeros:s,DenseMatrix:u}=t,l=iL({typed:r,equalScalar:o}),c=i6({typed:r,DenseMatrix:u}),f=iq({typed:r}),p=uM({typed:r,config:n,round:i});/**
   * Round a value towards minus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.floor(x)
   *    math.floor(x, n)
   *
   * Examples:
   *
   *    math.floor(3.2)              // returns number 3
   *    math.floor(3.8)              // returns number 3
   *    math.floor(-4.2)             // returns number -5
   *    math.floor(-4.7)             // returns number -5
   *
   *    math.floor(3.212, 2)          // returns number 3.21
   *    math.floor(3.288, 2)          // returns number 3.28
   *    math.floor(-4.212, 2)         // returns number -4.22
   *    math.floor(-4.782, 2)         // returns number -4.79
   *
   *    const c = math.complex(3.24, -2.71)
   *    math.floor(c)                 // returns Complex 3 - 3i
   *    math.floor(c, 1)              // returns Complex 3.2 -2.8i
   *
   *    math.floor([3.2, 3.8, -4.7])       // returns Array [3, 3, -5]
   *    math.floor([3.21, 3.82, -4.71], 1)  // returns Array [3.2, 3.8, -4.8]
   *
   *    math.floor(math.tau, [2, 3])  // returns Array [6.28, 6.283]
   *
   *    // Note that floor(array, array) currently not implemented.
   *
   * See also:
   *
   *    ceil, fix, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
   */return r("floor",{number:p.signatures.number,"number,number":p.signatures["number,number"],Complex:function(e){return e.floor()},"Complex, number":function(e,t){return e.floor(t)},"Complex, BigNumber":function(e,t){return e.floor(t.toNumber())},BigNumber:function(e){return oC(e,i(e),n.epsilon)?i(e):e.floor()},"BigNumber, BigNumber":function(t,r){return oC(t,i(t,r),n.epsilon)?i(t,r):t.toDecimalPlaces(r.toNumber(),/*@__PURE__*/e(a3).ROUND_FLOOR)},Fraction:function(e){return e.floor()},"Fraction, number":function(e,t){return e.floor(t)},"Fraction, BigNumber":function(e,t){return e.floor(t.toNumber())},"Array | Matrix":r.referToSelf(e=>t=>tq(t,e,!0)),"Array, number | BigNumber":r.referToSelf(e=>(t,r)=>tq(t,t=>e(t,r),!0)),"SparseMatrix, number | BigNumber":r.referToSelf(e=>(t,r)=>l(t,r,e,!1)),"DenseMatrix, number | BigNumber":r.referToSelf(e=>(t,r)=>f(t,r,e,!1)),"number | Complex | Fraction | BigNumber, Array":r.referToSelf(e=>(t,r)=>f(a(r),t,e,!0).valueOf()),"number | Complex | Fraction | BigNumber, Matrix":r.referToSelf(e=>(t,r)=>o(t,0)?s(r.size(),r.storage()):"dense"===r.storage()?f(r,t,e,!0):c(r,t,e,!0))})}),uB="forEach",uT=ta(uB,["typed"],e=>{var{typed:t}=e;/**
   * Iterate over all elements of a matrix/array, and executes the given callback function.
   *
   * Syntax:
   *
   *    math.forEach(x, callback)
   *
   * Examples:
   *
   *    math.forEach([1, 2, 3], function(value) {
   *      console.log(value)
   *    })
   *    // outputs 1, 2, 3
   *
   * See also:
   *
   *    filter, map, sort
   *
   * @param {Matrix | Array} x    The matrix to iterate on.
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix/array being traversed.
   */return t(uB,{"Array, function":uO,"Matrix, function":function(e,t){e.forEach(t)}})});/**
 * forEach for a multidimensional array
 * @param {Array} array
 * @param {Function} callback
 * @private
 */function uO(e,t){!function r(n,i){if(!Array.isArray(n))return rd(t,n,i,e,"forEach");e5(n,function(e,t){// we create a copy of the index array and append the new index value
r(e,i.concat(t))})}(e,[])}var u_="format",uz=ta(u_,["typed"],e=>{var{typed:t}=e;/**
   * Format a value of any type into a string.
   *
   * Syntax:
   *
   *    math.format(value)
   *    math.format(value, options)
   *    math.format(value, precision)
   *    math.format(value, callback)
   *
   * Where:
   *
   *  - `value: *`
   *    The value to be formatted
   *  - `options: Object`
   *    An object with formatting options. Available options:
   *    - `notation: string`
   *      Number notation. Choose from:
   *      - `'fixed'`
   *        Always use regular number notation.
   *        For example `'123.40'` and `'14000000'`
   *      - `'exponential'`
   *        Always use exponential notation.
   *        For example `'1.234e+2'` and `'1.4e+7'`
   *      - `'engineering'`
   *        Always use engineering notation: always have exponential notation,
   *        and select the exponent to be a multiple of `3`.
   *        For example `'123.4e+0'` and `'14.0e+6'`
   *      - `'auto'` (default)
   *        Regular number notation for numbers having an absolute value between
   *        `lower` and `upper` bounds, and uses exponential notation elsewhere.
   *        Lower bound is included, upper bound is excluded.
   *        For example `'123.4'` and `'1.4e7'`.
   *      - `'bin'`, `'oct'`, or `'hex'`
   *        Format the number using binary, octal, or hexadecimal notation.
   *        For example `'0b1101'` and `'0x10fe'`.
   *    - `wordSize: number`
   *      The word size in bits to use for formatting in binary, octal, or
   *      hexadecimal notation. To be used only with `'bin'`, `'oct'`, or `'hex'`
   *      values for `notation` option. When this option is defined the value
   *      is formatted as a signed twos complement integer of the given word
   *      size and the size suffix is appended to the output.
   *      For example `format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'`.
   *      Default value is undefined.
   *    - `precision: number`
   *      Limit the number of digits of the formatted value.
   *      For regular numbers, must be a number between `0` and `16`.
   *      For bignumbers, the maximum depends on the configured precision,
   *      see function `config()`.
   *      In case of notations `'exponential'`, `'engineering'`, and `'auto'`,
   *      `precision` defines the total number of significant digits returned.
   *      In case of notation `'fixed'`, `precision` defines the number of
   *      significant digits after the decimal point.
   *      `precision` is undefined by default.
   *    - `lowerExp: number`
   *      Exponent determining the lower boundary for formatting a value with
   *      an exponent when `notation='auto'`. Default value is `-3`.
   *    - `upperExp: number`
   *      Exponent determining the upper boundary for formatting a value with
   *      an exponent when `notation='auto'`. Default value is `5`.
   *    - `fraction: string`. Available values: `'ratio'` (default) or `'decimal'`.
   *      For example `format(fraction(1, 3))` will output `'1/3'` when `'ratio'`
   *      is configured, and will output `'0.(3)'` when `'decimal'` is configured.
   *    - `truncate: number`. Specifies the maximum allowed length of the
   *      returned string. If it had been longer, the excess characters
   *      are deleted and replaced with `'...'`.
   * - `callback: function`
   *   A custom formatting function, invoked for all numeric elements in `value`,
   *   for example all elements of a matrix, or the real and imaginary
   *   parts of a complex number. This callback can be used to override the
   *   built-in numeric notation with any type of formatting. Function `callback`
   *   is called with `value` as parameter and must return a string.
   *
   * When `value` is an Object:
   *
   * - When the object contains a property `format` being a function, this function
   *   is invoked as `value.format(options)` and the result is returned.
   * - When the object has its own `toString` method, this method is invoked
   *   and the result is returned.
   * - In other cases the function will loop over all object properties and
   *   return JSON object notation like '{"a": 2, "b": 3}'.
   *
   * When value is a function:
   *
   * - When the function has a property `syntax`, it returns this
   *   syntax description.
   * - In other cases, a string `'function'` is returned.
   *
   * Examples:
   *
   *    math.format(6.4)                                        // returns '6.4'
   *    math.format(1240000)                                    // returns '1.24e+6'
   *    math.format(1/3)                                        // returns '0.3333333333333333'
   *    math.format(1/3, 3)                                     // returns '0.333'
   *    math.format(21385, 2)                                   // returns '21000'
   *    math.format(12e8, {notation: 'fixed'})                  // returns '1200000000'
   *    math.format(2.3,  {notation: 'fixed', precision: 4})    // returns '2.3000'
   *    math.format(52.8, {notation: 'exponential'})            // returns '5.28e+1'
   *    math.format(12400, {notation: 'engineering'})           // returns '12.4e+3'
   *    math.format(2000, {lowerExp: -2, upperExp: 2})          // returns '2e+3'
   *
   *    function formatCurrency(value) {
   *      // return currency notation with two digits:
   *      return '$' + value.toFixed(2)
   *
   *      // you could also use math.format inside the callback:
   *      // return '$' + math.format(value, {notation: 'fixed', precision: 2})
   *    }
   *    math.format([2.1, 3, 0.016], formatCurrency)            // returns '[$2.10, $3.00, $0.02]'
   *
   * See also:
   *
   *    print
   *
   * @param {*} value                               Value to be stringified
   * @param {Object | Function | number} [options]  Formatting options
   * @return {string} The formatted value
   */return t(u_,{any:eP,"any, Object | function | number":eP})}),uq=ta("fraction",["typed","Fraction"],e=>{var{typed:t,Fraction:r}=e;/**
   * Create a fraction or convert a value to a fraction.
   *
   * With one numeric argument, produces the closest rational approximation to the
   * input.
   * With two arguments, the first is the numerator and the second is the denominator,
   * and creates the corresponding fraction. Both numerator and denominator must be
   * integers.
   * With one object argument, looks for the integer numerator as the value of property
   * 'n' and the integer denominator as the value of property 'd'.
   * With a matrix argument, creates a matrix of the same shape with entries
   * converted into fractions.
   *
   * Syntax:
   *     math.fraction(value)
   *     math.fraction(numerator, denominator)
   *     math.fraction({n: numerator, d: denominator})
   *     math.fraction(matrix: Array | Matrix)
   *
   * Examples:
   *
   *     math.fraction(6.283)             // returns Fraction 6283/1000
   *     math.fraction(1, 3)              // returns Fraction 1/3
   *     math.fraction('2/3')             // returns Fraction 2/3
   *     math.fraction({n: 2, d: 3})      // returns Fraction 2/3
   *     math.fraction([0.2, 0.25, 1.25]) // returns Array [1/5, 1/4, 5/4]
   *     math.fraction(4, 5.1)            // throws Error: Parameters must be integer
   *
   * See also:
   *
   *    bignumber, number, string, unit
   *
   * @param {number | string | Fraction | BigNumber | Unit | Array | Matrix} [args]
   *            Arguments specifying the value, or numerator and denominator of
   *            the fraction
   * @return {Fraction | Array | Matrix} Returns a fraction
   */return t("fraction",{number:function(e){if(!isFinite(e)||isNaN(e))throw Error(e+" cannot be represented as a fraction");return new r(e)},string:function(e){return new r(e)},"number, number":function(e,t){return new r(e,t)},null:function(e){return new r(0)},BigNumber:function(e){return new r(e.toString())},Fraction:function(e){return e;// fractions are immutable
},Unit:t.referToSelf(e=>t=>{var r=t.clone();return r.value=e(t.value),r}),Object:function(e){return new r(e)},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),uk={};!/**
 * @license Fraction.js v4.3.0 20/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **//**
 *
 * This class offers the possibility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 => <numerator>, 1 => <denominator> ]
 * [ n => <numerator>, d => <denominator> ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - a string fraction
 * 123.'456' - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45'6' - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * var f = new Fraction("9.4'31'");
 * f.mul([-4, 3]).div(4.9);
 *
 */function(e){// Parsed data to avoid calling "new" all the time
var t={s:1,n:0,d:1};function r(e,t){if(isNaN(e=parseInt(e,10)))throw l();return e*t}// Creates a new Fraction internally without the need of the bulky constructor
function n(e,t){if(0===t)throw u();var r=Object.create(s.prototype);r.s=e<0?-1:1;var n=o(e=e<0?-e:e,t);return r.n=e/n,r.d=t/n,r}function i(e){for(var t={},r=e,n=2,i=4;i<=r;){for(;r%n==0;)r/=n,t[n]=(t[n]||0)+1;i+=1+2*n++}return r!==e?r>1&&(t[r]=(t[r]||0)+1):t[e]=(t[e]||0)+1,t}var a=function(e,n){var i,a=0,o=1,s=1,f=0,p=0,m=0,d=1,h=1,g=0,y=1,v=1,x=1;if(null==e);else if(void 0!==n){if(s=(a=e)*(o=n),a%1!=0||o%1!=0)throw c()}else switch(typeof e){case"object":if("d"in e&&"n"in e)a=e.n,o=e.d,"s"in e&&(a*=e.s);else if(0 in e)a=e[0],1 in e&&(o=e[1]);else throw l();s=a*o;break;case"number":if(e<0&&(s=e,e=-e),e%1==0)a=e;else if(e>0){// Using Farey Sequences
// http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/
for(e>=1&&(h=Math.pow(10,Math.floor(1+Math.log(e)/Math.LN10)),e/=h);y<=1e7&&x<=1e7;){if(e===(i=(g+v)/(y+x))){y+x<=1e7?(a=g+v,o=y+x):x>y?(a=v,o=x):(a=g,o=y);break}e>i?(g+=v,y+=x):(v+=g,x+=y),y>1e7?(a=v,o=x):(a=g,o=y)}a*=h}else(isNaN(e)||isNaN(n))&&(o=a=NaN);break;case"string":if(null===(y=e.match(/\d+|./g)))throw l();if("-"===y[g]?(s=-1,g++):"+"===y[g]&&g++,y.length===g+1?p=r(y[g++],s):"."===y[g+1]||"."===y[g]?("."!==y[g]&&(f=r(y[g++],s)),(++g+1===y.length||"("===y[g+1]&&")"===y[g+3]||"'"===y[g+1]&&"'"===y[g+3])&&(p=r(y[g],s),d=Math.pow(10,y[g].length),g++),("("===y[g]&&")"===y[g+2]||"'"===y[g]&&"'"===y[g+2])&&(m=r(y[g+1],s),h=Math.pow(10,y[g+1].length)-1,g+=3)):"/"===y[g+1]||":"===y[g+1]?(p=r(y[g],s),d=r(y[g+2],1),g+=3):"/"===y[g+3]&&" "===y[g+1]&&(f=r(y[g],s),p=r(y[g+2],s),d=r(y[g+4],1),g+=5),y.length<=g){s=/* void */a=m+(o=d*h)*f+h*p;break}default:throw l()}if(0===o)throw u();t.s=s<0?-1:1,t.n=Math.abs(a),t.d=Math.abs(o)};function o(e,t){if(!e)return t;if(!t)return e;for(;;){if(!(e%=t))return t;if(!(t%=e))return e}}/**
   * Module constructor
   *
   * @constructor
   * @param {number|Fraction=} a
   * @param {number=} b
   */function s(e,r){if(a(e,r),!(this instanceof s))return n(t.s*t.n,t.d);e=o(t.d,t.n),this.s=t.s,this.n=t.n/e,this.d=t.d/e}var u=function(){return Error("Division by Zero")},l=function(){return Error("Invalid argument")},c=function(){return Error("Parameters must be integer")};s.prototype={s:1,n:0,d:1,/**
     * Calculates the absolute value
     *
     * Ex: new Fraction(-4).abs() => 4
     **/abs:function(){return n(this.n,this.d)},/**
     * Inverts the sign of the current fraction
     *
     * Ex: new Fraction(-4).neg() => 4
     **/neg:function(){return n(-this.s*this.n,this.d)},/**
     * Adds two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
     **/add:function(e,r){return a(e,r),n(this.s*this.n*t.d+t.s*this.d*t.n,this.d*t.d)},/**
     * Subtracts two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
     **/sub:function(e,r){return a(e,r),n(this.s*this.n*t.d-t.s*this.d*t.n,this.d*t.d)},/**
     * Multiplies two rational numbers
     *
     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
     **/mul:function(e,r){return a(e,r),n(this.s*t.s*this.n*t.n,this.d*t.d)},/**
     * Divides two rational numbers
     *
     * Ex: new Fraction("-17.(345)").inverse().div(3)
     **/div:function(e,r){return a(e,r),n(this.s*t.s*this.n*t.d,this.d*t.n)},/**
     * Clones the actual object
     *
     * Ex: new Fraction("-17.(345)").clone()
     **/clone:function(){return n(this.s*this.n,this.d)},/**
     * Calculates the modulo of two rational numbers - a more precise fmod
     *
     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
     **/mod:function(e,r){if(isNaN(this.n)||isNaN(this.d))return new s(NaN);if(void 0===e)return n(this.s*this.n%this.d,1);if(a(e,r),0===t.n&&0===this.d)throw u();/*
       * First silly attempt, kinda slow
       *
       return that["sub"]({
       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
       "d": num["d"],
       "s": this["s"]
       });*//*
       * New attempt: a1 / b1 = a2 / b2 * q + r
       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
       * => (b2 * a1 % a2 * b1) / (b1 * b2)
       */return n(this.s*(t.d*this.n)%(t.n*this.d),t.d*this.d)},/**
     * Calculates the fractional gcd of two rational numbers
     *
     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
     */gcd:function(e,r){// gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)
return a(e,r),n(o(t.n,this.n)*o(t.d,this.d),t.d*this.d)},/**
     * Calculates the fractional lcm of two rational numbers
     *
     * Ex: new Fraction(5,8).lcm(3,7) => 15
     */lcm:function(e,r){return(// lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)
(a(e,r),0===t.n&&0===this.n)?n(0,1):n(t.n*this.n,o(t.n,this.n)*o(t.d,this.d)))},/**
     * Calculates the ceil of a rational number
     *
     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
     **/ceil:function(e){return(e=Math.pow(10,e||0),isNaN(this.n)||isNaN(this.d))?new s(NaN):n(Math.ceil(e*this.s*this.n/this.d),e)},/**
     * Calculates the floor of a rational number
     *
     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
     **/floor:function(e){return(e=Math.pow(10,e||0),isNaN(this.n)||isNaN(this.d))?new s(NaN):n(Math.floor(e*this.s*this.n/this.d),e)},/**
     * Rounds a rational numbers
     *
     * Ex: new Fraction('4.(3)').round() => (4 / 1)
     **/round:function(e){return(e=Math.pow(10,e||0),isNaN(this.n)||isNaN(this.d))?new s(NaN):n(Math.round(e*this.s*this.n/this.d),e)},/**
     * Gets the inverse of the fraction, means numerator and denominator are exchanged
     *
     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
     **/inverse:function(){return n(this.s*this.d,this.n)},/**
     * Calculates the fraction to some rational exponent, if possible
     *
     * Ex: new Fraction(-1,2).pow(-3) => -8
     */pow:function(e,r){// Trivial case when exp is an integer
if(a(e,r),1===t.d)return t.s<0?n(Math.pow(this.s*this.d,t.n),Math.pow(this.n,t.n)):n(Math.pow(this.s*this.n,t.n),Math.pow(this.d,t.n));// Negative roots become complex
//     (-a/b)^(c/d) = x
// <=> (-1)^(c/d) * (a/b)^(c/d) = x
// <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180°
// <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
// From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
if(this.s<0)return null;// Now prime factor n and d
var o=i(this.n),s=i(this.d),u=1,l=1;for(var c in o)if("1"!==c){if("0"===c){u=0;break}if(o[c]*=t.n,o[c]%t.d!=0)return null;o[c]/=t.d,u*=Math.pow(c,o[c])}for(var c in s)if("1"!==c){if(s[c]*=t.n,s[c]%t.d!=0)return null;s[c]/=t.d,l*=Math.pow(c,s[c])}return t.s<0?n(l,u):n(u,l)},/**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/equals:function(e,r){return a(e,r),this.s*this.n*t.d==t.s*t.n*this.d;// Same as compare() === 0
},/**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/compare:function(e,r){a(e,r);var n=this.s*this.n*t.d-t.s*t.n*this.d;return(0<n)-(n<0)},simplify:function(e){if(isNaN(this.n)||isNaN(this.d))return this;e=e||.001;for(var t=this.abs(),r=t.toContinued(),i=1;i<r.length;i++){for(var a=n(r[i-1],1),o=i-2;o>=0;o--)a=a.inverse().add(r[o]);if(Math.abs(a.sub(t).valueOf())<e)return a.mul(this.s)}return this},/**
     * Check if two rational numbers are divisible
     *
     * Ex: new Fraction(19.6).divisible(1.5);
     */divisible:function(e,r){return a(e,r),!(!(t.n*this.d)||this.n*t.d%(t.n*this.d))},/**
     * Returns a decimal representation of the fraction
     *
     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
     **/valueOf:function(){return this.s*this.n/this.d},/**
     * Returns a string-fraction representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
     **/toFraction:function(e){var t,r="",n=this.n,i=this.d;return this.s<0&&(r+="-"),1===i?r+=n:(e&&(t=Math.floor(n/i))>0&&(r+=t+" ",n%=i),r+=n+"/"+i),r},/**
     * Returns a latex representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
     **/toLatex:function(e){var t,r="",n=this.n,i=this.d;return this.s<0&&(r+="-"),1===i?r+=n:(e&&(t=Math.floor(n/i))>0&&(r+=t,n%=i),r+="\\frac{"+n+"}{"+i+"}"),r},/**
     * Returns an array of continued fraction elements
     *
     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
     */toContinued:function(){var e,t=this.n,r=this.d,n=[];if(isNaN(t)||isNaN(r))return n;do n.push(Math.floor(t/r)),e=t%r,t=r,r=e;while(1!==t)return n},/**
     * Creates a string representation of a fraction with all digits
     *
     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
     **/toString:function(e){var t=this.n,r=this.d;if(isNaN(t)||isNaN(r))return"NaN";e=e||15;var n=function(e,t){for(;t%2==0;t/=2);for(;t%5==0;t/=5);if(1===t)return 0;for(// If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
// 10^(d-1) % d == 1
// However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
// as we want to translate the numbers to strings.
var r=10%t,n=1;1!==r;n++)if(r=10*r%t,n>2e3)return 0;// Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
return n}(0,r),i=function(e,t,r){for(var n=1,i=function(e,t,r){for(var n=1;t>0;e=e*e%r,t>>=1)1&t&&(n=n*e%r);return n}(10,r,t),a=0;a<300;a++){// Solve 10^s == 10^(s+t) (mod d)
if(n===i)return a;n=10*n%t,i=10*i%t}return 0}(0,r,n),a=this.s<0?"-":"";// Cycle length
if(a+=t/r|0,t%=r,(t*=10)&&(a+="."),n){for(var o=i;o--;)a+=t/r|0,t%=r,t*=10;a+="(";for(var o=n;o--;)a+=t/r|0,t%=r,t*=10;a+=")"}else for(var o=e;t&&o--;)a+=t/r|0,t%=r,t*=10;return a}},Object.defineProperty(s,"__esModule",{value:!0}),s.default=s,s.Fraction=s,uk=s}(0);var uI=ta("Fraction",[],()=>(/**
   * Attach type information
   */Object.defineProperty(/*@__PURE__*/e(uk),"name",{value:"Fraction"}),/*@__PURE__*/e(uk).prototype.constructor=/*@__PURE__*/e(uk),/*@__PURE__*/e(uk).prototype.type="Fraction",/*@__PURE__*/e(uk).prototype.isFraction=!0,/*@__PURE__*/e(uk).prototype.toJSON=function(){return{mathjs:"Fraction",n:this.s*this.n,d:this.d}},/*@__PURE__*/e(uk).fromJSON=function(t){return new/*@__PURE__*/(e(uk))(t)},/*@__PURE__*/e(uk)),{isClass:!0}),uR="freqz",uP=ta(uR,["typed","add","multiply","Complex","divide","matrix"],e=>{var{typed:t,add:r,multiply:n,Complex:i,divide:a,matrix:o}=e;/**
     * Calculates the frequency response of a filter given its numerator and denominator coefficients.
     *
     * Syntax:
     *    math.freqz(b, a)
     *    math.freqz(b, a, w)
     *
     * Examples:
     *   math.freqz([1, 2], [1, 2, 3], 4) // returns { h: [0.5 + 0i, 0.4768589245763655 + 0.2861153547458193i, 0.25000000000000006 + 0.75i, -0.770976571635189 + 0.4625859429811135i], w: [0, 0.7853981633974483, 1.5707963267948966, 2.356194490192345 ] }
     *   math.freqz([1, 2], [1, 2, 3], [0, 1]) // returns { h: [0.5 + 0i, 0.45436781 + 0.38598051i], w: [0, 1] }
     *
     * See also:
     *  zpk2tf
     *
     * @param {Array.<number>} b The numerator coefficients of the filter.
     * @param {Array.<number>} a The denominator coefficients of the filter.
     * @param {Array.<number>} [w] A vector of frequencies (in radians/sample) at which the frequency response is to be computed or the number of points to compute (if a number is not provided, the default is 512 points)
     * @returns {Object} An object with two properties: h, a vector containing the complex frequency response, and w, a vector containing the normalized frequencies (in radians/sample) at which the response was computed.
     *
     *
     */return t(uR,{"Array, Array":function(e,t){return s(e,t,u(512))},"Array, Array, Array":function(e,t,r){return s(e,t,r)},"Array, Array, number":function(e,t,r){if(r<0)throw Error("w must be a positive number");return s(e,t,u(r))},"Matrix, Matrix":function(e,t){// console.log('here')
var r=u(512),{w:n,h:i}=s(e.valueOf(),t.valueOf(),r);return{w:o(n),h:o(i)}},"Matrix, Matrix, Matrix":function(e,t,r){var{h:n}=s(e.valueOf(),t.valueOf(),r.valueOf());return{h:o(n),w:o(r)}},"Matrix, Matrix, number":function(e,t,r){if(r<0)throw Error("w must be a positive number");var n=u(r),{h:i}=s(e.valueOf(),t.valueOf(),n);return{h:o(i),w:o(n)}}});function s(e,t,o){for(var s=[],u=[],l=0;l<o.length;l++){for(var c=i(0,0),f=i(0,0),p=0;p<e.length;p++)c=r(c,n(e[p],i(Math.cos(-p*o[l]),Math.sin(-p*o[l]))));for(var m=0;m<t.length;m++)f=r(f,n(t[m],i(Math.cos(-m*o[l]),Math.sin(-m*o[l]))));s.push(c),u.push(f)}for(var d=[],h=0;h<s.length;h++)d.push(a(s[h],u[h]));return{h:d,w:o}}function u(e){for(var t=[],r=0;r<e;r++)t.push(r/e*Math.PI);return t}});/* eslint-disable no-loss-of-precision */function uj(e){if(eh(e))return e<=0?isFinite(e)?1/0:NaN:e>171?1/0:o_(1,e-1);if(e<.5)return Math.PI/(Math.sin(Math.PI*e)*uj(1-e));if(e>=171.35)return 1/0;// will overflow
if(e>85){// Extended Stirling Approx
var t,r=e*e,n=r*e,i=n*e,a=i*e;return Math.sqrt(2*Math.PI/e)*Math.pow(e/Math.E,e)*(1+1/(12*e)+1/(288*r)-139/(51840*n)-571/(2488320*i)+163879/(209018880*a)+5246819/(75246796800*a*e))}--e,t=uL[0];for(var o=1;o<uL.length;++o)t+=uL[o]/(e+o);var s=e+uU+.5;return Math.sqrt(2*Math.PI)*Math.pow(s,e+.5)*Math.exp(-s)*t}uj.signature="number";var uU=4.7421875,uL=[.9999999999999971,57.15623566586292,-59.59796035547549,14.136097974741746,-.4919138160976202,3399464998481189e-20,4652362892704858e-20,-.00009837447530487956,1580887032249125e-19,-.00021026444172410488,21743961811521265e-20,-.0001643181065367639,8441822398385275e-20,-.000026190838401581408,36899182659531625e-22],u$=[1.000000000190015,76.18009172947146,-86.50532032941678,24.01409824083091,-1.231739572450155,.001208650973866179,-.000005395239384953];function uH(e){if(e<0)return NaN;if(0===e)return 1/0;if(!isFinite(e))return e;if(e<.5)// gamma(z) = PI / (sin(PI * z) * gamma(1 - z))
return Math.log(Math.PI/Math.sin(Math.PI*e))-uH(1-e);// We start with the terms that have the smallest coefficients and largest denominator
for(var t=// Compute the logarithm of the Gamma function using the Lanczos method
(e-=1)+5+.5,r=1.000000000190015,n=6;n>=1;n--)r+=u$[n]/(e+n);return .9189385332046728+(e+.5)*Math.log(t)-t+Math.log(r)}uH.signature="number";var uZ="gamma",uG=ta(uZ,["typed","config","multiplyScalar","pow","BigNumber","Complex"],e=>{var{typed:t,config:r,multiplyScalar:n,pow:i,BigNumber:a,Complex:o}=e;return t(uZ,{number:uj,Complex:/**
   * Compute the gamma function of a value using Lanczos approximation for
   * small values, and an extended Stirling approximation for large values.
   *
   * To avoid confusion with the matrix Gamma function, this function does
   * not apply to matrices.
   *
   * Syntax:
   *
   *    math.gamma(n)
   *
   * Examples:
   *
   *    math.gamma(5)       // returns 24
   *    math.gamma(-0.5)    // returns -3.5449077018110335
   *    math.gamma(math.i)  // returns -0.15494982830180973 - 0.49801566811835596i
   *
   * See also:
   *
   *    combinations, factorial, permutations
   *
   * @param {number | BigNumber | Complex} n   A real or complex number
   * @return {number | BigNumber | Complex}    The gamma of `n`
   */function e(t){if(0===t.im)return uj(t.re);// Lanczos approximation doesn't work well with real part lower than 0.5
// So reflection formula is required
if(t.re<.5){// Euler's reflection formula
// gamma(1-z) * gamma(z) = PI / sin(PI * z)
// real part of Z should not be integer [sin(PI) == 0 -> 1/0 - undefined]
// thanks to imperfect sin implementation sin(PI * n) != 0
// we can safely use it anyway
var r=new o(1-t.re,-t.im),n=new o(Math.PI*t.re,Math.PI*t.im);return new o(Math.PI).div(n.sin()).div(e(r))}// Lanczos approximation
// z -= 1
t=new o(t.re-1,t.im);// for (i, gammaPval) in enumerate(gammaP):
for(var i=new o(uL[0],0),a=1;a<uL.length;++a){// x += gammaPval / (z + i)
var s=new o(uL[a],0);i=i.add(s.div(t.add(a)))}// x = gammaPval[0]
var u=new o(t.re+uU+.5,t.im),l=u.pow(t.add(.5)),c=u.neg().exp();// y = [x] * [sqrt(2 * pi)] * [t ** (z + 0.5)] * [exp(-t)]
return i.mul(Math.sqrt(2*Math.PI)).mul(l).mul(c)},BigNumber:function(e){if(e.isInteger())return e.isNegative()||e.isZero()?new a(1/0):/**
   * Calculate factorial for a BigNumber
   * @param {BigNumber} n
   * @returns {BigNumber} Returns the factorial of n
   */function e(t){if(t<8)return new a([1,1,2,6,24,120,720,5040][t]);var n=r.precision+(0|Math.log(t.toNumber())),i=a.clone({precision:n});if(t%2==1)return t.times(e(new a(t-1)));for(var o=t,s=new i(t),u=t.toNumber();o>2;)o-=2,u+=o,s=s.times(u);return new a(s.toPrecision(a.precision))}(e.minus(1));if(!e.isFinite())return new a(e.isNegative()?NaN:1/0);throw Error("Integer BigNumber expected")}})}),uV=ta("mod",["typed","config","round","matrix","equalScalar","zeros","DenseMatrix","concat"],e=>{var{typed:t,config:r,round:n,matrix:i,equalScalar:a,zeros:o,DenseMatrix:s,concat:u}=e,l=uF({typed:t,config:r,round:n,matrix:i,equalScalar:a,zeros:o,DenseMatrix:s}),c=iU({typed:t,equalScalar:a}),f=i5({typed:t}),p=oU({typed:t,equalScalar:a}),m=iL({typed:t,equalScalar:a}),d=i6({typed:t,DenseMatrix:s}),h=iI({typed:t,matrix:i,concat:u});/**
   * Calculates the modulus, the remainder of an integer division.
   *
   * For matrices, the function is evaluated element wise.
   *
   * The modulus is defined as:
   *
   *     x - y * floor(x / y)
   *
   * See https://en.wikipedia.org/wiki/Modulo_operation.
   *
   * Syntax:
   *
   *    math.mod(x, y)
   *
   * Examples:
   *
   *    math.mod(8, 3)                // returns 2
   *    math.mod(11, 2)               // returns 1
   *
   *    function isOdd(x) {
   *      return math.mod(x, 2) != 0
   *    }
   *
   *    isOdd(2)                      // returns false
   *    isOdd(3)                      // returns true
   *
   * See also:
   *
   *    divide
   *
   * @param  {number | BigNumber | Fraction | Array | Matrix} x Dividend
   * @param  {number | BigNumber | Fraction | Array | Matrix} y Divisor
   * @return {number | BigNumber | Fraction | Array | Matrix} Returns the remainder of `x` divided by `y`.
   */return t("mod",{"number, number":/**
  * Calculate the modulus of two numbers
  * @param {number} x
  * @param {number} y
  * @returns {number} res
  * @private
  */function(e,t){// We don't use JavaScript's % operator here as this doesn't work
// correctly for x < 0 and x === 0
// see https://en.wikipedia.org/wiki/Modulo_operation
// We use mathjs floor to handle errors associated with
// precision float approximation
return 0===t?e:e-t*l(e/t)},"BigNumber, BigNumber":function(e,t){return t.isZero()?e:e.sub(t.mul(l(e.div(t))))},"Fraction, Fraction":function(e,t){return t.equals(0)?e:e.sub(t.mul(l(e.div(t))))}},h({SS:p,DS:f,SD:c,Ss:m,sS:d}))});/**
 * Create a syntax error with the message:
 *     'Wrong number of arguments in function <fn> (<count> provided, <min>-<max> expected)'
 * @param {string} fn     Function name
 * @param {number} count  Actual argument count
 * @param {number} min    Minimum required argument count
 * @param {number} [max]  Maximum required argument count
 * @extends Error
 */function uW(e,t,r,n){if(!(this instanceof uW))throw SyntaxError("Constructor must be called with the new operator");this.fn=e,this.count=t,this.min=r,this.max=n,this.message="Wrong number of arguments in function "+e+" ("+t+" provided, "+r+(null!=n?"-"+n:"")+" expected)",this.stack=Error().stack}uW.prototype=Error(),uW.prototype.constructor=Error,uW.prototype.name="ArgumentsError",uW.prototype.isArgumentsError=!0;var uY="number | BigNumber | Fraction | Matrix | Array",uJ="".concat(uY,", ").concat(uY,", ...").concat(uY);function uX(e){return!e.some(e=>Array.isArray(e))}var uQ=ta("gcd",["typed","config","round","matrix","equalScalar","zeros","BigNumber","DenseMatrix","concat"],e=>{var{typed:t,matrix:r,config:n,round:i,equalScalar:a,zeros:o,BigNumber:s,DenseMatrix:u,concat:l}=e,c=uV({typed:t,config:n,round:i,matrix:r,equalScalar:a,zeros:o,DenseMatrix:u,concat:l}),f=iT({typed:t}),p=iO({typed:t,equalScalar:a}),m=i_({typed:t,DenseMatrix:u}),d=iI({typed:t,matrix:r,concat:l});/**
   * Calculate the greatest common divisor for two or more values or arrays.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.gcd(a, b)
   *    math.gcd(a, b, c, ...)
   *
   * Examples:
   *
   *    math.gcd(8, 12)              // returns 4
   *    math.gcd(-4, 6)              // returns 2
   *    math.gcd(25, 15, -10)        // returns 5
   *
   *    math.gcd([8, -4], [12, 6])   // returns [4, 2]
   *
   * See also:
   *
   *    lcm, xgcd
   *
   * @param {... number | BigNumber | Fraction | Array | Matrix} args  Two or more integer numbers
   * @return {number | BigNumber | Fraction | Array | Matrix}                           The greatest common divisor
   */return t("gcd",{"number, number":/**
  * Calculate gcd for numbers
  * @param {number} a
  * @param {number} b
  * @returns {number} Returns the greatest common denominator of a and b
  * @private
  */function(e,t){var r;if(!eh(e)||!eh(t))throw Error("Parameters in function gcd must be integer numbers");for(;0!==t;)r=c(e,t),e=t,t=r;return e<0?-e:e},"BigNumber, BigNumber":/**
   * Calculate gcd for BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} Returns greatest common denominator of a and b
   * @private
   */function(e,t){if(!e.isInt()||!t.isInt())throw Error("Parameters in function gcd must be integer numbers");for(// https://en.wikipedia.org/wiki/Euclidean_algorithm
var r=new s(0);!t.isZero();){var n=c(e,t);e=t,t=n}return e.lt(r)?e.neg():e},"Fraction, Fraction":(e,t)=>e.gcd(t)},d({SS:p,DS:f,Ss:m}),{[uJ]:t.referToSelf(e=>(t,r,n)=>{for(var i=e(t,r),a=0;a<n.length;a++)i=e(i,n[a]);return i}),Array:t.referToSelf(e=>t=>{if(1===t.length&&Array.isArray(t[0])&&uX(t[0]))return e(...t[0]);if(uX(t))return e(...t);throw new uW("gcd() supports only 1d matrices!")}),Matrix:t.referToSelf(e=>t=>e(t.toArray()))})}),uK="getMatrixDataType",u0=ta(uK,["typed"],e=>{var{typed:t}=e;/**
   * Find the data type of all elements in a matrix or array,
   * for example 'number' if all items are a number and 'Complex' if all values
   * are complex numbers.
   * If a matrix contains more than one data type, it will return 'mixed'.
   *
   * Syntax:
   *
   *    math.getMatrixDataType(x)
   *
   * Examples:
   *
   *    const x = [ [1, 2, 3], [4, 5, 6] ]
   *    const mixedX = [ [1, true], [2, 3] ]
   *    const fractionX = [ [math.fraction(1, 3)], [math.fraction(1, 3)] ]
   *    const unitX = [ [math.unit('5cm')], [math.unit('5cm')] ]
   *    const bigNumberX = [ [math.bignumber(1)], [math.bignumber(0)] ]
   *    const sparse = math.sparse(x)
   *    const dense = math.matrix(x)
   *    math.getMatrixDataType(x)   // returns 'number'
   *    math.getMatrixDataType(sparse)   // returns 'number'
   *    math.getMatrixDataType(dense)   // returns 'number'
   *    math.getMatrixDataType(mixedX) // returns 'mixed'
   *    math.getMatrixDataType(fractionX) // returns 'Fraction'
   *    math.getMatrixDataType(unitX) // returns 'Unit'
   *    math.getMatrixDataType(bigNumberX) // return 'BigNumber'
   *
   * See also:
   *  SparseMatrix, DenseMatrix
   *
   * @param {...Matrix | Array} x   The Matrix with values.
   *
   * @return {string} A string representation of the matrix type
   */return t(uK,{Array:function(e){return tt(e,Y)},Matrix:function(e){return e.getDataType()}})}),u1="hasNumericValue",u2=ta(u1,["typed","isNumeric"],e=>{var{typed:t,isNumeric:r}=e;/**
   * Test whether a value is an numeric value.
   *
   * In case of a string, true is returned if the string contains a numeric value.
   *
   * Syntax:
   *
   *     math.hasNumericValue(x)
   *
   * Examples:
   *
   *    math.hasNumericValue(2)                     // returns true
   *    math.hasNumericValue('2')                   // returns true
   *    math.isNumeric('2')                         // returns false
   *    math.hasNumericValue(0)                     // returns true
   *    math.hasNumericValue(math.bignumber(500))   // returns true
   *    math.hasNumericValue(math.fraction(4))      // returns true
   *    math.hasNumericValue(math.complex('2-4i'))  // returns false
   *    math.hasNumericValue(false)                 // returns true
   *    math.hasNumericValue([2.3, 'foo', false])   // returns [true, false, true]
   *
   * See also:
   *
   *    isZero, isPositive, isNegative, isInteger, isNumeric
   *
   * @param {*} x       Value to be tested
   * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,
   *                    `Fraction`, `Boolean`, or a `String` containing number. Returns false for other types.
   *                    Throws an error in case of unknown types.
   */return t(u1,{boolean:()=>!0,string:function(e){return e.trim().length>0&&!isNaN(Number(e))},any:function(e){return r(e)}})}),u3=ta("hex",["typed","format"],e=>{var{typed:t,format:r}=e;return t("hex",{"number | BigNumber":function(e){return r(e,{notation:"hex"})},"number | BigNumber, number":function(e,t){return r(e,{notation:"hex",wordSize:t})}})}),u4="hypot",u5=ta(u4,["typed","abs","addScalar","divideScalar","multiplyScalar","sqrt","smaller","isPositive"],e=>{var{typed:t,abs:r,addScalar:n,divideScalar:i,multiplyScalar:a,sqrt:o,smaller:s,isPositive:u}=e;/**
   * Calculate the hypotenusa of a list with values. The hypotenusa is defined as:
   *
   *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)
   *
   * For matrix input, the hypotenusa is calculated for all values in the matrix.
   *
   * Syntax:
   *
   *     math.hypot(a, b, ...)
   *     math.hypot([a, b, c, ...])
   *
   * Examples:
   *
   *     math.hypot(3, 4)      // 5
   *     math.hypot(3, 4, 5)   // 7.0710678118654755
   *     math.hypot([3, 4, 5]) // 7.0710678118654755
   *     math.hypot(-2)        // 2
   *
   * See also:
   *
   *     abs, norm
   *
   * @param {... number | BigNumber | Array | Matrix} args    A list with numeric values or an Array or Matrix.
   *                                                          Matrix and Array input is flattened and returns a
   *                                                          single number for the whole matrix.
   * @return {number | BigNumber} Returns the hypothenusa of the input values.
   */return t(u4,{"... number | BigNumber":l,Array:l,Matrix:e=>l(e3(e.toArray()))});/**
   * Calculate the hypotenusa for an Array with values
   * @param {Array.<number | BigNumber>} args
   * @return {number | BigNumber} Returns the result
   * @private
   */function l(e){for(var t=0,l=0,c=0;c<e.length;c++){if(f(e[c]))throw TypeError("Unexpected type of argument to hypot");var p=r(e[c]);s(l,p)?(t=n(t=a(t,a(i(l,p),i(l,p))),1),l=p):t=n(t,u(p)?a(i(p,l),i(p,l)):p)}return a(l,o(t))}}),u8="identity",u6=ta(u8,["typed","config","matrix","BigNumber","DenseMatrix","SparseMatrix"],e=>{var{typed:t,config:r,matrix:n,BigNumber:i,DenseMatrix:a,SparseMatrix:o}=e;/**
   * Create a 2-dimensional identity matrix with size m x n or n x n.
   * The matrix has ones on the diagonal and zeros elsewhere.
   *
   * Syntax:
   *
   *    math.identity(n)
   *    math.identity(n, format)
   *    math.identity(m, n)
   *    math.identity(m, n, format)
   *    math.identity([m, n])
   *    math.identity([m, n], format)
   *
   * Examples:
   *
   *    math.identity(3)                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
   *    math.identity(3, 2)                 // returns [[1, 0], [0, 1], [0, 0]]
   *
   *    const A = [[1, 2, 3], [4, 5, 6]]
   *    math.identity(math.size(A))         // returns [[1, 0, 0], [0, 1, 0]]
   *
   * See also:
   *
   *    diag, ones, zeros, size, range
   *
   * @param {...number | Matrix | Array} size   The size for the matrix
   * @param {string} [format]                   The Matrix storage format
   *
   * @return {Matrix | Array | number} A matrix with ones on the diagonal.
   */return t(u8,{"":function(){return"Matrix"===r.matrix?n([]):[]},string:function(e){return n(e)},"number | BigNumber":function(e){return u(e,e,"Matrix"===r.matrix?"dense":void 0)},"number | BigNumber, string":function(e,t){return u(e,e,t)},"number | BigNumber, number | BigNumber":function(e,t){return u(e,t,"Matrix"===r.matrix?"dense":void 0)},"number | BigNumber, number | BigNumber, string":function(e,t,r){return u(e,t,r)},Array:function(e){return s(e)},"Array, string":function(e,t){return s(e,t)},Matrix:function(e){return s(e.valueOf(),e.storage())},"Matrix, string":function(e,t){return s(e.valueOf(),t)}});function s(e,t){switch(e.length){case 0:return t?n(t):[];case 1:return u(e[0],e[0],t);case 2:return u(e[0],e[1],t);default:throw Error("Vector containing two values expected")}}/**
   * Create an identity matrix
   * @param {number | BigNumber} rows
   * @param {number | BigNumber} cols
   * @param {string} [format]
   * @returns {Matrix}
   * @private
   */function u(e,t,r){// BigNumber constructor with the right precision
var n=c(e)||c(t)?i:null;if(c(e)&&(e=e.toNumber()),c(t)&&(t=t.toNumber()),!eh(e)||e<1||!eh(t)||t<1)throw Error("Parameters in function identity must be positive integers");var s=n?new i(1):1,u=n?new n(0):0,l=[e,t];// check we need to return a matrix
if(r){// create diagonal matrix (use optimized implementation for storage format)
if("sparse"===r)return o.diagonal(l,s,0,u);if("dense"===r)return a.diagonal(l,s,0,u);throw TypeError('Unknown matrix type "'.concat(r,'"'))}// fill diagonal
for(var f=eX([],l,u),p=e<t?e:t,m=0;m<p;m++)f[m][m]=s;return f}}),u7="ifft",u9=ta(u7,["typed","fft","dotDivide","conj"],e=>{var{typed:t,fft:r,dotDivide:n,conj:i}=e;/**
   * Calculate N-dimensional inverse fourier transform
   *
   * Syntax:
   *
   *     math.ifft(arr)
   *
   * Examples:
   *
   *    math.ifft([[2, 2], [0, 0]]) // returns [[{re:1, im:0}, {re:0, im:0}], [{re:1, im:0}, {re:0, im:0}]]
   *
   * See Also:
   *
   *      fft
   *
   * @param {Array | Matrix} arr    An array or matrix
   * @return {Array | Matrix}       N-dimensional fourier transformation of the array
   */return t(u7,{"Array | Matrix":function(e){var t=g(e)?e.size():eG(e);return n(i(r(i(e))),t.reduce((e,t)=>e*t,1))}})}),le=ta("im",["typed"],e=>{var{typed:t}=e;/**
   * Get the imaginary part of a complex number.
   * For a complex number `a + bi`, the function returns `b`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.im(x)
   *
   * Examples:
   *
   *    const a = math.complex(2, 3)
   *    math.re(a)                     // returns number 2
   *    math.im(a)                     // returns number 3
   *
   *    math.re(math.complex('-5.2i')) // returns number -5.2
   *    math.re(math.complex(2.4))     // returns number 0
   *
   * See also:
   *
   *    re, conj, abs, arg
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Array | Matrix} The imaginary part of x
   */return t("im",{number:()=>0,"BigNumber | Fraction":e=>e.mul(0),Complex:e=>e.im,"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),lt=ta("ImmutableDenseMatrix",["smaller","DenseMatrix"],e=>{var{smaller:t,DenseMatrix:r}=e;function n(e,t){if(!(this instanceof n))throw SyntaxError("Constructor must be called with the new operator");if(t&&!d(t))throw Error("Invalid datatype: "+t);if(g(e)||h(e)){// use DenseMatrix implementation
var i=new r(e,t);// internal structures
this._data=i._data,this._size=i._size,this._datatype=i._datatype,this._min=null,this._max=null}else if(e&&h(e.data)&&h(e.size))// initialize fields from JSON representation
this._data=e.data,this._size=e.size,this._datatype=e.datatype,this._min=void 0!==e.min?e.min:null,this._max=void 0!==e.max?e.max:null;else if(e)throw TypeError("Unsupported type of data ("+Y(e)+")");else // nothing provided
this._data=[],this._size=[0],this._datatype=t,this._min=null,this._max=null}return n.prototype=new r,/**
   * Attach type information
   */n.prototype.type="ImmutableDenseMatrix",n.prototype.isImmutableDenseMatrix=!0,/**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     const subset = matrix.subset(index)               // retrieve subset
   *     const value = matrix.subset(index, replacement)   // replace subset
   *
   * @param {Index} index
   * @param {Array | ImmutableDenseMatrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */n.prototype.subset=function(e){switch(arguments.length){case 1:// use base implementation
var t=r.prototype.subset.call(this,e);// check result is a matrix
if(g(t))return new n({data:t._data,size:t._size,datatype:t._datatype});return t;// intentional fall through
case 2:case 3:throw Error("Cannot invoke set subset on an Immutable Matrix instance");default:throw SyntaxError("Wrong number of arguments")}},/**
   * Replace a single element in the matrix.
   * @param {Number[]} index   Zero-based index
   * @param {*} value
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be left undefined.
   * @return {ImmutableDenseMatrix} self
   */n.prototype.set=function(){throw Error("Cannot invoke set on an Immutable Matrix instance")},/**
   * Resize the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @param {Number[]} size           The new size the matrix should have.
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix}                 The resized matrix
   */n.prototype.resize=function(){throw Error("Cannot invoke resize on an Immutable Matrix instance")},/**
   * Disallows reshaping in favor of immutability.
   *
   * @throws {Error} Operation not allowed
   */n.prototype.reshape=function(){throw Error("Cannot invoke reshape on an Immutable Matrix instance")},/**
   * Create a clone of the matrix
   * @return {ImmutableDenseMatrix} clone
   */n.prototype.clone=function(){return new n({data:J(this._data),size:J(this._size),datatype:this._datatype})},/**
   * Get a JSON representation of the matrix
   * @returns {Object}
   */n.prototype.toJSON=function(){return{mathjs:"ImmutableDenseMatrix",data:this._data,size:this._size,datatype:this._datatype}},/**
   * Generate a matrix from a JSON object
   * @param {Object} json  An object structured like
   *                       `{"mathjs": "ImmutableDenseMatrix", data: [], size: []}`,
   *                       where mathjs is optional
   * @returns {ImmutableDenseMatrix}
   */n.fromJSON=function(e){return new n(e)},/**
   * Swap rows i and j in Matrix.
   *
   * @param {Number} i       Matrix row index 1
   * @param {Number} j       Matrix row index 2
   *
   * @return {Matrix}        The matrix reference
   */n.prototype.swapRows=function(){throw Error("Cannot invoke swapRows on an Immutable Matrix instance")},/**
   * Calculate the minimum value in the set
   * @return {Number | undefined} min
   */n.prototype.min=function(){// check min has been calculated before
if(null===this._min){// minimum
var e=null;// compute min
this.forEach(function(r){(null===e||t(r,e))&&(e=r)}),this._min=null!==e?e:void 0}return this._min},/**
   * Calculate the maximum value in the set
   * @return {Number | undefined} max
   */n.prototype.max=function(){// check max has been calculated before
if(null===this._max){// maximum
var e=null;// compute max
this.forEach(function(r){(null===e||t(e,r))&&(e=r)}),this._max=null!==e?e:void 0}return this._max},n},{isClass:!0}),lr="index",ln=ta(lr,["typed","Index"],e=>{var{typed:t,Index:r}=e;/**
   * Create an index. An Index can store ranges having start, step, and end
   * for multiple dimensions.
   * Matrix.get, Matrix.set, and math.subset accept an Index as input.
   *
   * Syntax:
   *
   *     math.index(range1, range2, ...)
   *
   * Where each range can be any of:
   *
   * - A number
   * - A string for getting/setting an object property
   * - An instance of `Range`
   * - A one-dimensional Array or a Matrix with numbers or booleans
   *
   * Indexes must be zero-based, integer numbers.
   *
   * Examples:
   *
   *    const b = [1, 2, 3, 4, 5]
   *    math.subset(b, math.index([1, 2, 3]))                         // returns [2, 3, 4]
   *    math.subset(b, math.index([false, true, true, true, false]))  // returns [2, 3, 4]
   *
   *    const a = math.matrix([[1, 2], [3, 4]])
   *    a.subset(math.index(0, 1))             // returns 2
   *    a.subset(math.index(0, [false, true])) // returns 2
   *
   * See also:
   *
   *    bignumber, boolean, complex, matrix, number, string, unit
   *
   * @param {...*} ranges   Zero or more ranges or numbers.
   * @return {Index}        Returns the created index
   */return t(lr,{"...number | string | BigNumber | Range | Array | Matrix":function(e){var t=e.map(function(e){return c(e)?e.toNumber():h(e)||g(e)?e.map(function(e){// convert BigNumber to Number
return c(e)?e.toNumber():e}):e}),n=new r;return r.apply(n,t),n}})}),li=ta("Index",["ImmutableDenseMatrix","getMatrixDataType"],e=>{var{ImmutableDenseMatrix:t,getMatrixDataType:r}=e;/**
   * Create an index. An Index can store ranges and sets for multiple dimensions.
   * Matrix.get, Matrix.set, and math.subset accept an Index as input.
   *
   * Usage:
   *     const index = new Index(range1, range2, matrix1, array1, ...)
   *
   * Where each parameter can be any of:
   *     A number
   *     A string (containing a name of an object property)
   *     An instance of Range
   *     An Array with the Set values
   *     An Array with Booleans
   *     A Matrix with the Set values
   *     A Matrix with Booleans
   *
   * The parameters start, end, and step must be integer numbers.
   *
   * @class Index
   * @Constructor Index
   * @param {...*} ranges
   */function n(e){if(!(this instanceof n))throw SyntaxError("Constructor must be called with the new operator");this._dimensions=[],this._sourceSize=[],this._isScalar=!0;for(var t=0,a=arguments.length;t<a;t++){var o=arguments[t],s=h(o),u=g(o),l=null;if(b(o))this._dimensions.push(o),this._isScalar=!1;else if(s||u){// create matrix
var c=void 0;"boolean"===r(o)?(s&&(c=i(la(o).valueOf())),u&&(c=i(la(o._data).valueOf())),l=o.valueOf().length):c=i(o.valueOf()),this._dimensions.push(c);// size
var f=c.size();(1!==f.length||1!==f[0]||null!==l)&&(this._isScalar=!1)}else if("number"==typeof o)this._dimensions.push(i([o]));else if("string"==typeof o)this._dimensions.push(o);else throw TypeError("Dimension must be an Array, Matrix, number, string, or Range");this._sourceSize.push(l);// TODO: implement support for wildcard '*'
}}function i(e){// loop array elements
for(var r=0,n=e.length;r<n;r++)if("number"!=typeof e[r]||!eh(e[r]))throw TypeError("Index parameters must be positive integer numbers");// create matrix
return new t(e)}return(/**
   * Attach type information
   */n.prototype.type="Index",n.prototype.isIndex=!0,/**
   * Create a clone of the index
   * @memberof Index
   * @return {Index} clone
   */n.prototype.clone=function(){var e=new n;return e._dimensions=J(this._dimensions),e._isScalar=this._isScalar,e._sourceSize=this._sourceSize,e},/**
   * Create an index from an array with ranges/numbers
   * @memberof Index
   * @param {Array.<Array | number>} ranges
   * @return {Index} index
   * @private
   */n.create=function(e){var t=new n;return n.apply(t,e),t},/**
   * Retrieve the size of the index, the number of elements for each dimension.
   * @memberof Index
   * @returns {number[]} size
   */n.prototype.size=function(){for(var e=[],t=0,r=this._dimensions.length;t<r;t++){var n=this._dimensions[t];e[t]="string"==typeof n?1:n.size()[0]}return e},/**
   * Get the maximum value for each of the indexes ranges.
   * @memberof Index
   * @returns {number[]} max
   */n.prototype.max=function(){for(var e=[],t=0,r=this._dimensions.length;t<r;t++){var n=this._dimensions[t];e[t]="string"==typeof n?n:n.max()}return e},/**
   * Get the minimum value for each of the indexes ranges.
   * @memberof Index
   * @returns {number[]} min
   */n.prototype.min=function(){for(var e=[],t=0,r=this._dimensions.length;t<r;t++){var n=this._dimensions[t];e[t]="string"==typeof n?n:n.min()}return e},/**
   * Loop over each of the ranges of the index
   * @memberof Index
   * @param {Function} callback   Called for each range with a Range as first
   *                              argument, the dimension as second, and the
   *                              index object as third.
   */n.prototype.forEach=function(e){for(var t=0,r=this._dimensions.length;t<r;t++)e(this._dimensions[t],t,this)},/**
   * Retrieve the dimension for the given index
   * @memberof Index
   * @param {Number} dim                  Number of the dimension
   * @returns {Range | null} range
   */n.prototype.dimension=function(e){return this._dimensions[e]||null},/**
   * Test whether this index contains an object property
   * @returns {boolean} Returns true if the index is an object property
   */n.prototype.isObjectProperty=function(){return 1===this._dimensions.length&&"string"==typeof this._dimensions[0]},/**
   * Returns the object property name when the Index holds a single object property,
   * else returns null
   * @returns {string | null}
   */n.prototype.getObjectProperty=function(){return this.isObjectProperty()?this._dimensions[0]:null},/**
   * Test whether this index contains only a single value.
   *
   * This is the case when the index is created with only scalar values as ranges,
   * not for ranges resolving into a single value.
   * @memberof Index
   * @return {boolean} isScalar
   */n.prototype.isScalar=function(){return this._isScalar},/**
   * Expand the Index into an array.
   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]
   * @memberof Index
   * @returns {Array} array
   */n.prototype.toArray=function(){for(var e=[],t=0,r=this._dimensions.length;t<r;t++){var n=this._dimensions[t];e.push("string"==typeof n?n:n.toArray())}return e},/**
   * Get the primitive value of the Index, a two dimensional array.
   * Equivalent to Index.toArray().
   * @memberof Index
   * @returns {Array} array
   */n.prototype.valueOf=n.prototype.toArray,/**
   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'
   * @memberof Index
   * @returns {String} str
   */n.prototype.toString=function(){for(var e=[],t=0,r=this._dimensions.length;t<r;t++){var n=this._dimensions[t];"string"==typeof n?e.push(JSON.stringify(n)):e.push(n.toString())}return"["+e.join(", ")+"]"},/**
   * Get a JSON representation of the Index
   * @memberof Index
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Index", "ranges": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
   */n.prototype.toJSON=function(){return{mathjs:"Index",dimensions:this._dimensions}},/**
   * Instantiate an Index from a JSON object
   * @memberof Index
   * @param {Object} json A JSON object structured as:
   *                     `{"mathjs": "Index", "dimensions": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
   * @return {Index}
   */n.fromJSON=function(e){return n.create(e.dimensions)},n)},{isClass:!0});/**
 * Receives an array of booleans and returns an array of Numbers for Index
 * @param {Array} booleanArrayIndex An array of booleans
 * @return {Array} A set of numbers ready for index
 */function la(e){// gets an array of booleans and returns an array of numbers
var t=[];return e.forEach((e,r)=>{e&&t.push(r)}),t}var lo=ta("intersect",["typed","config","abs","add","addScalar","matrix","multiply","multiplyScalar","divideScalar","subtract","smaller","equalScalar","flatten","isZero","isNumeric"],e=>{var{typed:t,config:r,abs:n,add:i,addScalar:a,matrix:o,multiply:s,multiplyScalar:u,divideScalar:l,subtract:c,smaller:f,equalScalar:p,flatten:m,isZero:d,isNumeric:h}=e;/**
   * Calculates the point of intersection of two lines in two or three dimensions
   * and of a line and a plane in three dimensions. The inputs are in the form of
   * arrays or 1 dimensional matrices. The line intersection functions return null
   * if the lines do not meet.
   *
   * Note: Fill the plane coefficients as `x + y + z = c` and not as `x + y + z + c = 0`.
   *
   * Syntax:
   *
   *    math.intersect(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
   *    math.intersect(endPoint1, endPoint2, planeCoefficients)
   *
   * Examples:
   *
   *    math.intersect([0, 0], [10, 10], [10, 0], [0, 10])              // Returns [5, 5]
   *    math.intersect([0, 0, 0], [10, 10, 0], [10, 0, 0], [0, 10, 0])  // Returns [5, 5, 0]
   *    math.intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])            // Returns [7, -4, 3]
   *
   * @param  {Array | Matrix} w   Co-ordinates of first end-point of first line
   * @param  {Array | Matrix} x   Co-ordinates of second end-point of first line
   * @param  {Array | Matrix} y   Co-ordinates of first end-point of second line
   *                              OR Co-efficients of the plane's equation
   * @param  {Array | Matrix} z   Co-ordinates of second end-point of second line
   *                              OR undefined if the calculation is for line and plane
   * @return {Array}              Returns the point of intersection of lines/lines-planes
   */return t("intersect",{"Array, Array, Array":g,"Array, Array, Array, Array":y,"Matrix, Matrix, Matrix":function(e,t,r){var n=g(e.valueOf(),t.valueOf(),r.valueOf());return null===n?null:o(n)},"Matrix, Matrix, Matrix, Matrix":function(e,t,r,n){// TODO: output matrix type should match input matrix type
var i=y(e.valueOf(),t.valueOf(),r.valueOf(),n.valueOf());return null===i?null:o(i)}});function g(e,t,r){var n,i,o,s,f,p,m,d,g,y,x,N,w,D,E,A,S,C;if(e=v(e),t=v(t),r=v(r),!b(e))throw TypeError("Array with 3 numbers or BigNumbers expected for first argument");if(!b(t))throw TypeError("Array with 3 numbers or BigNumbers expected for second argument");if(!(4===(n=r).length&&h(n[0])&&h(n[1])&&h(n[2])&&h(n[3])))throw TypeError("Array with 4 numbers expected as third argument");return i=e[0],o=e[1],s=e[2],f=t[0],p=t[1],m=t[2],d=r[0],g=r[1],y=r[2],x=r[3],N=u(i,d),w=u(f,d),D=u(o,g),E=u(p,g),A=u(s,y),S=u(m,y),C=l(c(c(c(x,N),D),A),c(c(c(a(a(w,E),S),N),D),A)),[a(i,u(C,c(f,i))),a(o,u(C,c(p,o))),a(s,u(C,c(m,s)))]}function y(e,t,o,m){if(e=v(e),t=v(t),o=v(o),m=v(m),2===e.length){if(!x(e))throw TypeError("Array with 2 numbers or BigNumbers expected for first argument");if(!x(t))throw TypeError("Array with 2 numbers or BigNumbers expected for second argument");if(!x(o))throw TypeError("Array with 2 numbers or BigNumbers expected for third argument");if(!x(m))throw TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");return function(e,t,o,p){var m=c(e,t),h=c(o,p),g=c(u(m[0],h[1]),u(h[0],m[1]));if(d(g)||f(n(g),r.epsilon))return null;var y=u(h[0],e[1]),v=u(h[1],e[0]),x=u(h[0],o[1]),b=u(h[1],o[0]);return i(s(m,l(a(c(c(y,v),x),b),g)),e)}(e,t,o,m)}if(3===e.length){if(!b(e))throw TypeError("Array with 3 numbers or BigNumbers expected for first argument");if(!b(t))throw TypeError("Array with 3 numbers or BigNumbers expected for second argument");if(!b(o))throw TypeError("Array with 3 numbers or BigNumbers expected for third argument");if(!b(m))throw TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");return function(e,t,r,n,i,o,s,f,m,h,g,y){var v=N(e,s,h,s,t,f,g,f,r,m,y,m),x=N(h,s,n,e,g,f,i,t,y,m,o,r),b=N(e,s,n,e,t,f,i,t,r,m,o,r),w=N(h,s,h,s,g,f,g,f,y,m,y,m),D=N(n,e,n,e,i,t,i,t,o,r,o,r),E=c(u(v,x),u(b,w)),A=c(u(D,w),u(x,x));if(d(A))return null;var S=l(E,A),C=l(a(v,u(S,x)),w),M=a(e,u(S,c(n,e))),F=a(t,u(S,c(i,t))),B=a(r,u(S,c(o,r))),T=a(s,u(C,c(h,s))),O=a(f,u(C,c(g,f))),_=a(m,u(C,c(y,m)));return p(M,T)&&p(F,O)&&p(B,_)?[M,F,B]:null}(e[0],e[1],e[2],t[0],t[1],t[2],o[0],o[1],o[2],m[0],m[1],m[2])}throw TypeError("Arrays with two or thee dimensional points expected")}/** Coerce row and column 2-dim arrays to 1-dim array */function v(e){return(// row matrix
1===e.length?e[0]:e.length>1&&Array.isArray(e[0])&&e.every(e=>Array.isArray(e)&&1===e.length)?m(e):e)}function x(e){return 2===e.length&&h(e[0])&&h(e[1])}function b(e){return 3===e.length&&h(e[0])&&h(e[1])&&h(e[2])}function N(e,t,r,n,i,o,s,l,f,p,m,d){// (a - b)*(c - d) + (e - f)*(g - h) + (i - j)*(k - l)
var h=u(c(e,t),c(r,n)),g=u(c(i,o),c(s,l)),y=u(c(f,p),c(m,d));return a(a(h,g),y)}}),ls=ta("inv",["typed","matrix","divideScalar","addScalar","multiply","unaryMinus","det","identity","abs"],e=>{var{typed:t,matrix:r,divideScalar:n,addScalar:i,multiply:a,unaryMinus:o,det:s,identity:u,abs:l}=e;/**
   * Calculate the inverse of a square matrix.
   *
   * Syntax:
   *
   *     math.inv(x)
   *
   * Examples:
   *
   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]
   *     math.inv(4)                 // returns 0.25
   *     1 / 4                       // returns 0.25
   *
   * See also:
   *
   *     det, transpose
   *
   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
   * @return {number | Complex | Array | Matrix} The inverse of `x`.
   */return t("inv",{"Array | Matrix":function(e){var t=g(e)?e.size():eG(e);switch(t.length){case 1:// vector
if(1===t[0]){if(g(e))return r([n(1,e.valueOf()[0])]);return[n(1,e[0])]}throw RangeError("Matrix must be square (size: "+eP(t)+")");case 2:var i=t[0],a=t[1];if(i===a){if(g(e))return r(c(e.valueOf(),i,a),e.storage());return c(e,i,a)}throw RangeError("Matrix must be square (size: "+eP(t)+")");default:// multi dimensional array
throw RangeError("Matrix must be two dimensional (size: "+eP(t)+")")}},any:function(e){// scalar
return n(1,e);// FIXME: create a BigNumber one when configured for bignumbers
}});/**
   * Calculate the inverse of a square matrix
   * @param {Array[]} mat     A square matrix
   * @param {number} rows     Number of rows
   * @param {number} cols     Number of columns, must equal rows
   * @return {Array[]} inv    Inverse matrix
   * @private
   */function c(e,t,r){if(1===t){if(0===// this is a 1 x 1 matrix
(m=e[0][0]))throw Error("Cannot calculate inverse, determinant is zero");return[[n(1,m)]]}if(2===t){// this is a 2 x 2 matrix
var c,f,p,m,d,h=s(e);if(0===h)throw Error("Cannot calculate inverse, determinant is zero");return[[n(e[1][1],h),n(o(e[0][1]),h)],[n(o(e[1][0]),h),n(e[0][0],h)]]}// this is a matrix of 3 x 3 or larger
// calculate inverse using gauss-jordan elimination
//      https://en.wikipedia.org/wiki/Gaussian_elimination
//      http://mathworld.wolfram.com/MatrixInverse.html
//      http://math.uww.edu/~mcfarlat/inverse.htm
// make a copy of the matrix (only the arrays, not of the elements)
var g=e.concat();for(c=0;c<t;c++)g[c]=g[c].concat();// loop over all columns, and perform row reductions
for(var y=u(t).valueOf(),v=0;v<r;v++){// Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]
var x=l(g[v][v]),b=v;for(c=v+1;c<t;)l(g[c][v])>x&&(x=l(g[c][v]),b=c),c++;if(0===x)throw Error("Cannot calculate inverse, determinant is zero");(c=b)!==v&&(d=g[v],g[v]=g[c],g[c]=d,d=y[v],y[v]=y[c],y[c]=d);// eliminate non-zero values on the other rows at column c
var N=g[v],w=y[v];for(c=0;c<t;c++){var D=g[c],E=y[c];if(c!==v){if(0!==D[v]){// add (f * row c) to row r to eliminate the value
// at column c
for(p=n(o(D[v]),N[v]),f=v;f<r;f++)D[f]=i(D[f],a(p,N[f]));for(f=0;f<r;f++)E[f]=i(E[f],a(p,w[f]))}}else{for(// normalize value at Acc to 1,
// divide each value on row r with the value at Acc
p=N[v],f=v;f<r;f++)D[f]=n(D[f],p);for(f=0;f<r;f++)E[f]=n(E[f],p)}}}return y}}),lu="invmod",ll=ta(lu,["typed","config","BigNumber","xgcd","equal","smaller","mod","add","isInteger"],e=>{var{typed:t,config:r,BigNumber:n,xgcd:i,equal:a,smaller:o,mod:s,add:u,isInteger:l}=e;/**
   * Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation `ax ≣ 1 (mod b)`
   * See https://en.wikipedia.org/wiki/Modular_multiplicative_inverse.
   *
   * Syntax:
   *
   *    math.invmod(a, b)
   *
   * Examples:
   *
   *    math.invmod(8, 12)             // returns NaN
   *    math.invmod(7, 13)             // returns 2
   *    math.invmod(15151, 15122)      // returns 10429
   *
   * See also:
   *
   *    gcd, xgcd
   *
   * @param {number | BigNumber} a  An integer number
   * @param {number | BigNumber} b  An integer number
   * @return {number | BigNumber }  Returns an integer number
   *                              where `invmod(a,b)*a ≣ 1 (mod b)`
   */return t(lu,{"number, number":c,"BigNumber, BigNumber":c});function c(e,t){if(!l(e)||!l(t))throw Error("Parameters in function invmod must be integer numbers");if(e=s(e,t),a(t,0))throw Error("Divisor must be non zero");var r=i(e,t),[c,f]=r=r.valueOf();return a(c,n(1))?(o(f=s(f,t),n(0))&&(f=u(f,t)),f):NaN}}),lc="isInteger",lf=ta(lc,["typed"],e=>{var{typed:t}=e;/**
   * Test whether a value is an integer number.
   * The function supports `number`, `BigNumber`, and `Fraction`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isInteger(x)
   *
   * Examples:
   *
   *    math.isInteger(2)                     // returns true
   *    math.isInteger(0)                     // returns true
   *    math.isInteger(0.5)                   // returns false
   *    math.isInteger(math.bignumber(500))   // returns true
   *    math.isInteger(math.fraction(4))      // returns true
   *    math.isInteger('3')                   // returns true
   *    math.isInteger([3, 0.5, -2])          // returns [true, false, true]
   *    math.isInteger(math.complex('2-4i'))  // throws an error
   *
   * See also:
   *
   *    isNumeric, isPositive, isNegative, isZero
   *
   * @param {number | BigNumber | Fraction | Array | Matrix} x   Value to be tested
   * @return {boolean}  Returns true when `x` contains a numeric, integer value.
   *                    Throws an error in case of an unknown data type.
   */return t(lc,{number:eh,// TODO: what to do with isInteger(add(0.1, 0.2))  ?
BigNumber:function(e){return e.isInt()},Fraction:function(e){return 1===e.d&&isFinite(e.n)},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),lp="number";function lm(e){return e<0}function ld(e){return e>0}function lh(e){return 0===e}function lg(e){return Number.isNaN(e)}lm.signature=lp,ld.signature=lp,lh.signature=lp,lg.signature=lp;var ly="isNaN",lv=ta(ly,["typed"],e=>{var{typed:t}=e;/**
   * Test whether a value is NaN (not a number).
   * The function supports types `number`, `BigNumber`, `Fraction`, `Unit` and `Complex`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNaN(x)
   *
   * Examples:
   *
   *    math.isNaN(3)                     // returns false
   *    math.isNaN(NaN)                   // returns true
   *    math.isNaN(0)                     // returns false
   *    math.isNaN(math.bignumber(NaN))   // returns true
   *    math.isNaN(math.bignumber(0))     // returns false
   *    math.isNaN(math.fraction(-2, 5))  // returns false
   *    math.isNaN('-2')                  // returns false
   *    math.isNaN([2, 0, -3, NaN])       // returns [false, false, false, true]
   *
   * See also:
   *
   *    isNumeric, isNegative, isPositive, isZero, isInteger
   *
   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is NaN.
   *                    Throws an error in case of an unknown data type.
   */return t(ly,{number:lg,BigNumber:function(e){return e.isNaN()},Fraction:function(e){return!1},Complex:function(e){return e.isNaN()},Unit:function(e){return Number.isNaN(e.value)},"Array | Matrix":function(e){return tq(e,Number.isNaN)}})}),lx="isNegative",lb=ta(lx,["typed"],e=>{var{typed:t}=e;/**
   * Test whether a value is negative: smaller than zero.
   * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNegative(x)
   *
   * Examples:
   *
   *    math.isNegative(3)                     // returns false
   *    math.isNegative(-2)                    // returns true
   *    math.isNegative(0)                     // returns false
   *    math.isNegative(-0)                    // returns false
   *    math.isNegative(math.bignumber(2))     // returns false
   *    math.isNegative(math.fraction(-2, 5))  // returns true
   *    math.isNegative('-2')                  // returns true
   *    math.isNegative([2, 0, -3])            // returns [false, false, true]
   *
   * See also:
   *
   *    isNumeric, isPositive, isZero, isInteger
   *
   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */return t(lx,{number:lm,BigNumber:function(e){return e.isNeg()&&!e.isZero()&&!e.isNaN()},Fraction:function(e){return e.s<0;// It's enough to decide on the sign
},Unit:t.referToSelf(e=>r=>t.find(e,r.valueType())(r.value)),"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),lN="isNumeric",lw=ta(lN,["typed"],e=>{var{typed:t}=e;/**
   * Test whether a value is an numeric value.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNumeric(x)
   *
   * Examples:
   *
   *    math.isNumeric(2)                     // returns true
   *    math.isNumeric('2')                   // returns false
   *    math.hasNumericValue('2')             // returns true
   *    math.isNumeric(0)                     // returns true
   *    math.isNumeric(math.bignumber(500))   // returns true
   *    math.isNumeric(math.fraction(4))      // returns true
   *    math.isNumeric(math.complex('2-4i'))  // returns false
   *    math.isNumeric([2.3, 'foo', false])   // returns [true, false, true]
   *
   * See also:
   *
   *    isZero, isPositive, isNegative, isInteger, hasNumericValue
   *
   * @param {*} x       Value to be tested
   * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,
   *                    `Fraction`, or `boolean`. Returns false for other types.
   *                    Throws an error in case of unknown types.
   */return t(lN,{"number | BigNumber | Fraction | boolean":()=>!0,"Complex | Unit | string | null | undefined | Node":()=>!1,"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),lD="isPositive",lE=ta(lD,["typed"],e=>{var{typed:t}=e;/**
   * Test whether a value is positive: larger than zero.
   * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isPositive(x)
   *
   * Examples:
   *
   *    math.isPositive(3)                     // returns true
   *    math.isPositive(-2)                    // returns false
   *    math.isPositive(0)                     // returns false
   *    math.isPositive(-0)                    // returns false
   *    math.isPositive(0.5)                   // returns true
   *    math.isPositive(math.bignumber(2))     // returns true
   *    math.isPositive(math.fraction(-2, 5))  // returns false
   *    math.isPositive(math.fraction(1, 3))   // returns true
   *    math.isPositive('2')                   // returns true
   *    math.isPositive([2, 0, -3])            // returns [true, false, false]
   *
   * See also:
   *
   *    isNumeric, isZero, isNegative, isInteger
   *
   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */return t(lD,{number:ld,BigNumber:function(e){return!e.isNeg()&&!e.isZero()&&!e.isNaN()},Fraction:function(e){return e.s>0&&e.n>0},Unit:t.referToSelf(e=>r=>t.find(e,r.valueType())(r.value)),"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),lA="isPrime",lS=ta(lA,["typed"],e=>{var{typed:t}=e;/**
   * Test whether a value is prime: has no divisors other than itself and one.
   * The function supports type `number`, `bignumber`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isPrime(x)
   *
   * Examples:
   *
   *    math.isPrime(3)                     // returns true
   *    math.isPrime(-2)                    // returns false
   *    math.isPrime(0)                     // returns false
   *    math.isPrime(-0)                    // returns false
   *    math.isPrime(0.5)                   // returns false
   *    math.isPrime('2')                   // returns true
   *    math.isPrime([2, 17, 100])           // returns [true, true, false]
   *
   * See also:
   *
   *    isNumeric, isZero, isNegative, isInteger
   *
   * @param {number | BigNumber | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */return t(lA,{number:function(e){if(0*e!=0)return!1;if(e<=3)return e>1;if(e%2==0||e%3==0)return!1;for(var t=5;t*t<=e;t+=6)if(e%t==0||e%(t+2)==0)return!1;return!0},BigNumber:function(e){if(0*e.toNumber()!=0)return!1;if(e.lte(3))return e.gt(1);if(e.mod(2).eq(0)||e.mod(3).eq(0))return!1;if(e.lt(4294967296)){for(var t=e.toNumber(),r=5;r*r<=t;r+=6)if(t%r==0||t%(r+2)==0)return!1;return!0}e=new(e.constructor.clone({precision:2*e.toFixed(0).length}))(e);for(var n=0,i=e.sub(1);i.mod(2).eq(0);)i=i.div(2),n+=1;var a=null;// https://en.wikipedia.org/wiki/Miller–Rabin_primality_test#Testing_against_small_sets_of_bases
if(e.lt("3317044064679887385961981"))a=[2,3,5,7,11,13,17,19,23,29,31,37,41].filter(t=>t<e);else{var o=Math.min(e.toNumber()-2,Math.floor(2*Math.pow(e.toFixed(0).length*Math.log(10),2)));a=[];for(var s=2;s<=o;s+=1)a.push(o)}for(var u=0;u<a.length;u+=1){var l=a[u],c=function(e,t,r){for(// exponent can be huge, use non-recursive variant
var n=1;!t.eq(0);)t.mod(2).eq(0)?(t=t.div(2),e=e.mul(e).mod(r)):(t=t.sub(1),n=e.mul(n).mod(r));return n}(e.sub(e).add(l),i,e);if(!c.eq(1)){for(var f=0,p=c;!p.eq(e.sub(1));f+=1,p=p.mul(p).mod(e))if(f===n-1)return!1}}return!0},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),lC="isZero",lM=ta(lC,["typed"],e=>{var{typed:t}=e;/**
   * Test whether a value is zero.
   * The function can check for zero for types `number`, `BigNumber`, `Fraction`,
   * `Complex`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isZero(x)
   *
   * Examples:
   *
   *    math.isZero(0)                      // returns true
   *    math.isZero(2)                      // returns false
   *    math.isZero(0.5)                    // returns false
   *    math.isZero(math.bignumber(0))      // returns true
   *    math.isZero(math.fraction(0))       // returns true
   *    math.isZero(math.fraction(1,3))     // returns false
   *    math.isZero(math.complex('2 - 4i')) // returns false
   *    math.isZero(math.complex('0i'))     // returns true
   *    math.isZero('0')                    // returns true
   *    math.isZero('2')                    // returns false
   *    math.isZero([2, 0, -3])             // returns [false, true, false]
   *
   * See also:
   *
   *    isNumeric, isPositive, isNegative, isInteger
   *
   * @param {number | BigNumber | Complex | Fraction | Unit | Array | Matrix} x       Value to be tested
   * @return {boolean}  Returns true when `x` is zero.
   *                    Throws an error in case of an unknown data type.
   */return t(lC,{number:lh,BigNumber:function(e){return e.isZero()},Complex:function(e){return 0===e.re&&0===e.im},Fraction:function(e){return 1===e.d&&0===e.n},Unit:t.referToSelf(e=>r=>t.find(e,r.valueType())(r.value)),"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),lF="kldivergence",lB=ta(lF,["typed","matrix","divide","sum","multiply","map","dotDivide","log","isNumeric"],e=>{var{typed:t,matrix:r,divide:n,sum:i,multiply:a,map:o,dotDivide:s,log:u,isNumeric:l}=e;/**
     * Calculate the Kullback-Leibler (KL) divergence  between two distributions
     *
     * Syntax:
     *
     *     math.kldivergence(x, y)
     *
     * Examples:
     *
     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153
     *
     *
     * @param  {Array | Matrix} q    First vector
     * @param  {Array | Matrix} p    Second vector
     * @return {number}              Returns distance between q and p
     */return t(lF,{"Array, Array":function(e,t){return c(r(e),r(t))},"Matrix, Array":function(e,t){return c(e,r(t))},"Array, Matrix":function(e,t){return c(r(e),t)},"Matrix, Matrix":function(e,t){return c(e,t)}});function c(e,t){var r=t.size().length,c=e.size().length;if(r>1)throw Error("first object must be one dimensional");if(c>1)throw Error("second object must be one dimensional");if(r!==c)throw Error("Length of two vectors must be equal");if(0===i(e))throw Error("Sum of elements in first object must be non zero");if(0===i(t))throw Error("Sum of elements in second object must be non zero");var f=n(e,i(e)),p=n(t,i(t)),m=i(a(f,o(s(f,p),e=>u(e))));return l(m)?m:Number.NaN}}),lT="kron",lO=ta(lT,["typed","matrix","multiplyScalar"],e=>{var{typed:t,matrix:r,multiplyScalar:n}=e;/**
     * Calculates the kronecker product of 2 matrices or vectors.
     *
     * NOTE: If a one dimensional vector / matrix is given, it will be
     * wrapped so its two dimensions.
     * See the examples.
     *
     * Syntax:
     *
     *    math.kron(x, y)
     *
     * Examples:
     *
     *    math.kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])
     *    // returns [ [ 1, 2, 0, 0 ], [ 3, 4, 0, 0 ], [ 0, 0, 1, 2 ], [ 0, 0, 3, 4 ] ]
     *
     *    math.kron([1,1], [2,3,4])
     *    // returns [ [ 2, 3, 4, 2, 3, 4 ] ]
     *
     * See also:
     *
     *    multiply, dot, cross
     *
     * @param  {Array | Matrix} x     First vector
     * @param  {Array | Matrix} y     Second vector
     * @return {Array | Matrix}       Returns the kronecker product of `x` and `y`
     */return t(lT,{"Matrix, Matrix":function(e,t){return r(i(e.toArray(),t.toArray()))},"Matrix, Array":function(e,t){return r(i(e.toArray(),t))},"Array, Matrix":function(e,t){return r(i(e,t.toArray()))},"Array, Array":i});/**
     * Calculate the kronecker product of two matrices / vectors
     * @param {Array} a  First vector
     * @param {Array} b  Second vector
     * @returns {Array} Returns the kronecker product of x and y
     * @private
     */function i(e,t){if(1===eG(e).length&&(e=[e]),1===eG(t).length&&(t=[t]),eG(e).length>2||eG(t).length>2)throw RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = "+JSON.stringify(e.length)+", y = "+JSON.stringify(t.length)+")");var r=[],i=[];return e.map(function(e){return t.map(function(t){return i=[],r.push(i),e.map(function(e){return t.map(function(t){return i.push(n(e,t))})})})})&&r}}),l_="larger",lz=ta(l_,["typed","config","matrix","DenseMatrix","concat"],e=>{var{typed:t,config:r,matrix:n,DenseMatrix:i,concat:a}=e,o=i5({typed:t}),s=ov({typed:t,DenseMatrix:i}),u=i6({typed:t,DenseMatrix:i}),l=iI({typed:t,matrix:n,concat:a}),c=oL({typed:t});/**
   * Test whether value x is larger than y.
   *
   * The function returns true when x is larger than y and the relative
   * difference between x and y is larger than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.larger(x, y)
   *
   * Examples:
   *
   *    math.larger(2, 3)             // returns false
   *    math.larger(5, 2 + 2)         // returns true
   *
   *    const a = math.unit('5 cm')
   *    const b = math.unit('2 inch')
   *    math.larger(a, b)             // returns false
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, largerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is larger than y, else returns false
   */return t(l_,lq({typed:t,config:r}),{"boolean, boolean":(e,t)=>e>t,"BigNumber, BigNumber":function(e,t){return e.gt(t)&&!oC(e,t,r.epsilon)},"Fraction, Fraction":(e,t)=>1===e.compare(t),"Complex, Complex":function(){throw TypeError("No ordering relation is defined for complex numbers")}},c,l({SS:s,DS:o,Ss:u}))}),lq=ta(l_,["typed","config"],e=>{var{typed:t,config:r}=e;return t(l_,{"number, number":function(e,t){return e>t&&!eB(e,t,r.epsilon)}})}),lk="largerEq",lI=ta(lk,["typed","config","matrix","DenseMatrix","concat"],e=>{var{typed:t,config:r,matrix:n,DenseMatrix:i,concat:a}=e,o=i5({typed:t}),s=ov({typed:t,DenseMatrix:i}),u=i6({typed:t,DenseMatrix:i}),l=iI({typed:t,matrix:n,concat:a}),c=oL({typed:t});/**
   * Test whether value x is larger or equal to y.
   *
   * The function returns true when x is larger than y or the relative
   * difference between x and y is smaller than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.largerEq(x, y)
   *
   * Examples:
   *
   *    math.larger(2, 1 + 1)         // returns false
   *    math.largerEq(2, 1 + 1)       // returns true
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, larger, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is larger or equal to y, else returns false
   */return t(lk,lR({typed:t,config:r}),{"boolean, boolean":(e,t)=>e>=t,"BigNumber, BigNumber":function(e,t){return e.gte(t)||oC(e,t,r.epsilon)},"Fraction, Fraction":(e,t)=>-1!==e.compare(t),"Complex, Complex":function(){throw TypeError("No ordering relation is defined for complex numbers")}},c,l({SS:s,DS:o,Ss:u}))}),lR=ta(lk,["typed","config"],e=>{var{typed:t,config:r}=e;return t(lk,{"number, number":function(e,t){return e>=t||eB(e,t,r.epsilon)}})}),lP=ta("lcm",["typed","matrix","equalScalar","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,concat:i}=e,a=iU({typed:t,equalScalar:n}),o=i$({typed:t,equalScalar:n}),s=iL({typed:t,equalScalar:n}),u=iI({typed:t,matrix:r,concat:i}),l="number | BigNumber | Fraction | Matrix | Array",c={};/**
   * Calculate the least common multiple for two or more values or arrays.
   *
   * lcm is defined as:
   *
   *     lcm(a, b) = abs(a * b) / gcd(a, b)
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.lcm(a, b)
   *    math.lcm(a, b, c, ...)
   *
   * Examples:
   *
   *    math.lcm(4, 6)               // returns 12
   *    math.lcm(6, 21)              // returns 42
   *    math.lcm(6, 21, 5)           // returns 210
   *
   *    math.lcm([4, 6], [6, 21])    // returns [12, 42]
   *
   * See also:
   *
   *    gcd, xgcd
   *
   * @param {... number | BigNumber | Array | Matrix} args  Two or more integer numbers
   * @return {number | BigNumber | Array | Matrix}                           The least common multiple
   */return c["".concat(l,", ").concat(l,", ...").concat(l)]=t.referToSelf(e=>(t,r,n)=>{for(var i=e(t,r),a=0;a<n.length;a++)i=e(i,n[a]);return i}),t("lcm",{"number, number":n4,"BigNumber, BigNumber":/**
   * Calculate lcm for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} Returns the least common multiple of a and b
   * @private
   */function(e,t){if(!e.isInt()||!t.isInt())throw Error("Parameters in function lcm must be integer numbers");if(e.isZero())return e;if(t.isZero())return t;for(// https://en.wikipedia.org/wiki/Euclidean_algorithm
// evaluate lcm here inline to reduce overhead
var r=e.times(t);!t.isZero();){var n=t;t=e.mod(n),e=n}return r.div(e).abs()},"Fraction, Fraction":(e,t)=>e.lcm(t)},u({SS:o,DS:a,Ss:s}),c)}),lj=ta("matAlgo08xS0Sid",["typed","equalScalar"],e=>{var{typed:t,equalScalar:r}=e;/**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
   * Callback function invoked MAX(NNZA, NNZB) times
   *
   *
   *          ┌  f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
   * C(i,j) = ┤  A(i,j)       ; A(i,j) !== 0 && B(i,j) === 0
   *          └  0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */return function(e,n,i){// sparse matrix arrays
var a,o,s,u,l,c=e._values,f=e._index,p=e._ptr,m=e._size,d=e._datatype,h=n._values,g=n._index,y=n._ptr,v=n._size,x=n._datatype;// validate dimensions
if(m.length!==v.length)throw new eH(m.length,v.length);// check rows & columns
if(m[0]!==v[0]||m[1]!==v[1])throw RangeError("Dimension mismatch. Matrix A ("+m+") must match Matrix B ("+v+")");// sparse matrix cannot be a Pattern matrix
if(!c||!h)throw Error("Cannot perform operation on Pattern Sparse Matrices");// rows & columns
var b=m[0],N=m[1],w=r,D=0,E=i;"string"==typeof d&&d===x&&(// datatype
a=d,// find signature that matches (dt, dt)
w=t.find(r,[a,a]),// convert 0 to the same datatype
D=t.convert(0,a),// callback
E=t.find(i,[a,a]));// loop columns
for(var A=[],S=[],C=[],M=[],F=[],B=0;B<N;B++){// update cptr
C[B]=S.length;// columns mark
var T=B+1;// loop values in a
for(s=p[B],u=p[B+1],o=s;o<u;o++)// mark workspace
F[// row
l=f[o]]=T,// set value
M[l]=c[o],// add index
S.push(l);// loop values in b
for(s=y[B],u=y[B+1],o=s;o<u;o++)// check value exists in workspace
F[// row
l=g[o]]===T&&(M[l]=E(M[l],h[o]));// loop index in j
for(// initialize first index in j
o=C[B];o<S.length;){// value @ i
var O=M[// row
l=S[o]];// check for zero value
w(O,D)?S.splice(o,1):(// push value
A.push(O),// increment pointer
o++)}}// return sparse matrix
return(// update cptr
C[N]=S.length,e.createSparseMatrix({values:A,index:S,ptr:C,size:[b,N],datatype:a}))}}),lU=ta("useMatrixForArrayScalar",["typed","matrix"],e=>{var{typed:t,matrix:r}=e;return{"Array, number":t.referTo("DenseMatrix, number",e=>(t,n)=>e(r(t),n).valueOf()),"Array, BigNumber":t.referTo("DenseMatrix, BigNumber",e=>(t,n)=>e(r(t),n).valueOf()),"number, Array":t.referTo("number, DenseMatrix",e=>(t,n)=>e(t,r(n)).valueOf()),"BigNumber, Array":t.referTo("BigNumber, DenseMatrix",e=>(t,n)=>e(t,r(n)).valueOf())}}),lL="leftShift",l$=ta(lL,["typed","matrix","equalScalar","zeros","DenseMatrix","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,zeros:i,DenseMatrix:a,concat:o}=e,s=iT({typed:t}),u=iU({typed:t,equalScalar:n}),l=lj({typed:t,equalScalar:n}),c=i_({typed:t,DenseMatrix:a}),f=iL({typed:t,equalScalar:n}),p=iq({typed:t}),m=iI({typed:t,matrix:r,concat:o}),d=lU({typed:t,matrix:r});/**
   * Bitwise left logical shift of a value x by y number of bits, `x << y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.leftShift(x, y)
   *
   * Examples:
   *
   *    math.leftShift(1, 2)               // returns number 4
   *
   *    math.leftShift([1, 2, 4], 4)       // returns Array [16, 32, 64]
   *
   * See also:
   *
   *    leftShift, bitNot, bitOr, bitXor, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x Value to be shifted
   * @param  {number | BigNumber} y Amount of shifts
   * @return {number | BigNumber | Array | Matrix} `x` shifted left `y` times
   */return t(lL,{"number, number":ol,"BigNumber, BigNumber":or,"SparseMatrix, number | BigNumber":t.referToSelf(e=>(t,r)=>// check scalar
        n(r,0)?t.clone():f(t,r,e,!1)),"DenseMatrix, number | BigNumber":t.referToSelf(e=>(t,r)=>// check scalar
        n(r,0)?t.clone():p(t,r,e,!1)),"number | BigNumber, SparseMatrix":t.referToSelf(e=>(t,r)=>// check scalar
        n(t,0)?i(r.size(),r.storage()):c(r,t,e,!0)),"number | BigNumber, DenseMatrix":t.referToSelf(e=>(t,r)=>// check scalar
        n(t,0)?i(r.size(),r.storage()):p(r,t,e,!0))},d,m({SS:l,DS:s,SD:u}))}),lH="lgamma",lZ=ta(lH,["Complex","typed"],e=>{var{Complex:t,typed:r}=e,n=[-.029550653594771242,.00641025641025641,-.0019175269175269176,8417508417508417e-19,-.0005952380952380953,7936507936507937e-19,-.002777777777777778,.08333333333333333];/**
   * Logarithm of the gamma function for real, positive numbers and complex numbers,
   * using Lanczos approximation for numbers and Stirling series for complex numbers.
   *
   * Syntax:
   *
   *    math.lgamma(n)
   *
   * Examples:
   *
   *    math.lgamma(5)       // returns 3.178053830347945
   *    math.lgamma(0)       // returns Infinity
   *    math.lgamma(-0.5)    // returns NaN
   *    math.lgamma(math.i)  // returns -0.6509231993018536 - 1.8724366472624294i
   *
   * See also:
   *
   *    gamma
   *
   * @param {number | Complex} n   A real or complex number
   * @return {number | Complex}    The log gamma of `n`
   */return r(lH,{number:uH,Complex:function e(r){if(r.isNaN())return new t(NaN,NaN);if(0===r.im)return new t(uH(r.re),0);if(r.re>=7||Math.abs(r.im)>=7)return i(r);if(r.re<=.1){// Reflection formula. see Proposition 3.1 in [1]
var n,o=(!0^((n=r.im)>0||!(n<0)&&1/n==1/0)?-6.283185307179586:6.283185307179586)*Math.floor(.5*r.re+.25),s=r.mul(Math.PI).sin().log(),u=e(new t(1-r.re,-r.im));return new t(1.1447298858494002,o).sub(s).sub(u)}return r.im>=0?a(r):a(r.conjugate()).conjugate()},BigNumber:function(){throw Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber")}});function i(e){for(var r=e.sub(.5).mul(e.log()).sub(e).add(.9189385332046728),i=new t(1,0).div(e),a=i.div(e),o=-.029550653594771242,s=.00641025641025641,u=2*a.re,l=a.re*a.re+a.im*a.im,c=2;c<8;c++){var f=s;s=-l*o+n[c],o=u*o+f}// formula ref in [2]
// computation ref:
// https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L101
// left part
// x (log(x) - 1) + 1/2 (log(2PI) - log(x))
// => (x - 0.5) * log(x) - x + log(2PI) / 2
var p=i.mul(a.mul(o).add(s));// plus left and right
return r.add(p)}function a(e){// computation ref:
// https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L78
var r=0,n=0,a=e;for(e=e.add(1);e.re<=7;){var o=(a=a.mul(e)).im<0?1:0;0!==o&&0===n&&r++,n=o,e=e.add(1)}return i(e).sub(a.log()).sub(new t(0,2*r*Math.PI*1))}}),lG=ta("log",["config","typed","divideScalar","Complex"],e=>{var{typed:t,config:r,divideScalar:n,Complex:i}=e;/**
   * Calculate the logarithm of a value.
   *
   * To avoid confusion with the matrix logarithm, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.log(x)
   *    math.log(x, base)
   *
   * Examples:
   *
   *    math.log(3.5)                  // returns 1.252762968495368
   *    math.exp(math.log(2.4))        // returns 2.4
   *
   *    math.pow(10, 4)                // returns 10000
   *    math.log(10000, 10)            // returns 4
   *    math.log(10000) / math.log(10) // returns 4
   *
   *    math.log(1024, 2)              // returns 10
   *    math.pow(2, 10)                // returns 1024
   *
   * See also:
   *
   *    exp, log2, log10, log1p
   *
   * @param {number | BigNumber | Complex} x
   *            Value for which to calculate the logarithm.
   * @param {number | BigNumber | Complex} [base=e]
   *            Optional base for the logarithm. If not provided, the natural
   *            logarithm of `x` is calculated.
   * @return {number | BigNumber | Complex}
   *            Returns the logarithm of `x`
   */return t("log",{number:function(e){var t;return e>=0||r.predictable?t?Math.log(e)/Math.log(t):Math.log(e):new i(e,0).log()},Complex:function(e){return e.log()},BigNumber:function(e){return!e.isNegative()||r.predictable?e.ln():new i(e.toNumber(),0).log()},"any, any":t.referToSelf(e=>(t,r)=>n(e(t),e(r)))})}),lV="log10",lW=ta(lV,["typed","config","Complex"],e=>{var{typed:t,config:r,Complex:n}=e;/**
   * Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log10(x)
   *
   * Examples:
   *
   *    math.log10(0.00001)            // returns -5
   *    math.log10(10000)              // returns 4
   *    math.log(10000) / math.log(10) // returns 4
   *    math.pow(10, 4)                // returns 10000
   *
   * See also:
   *
   *    exp, log, log1p, log2
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the 10-base logarithm of `x`
   */return t(lV,{number:function(e){return e>=0||r.predictable?ev(e):new n(e,0).log().div(Math.LN10)},Complex:function(e){return new n(e).log().div(Math.LN10)},BigNumber:function(e){return!e.isNegative()||r.predictable?e.log():new n(e.toNumber(),0).log().div(Math.LN10)},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),lY="log1p",lJ=ta(lY,["typed","config","divideScalar","log","Complex"],e=>{var{typed:t,config:r,divideScalar:n,log:i,Complex:a}=e;/**
   * Calculate the logarithm of a `value+1`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log1p(x)
   *    math.log1p(x, base)
   *
   * Examples:
   *
   *    math.log1p(2.5)                 // returns 1.252762968495368
   *    math.exp(math.log1p(1.4))       // returns 2.4
   *
   *    math.pow(10, 4)                 // returns 10000
   *    math.log1p(9999, 10)            // returns 4
   *    math.log1p(9999) / math.log(10) // returns 4
   *
   * See also:
   *
   *    exp, log, log2, log10
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm of `x+1`.
   * @param {number | BigNumber | Complex} [base=e]
   *            Optional base for the logarithm. If not provided, the natural
   *            logarithm of `x+1` is calculated.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the logarithm of `x+1`
   */return t(lY,{number:function(e){return e>=-1||r.predictable?ex(e):o(new a(e,0))},Complex:o,BigNumber:function(e){var t=e.plus(1);return!t.isNegative()||r.predictable?t.ln():o(new a(e.toNumber(),0))},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e)),"any, any":t.referToSelf(e=>(t,r)=>n(e(t),i(r)))});/**
   * Calculate the natural logarithm of a complex number + 1
   * @param {Complex} x
   * @returns {Complex}
   * @private
   */function o(e){var t=e.re+1;return new a(Math.log(Math.sqrt(t*t+e.im*e.im)),Math.atan2(e.im,t))}}),lX="log2",lQ=ta(lX,["typed","config","Complex"],e=>{var{typed:t,config:r,Complex:n}=e;/**
   * Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log2(x)
   *
   * Examples:
   *
   *    math.log2(0.03125)           // returns -5
   *    math.log2(16)                // returns 4
   *    math.log2(16) / math.log2(2) // returns 4
   *    math.pow(2, 4)               // returns 16
   *
   * See also:
   *
   *    exp, log, log1p, log10
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the 2-base logarithm of `x`
   */return t(lX,{number:function(e){return e>=0||r.predictable?ey(e):i(new n(e,0))},Complex:i,BigNumber:function(e){return!e.isNegative()||r.predictable?e.log(2):i(new n(e.toNumber(),0))},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))});/**
   * Calculate log2 for a complex value
   * @param {Complex} x
   * @returns {Complex}
   * @private
   */function i(e){var t=Math.sqrt(e.re*e.re+e.im*e.im);return new n(Math.log2?Math.log2(t):Math.log(t)/Math.LN2,Math.atan2(e.im,e.re)/Math.LN2)}});function lK(e){var{DenseMatrix:t}=e;/**
   * Validates matrix and column vector b for backward/forward substitution algorithms.
   *
   * @param {Matrix} m            An N x N matrix
   * @param {Array | Matrix} b    A column vector
   * @param {Boolean} copy        Return a copy of vector b
   *
   * @return {DenseMatrix}        Dense column vector b
   */return function(e,r,n){var i=e.size();if(2!==i.length)throw RangeError("Matrix must be two dimensional (size: "+eP(i)+")");var a=i[0];if(a!==i[1])throw RangeError("Matrix must be square (size: "+eP(i)+")");var o=[];if(g(r)){var s=r.size(),u=r._data;// 1-dim vector
if(1===s.length){if(s[0]!==a)throw RangeError("Dimension mismatch. Matrix columns must match vector length.");for(var l=0;l<a;l++)o[l]=[u[l]];return new t({data:o,size:[a,1],datatype:r._datatype})}// 2-dim column
if(2===s.length){if(s[0]!==a||1!==s[1])throw RangeError("Dimension mismatch. Matrix columns must match vector length.");if(v(r)){if(n){o=[];for(var c=0;c<a;c++)o[c]=[u[c][0]];return new t({data:o,size:[a,1],datatype:r._datatype})}return r}if(x(r)){for(var f=0;f<a;f++)o[f]=[0];for(var p=r._values,m=r._index,d=r._ptr,y=d[1],b=d[0];b<y;b++)o[m[b]][0]=p[b];return new t({data:o,size:[a,1],datatype:r._datatype})}}throw RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.")}if(h(r)){var N=eG(r);if(1===N.length){if(N[0]!==a)throw RangeError("Dimension mismatch. Matrix columns must match vector length.");for(var w=0;w<a;w++)o[w]=[r[w]];return new t({data:o,size:[a,1]})}if(2===N.length){if(N[0]!==a||1!==N[1])throw RangeError("Dimension mismatch. Matrix columns must match vector length.");for(var D=0;D<a;D++)o[D]=[r[D][0]];return new t({data:o,size:[a,1]})}throw RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.")}}}var l0="lsolve",l1=ta(l0,["typed","matrix","divideScalar","multiplyScalar","subtractScalar","equalScalar","DenseMatrix"],e=>{var{typed:t,matrix:r,divideScalar:n,multiplyScalar:i,subtractScalar:a,equalScalar:o,DenseMatrix:s}=e,u=lK({DenseMatrix:s});/**
   * Finds one solution of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix. Throws an error if there's no solution.
   *
   * `L * x = b`
   *
   * Syntax:
   *
   *    math.lsolve(L, b)
   *
   * Examples:
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = lsolve(a, b)  // [[-5.5], [20]]
   *
   * See also:
   *
   *    lsolveAll, lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} L       A N x N matrix or array (L)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
   */return t(l0,{"SparseMatrix, Array | Matrix":function(e,t){return function(e,t){// loop columns
for(var r=// validate matrix and vector, return copy of column vector b
(t=u(e,t,!0))._data,l=e._size[0],c=e._size[1],f=e._values,p=e._index,m=e._ptr,d=[],h=0;h<c;h++){var g=r[h][0]||0;if(o(g,0))d[h]=[0];else{// values in column, find value at [j, j]
for(var y=0,v=[],x=[],b=m[h],N=m[h+1],w=b;w<N;w++){var D=p[w];// check row (rows are not sorted!)
D===h?y=f[w]:D>h&&(// store lower triangular
v.push(f[w]),x.push(D))}// at this point we must have a value in vjj
if(o(y,0))throw Error("Linear system cannot be solved since matrix is singular");for(var E=n(g,y),A=0,S=x.length;A<S;A++){var C=x[A];r[C]=[a(r[C][0]||0,i(E,v[A]))]}d[h]=[E]}}return new s({data:d,size:[l,1]})}(e,t)},"DenseMatrix, Array | Matrix":function(e,t){return l(e,t)},"Array, Array | Matrix":function(e,t){return l(r(e),t).valueOf()}});function l(e,t){// loop columns
for(var r=// validate matrix and vector, return copy of column vector b
(t=u(e,t,!0))._data,l=e._size[0],c=e._size[1],f=[],p=e._data,m=0;m<c;m++){var d=r[m][0]||0,h=void 0;if(o(d,0))h=0;else{// non-degenerate row, find solution
var g=p[m][m];if(o(g,0))throw Error("Linear system cannot be solved since matrix is singular");h=n(d,g);// loop rows
for(var y=m+1;y<l;y++)r[y]=[a(r[y][0]||0,i(h,p[y][m]))]}f[m]=[h]}return new s({data:f,size:[l,1]})}}),l2="lsolveAll",l3=ta(l2,["typed","matrix","divideScalar","multiplyScalar","subtractScalar","equalScalar","DenseMatrix"],e=>{var{typed:t,matrix:r,divideScalar:n,multiplyScalar:i,subtractScalar:a,equalScalar:o,DenseMatrix:s}=e,u=lK({DenseMatrix:s});/**
   * Finds all solutions of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix.
   *
   * `L * x = b`
   *
   * Syntax:
   *
   *    math.lsolveAll(L, b)
   *
   * Examples:
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = lsolveAll(a, b)  // [ [[-5.5], [20]] ]
   *
   * See also:
   *
   *    lsolve, lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} L       A N x N matrix or array (L)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system
   */return t(l2,{"SparseMatrix, Array | Matrix":function(e,t){return function(e,t){// loop columns
for(var r=[u(e,t,!0)._data.map(e=>e[0])],l=e._size[0],c=e._size[1],f=e._values,p=e._index,m=e._ptr,d=0;d<c;d++)// loop right-hand sides
for(var h=r.length,g=0;g<h;g++){for(var y=r[g],v=[],x=[],b=m[d],N=m[d+1],w=0,D=b;D<N;D++){var E=p[D];// check row
E===d?w=f[D]:E>d&&(// store lower triangular
v.push(f[D]),x.push(E))}if(o(w,0)){if(o(y[d],0)){if(0===g){// singular row, RHS is zero
var A=[...y];A[d]=1;for(var S=0,C=x.length;S<C;S++){var M=x[S];A[M]=a(A[M],v[S])}r.push(A)}}else{// singular row, nonzero RHS
if(0===g)return[];// This RHS is invalid but other solutions may still exist
r.splice(g,1),g-=1,h-=1}}else{// non-singular row
y[d]=n(y[d],w);for(var F=0,B=x.length;F<B;F++){var T=x[F];y[T]=a(y[T],i(y[d],v[F]))}}}return r.map(e=>new s({data:e.map(e=>[e]),size:[l,1]}))}(e,t)},"DenseMatrix, Array | Matrix":function(e,t){return l(e,t)},"Array, Array | Matrix":function(e,t){return l(r(e),t).map(e=>e.valueOf())}});function l(e,t){// loop columns
for(var r=[u(e,t,!0)._data.map(e=>e[0])],l=e._data,c=e._size[0],f=e._size[1],p=0;p<f;p++)// loop right-hand sides
for(var m=r.length,d=0;d<m;d++){var h=r[d];if(o(l[p][p],0)){if(o(h[p],0)){if(0===d){// singular row, RHS is zero
var g=[...h];g[p]=1;for(var y=p+1;y<f;y++)g[y]=a(g[y],l[y][p]);r.push(g)}}else{// singular row, nonzero RHS
if(0===d)return[];// This RHS is invalid but other solutions may still exist
r.splice(d,1),d-=1,m-=1}}else{// non-singular row
h[p]=n(h[p],l[p][p]);for(var v=p+1;v<f;v++)h[v]=a(h[v],i(h[p],l[v][p]))}}return r.map(e=>new s({data:e.map(e=>[e]),size:[c,1]}))}}),l4=ta("lup",["typed","matrix","abs","addScalar","divideScalar","multiplyScalar","subtractScalar","larger","equalScalar","unaryMinus","DenseMatrix","SparseMatrix","Spa"],e=>{var{typed:t,matrix:r,abs:n,addScalar:i,divideScalar:a,multiplyScalar:o,subtractScalar:s,larger:u,equalScalar:l,unaryMinus:c,DenseMatrix:f,SparseMatrix:p,Spa:m}=e;/**
   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a
   * row permutation vector `p` where `A[p,:] = L * U`
   *
   * Syntax:
   *
   *    math.lup(A)
   *
   * Example:
   *
   *    const m = [[2, 1], [1, 4]]
   *    const r = math.lup(m)
   *    // r = {
   *    //   L: [[1, 0], [0.5, 1]],
   *    //   U: [[2, 1], [0, 3.5]],
   *    //   P: [0, 1]
   *    // }
   *
   * See also:
   *
   *    slu, lsolve, lusolve, usolve
   *
   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.
   *
   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.
   */return t("lup",{DenseMatrix:function(e){return d(e)},SparseMatrix:function(e){return function(e){// rows & columns
var t,r,i,s=e._size[0],f=e._size[1],d=Math.min(s,f),h=e._values,g=e._index,y=e._ptr,v=[],x=[],b=[],N=[s,d],w=[],D=[],E=[],A=[d,f],S=[],C=[];for(t=0;t<s;t++)S[t]=t,C[t]=t;// swap indices in permutation vectors (condition x < y)!
var M=function(e,t){// find pv indeces getting data from x and y
var r=C[e],n=C[t];// update permutation vector current -> original
S[r]=t,S[n]=e,// update permutation vector original -> current
C[e]=n,C[t]=r};for(r=0;r<f;r++)!function(){// sparse accumulator
var e=new m;r<s&&(// update ptr
b.push(v.length),// first value in j column for lower triangular matrix
v.push(1),x.push(r)),// update ptr
E.push(w.length);// k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
var f=y[r],d=y[r+1];// copy column j into sparse accumulator
for(i=f;i<d;i++)// row
t=g[i],// copy column values into sparse accumulator (use permutation vector)
e.set(S[t],h[i]);r>0&&e.forEach(0,r-1,function(t,r){// loop rows in column k (L)
p._forEachRow(t,v,x,b,function(n,i){// check row is below k
n>t&&e.accumulate(n,c(o(i,r)))})});// row with larger value in spa, row >= j
var C=r,F=e.get(r),B=n(F);// loop values in spa (order by row, below diagonal)
e.forEach(r+1,s-1,function(e,t){// absolute value
var r=n(t);// value is greater than pivote value
u(r,B)&&(// store row
C=e,// update max value
B=r,// value @ [j, j]
F=t)}),r!==C&&(// swap values j <-> pi in L
p._swapRows(r,C,N[1],v,x,b),// swap values j <-> pi in U
p._swapRows(r,C,A[1],w,D,E),// swap values in spa
e.swap(r,C),// update permutation vector (swap values @ j, pi)
M(r,C)),// loop values in spa (order by row)
e.forEach(0,s-1,function(e,t){// check we are above diagonal
e<=r?(// update upper triangular matrix
w.push(t),D.push(e)):l(// update value
t=a(t,F),0)||(// update lower triangular matrix
v.push(t),x.push(e))})}();// return matrices
return(// update ptrs
E.push(w.length),b.push(v.length),{L:new p({values:v,index:x,ptr:b,size:N}),U:new p({values:w,index:D,ptr:E,size:A}),p:S,toString:function(){return"L: "+this.L.toString()+"\nU: "+this.U.toString()+"\nP: "+this.p}})}(e)},Array:function(e){// lup, use matrix implementation
var t=d(r(e));// result
return{L:t.L.valueOf(),U:t.U.valueOf(),p:t.p}}});function d(e){// rows & columns
var t,r,c,p=e._size[0],m=e._size[1],d=Math.min(p,m),h=J(e._data),g=[],y=[p,d],v=[],x=[d,m],b=[];for(t=0;t<p;t++)b[t]=t;// loop columns
for(r=0;r<m;r++){// skip first column in upper triangular matrix
if(r>0)for(t=0;t<p;t++){// min i,j
var N=Math.min(t,r),w=0;// loop up to min
for(c=0;c<N;c++)w=i(w,o(h[t][c],h[c][r]));h[t][r]=s(h[t][r],w)}// row with larger value in cvector, row >= j
var D=r,E=0,A=0;// loop rows
for(t=r;t<p;t++){// data @ i, j
var S=h[t][r],C=n(S);// value is greater than pivote value
u(C,E)&&(// store row
D=t,// update max value
E=C,// value @ [j, j]
A=S)}// check column is in lower triangular matrix
if(r!==D&&(// swap values j <-> pi in p
b[r]=[b[D],b[D]=b[r]][0],// swap j <-> pi in data
f._swapRows(r,D,h)),r<p)for(t=r+1;t<p;t++)l(h[t][r],0)||(h[t][r]=a(h[t][r],A))}// loop columns
for(r=0;r<m;r++)for(t=0;t<p;t++){// check we are in the upper triangular matrix
if(0===r&&(t<m&&(v[t]=[]),// L
g[t]=[]),t<r){t<m&&(v[t][r]=h[t][r]),r<p&&(g[t][r]=0);continue}// diagonal value
if(t===r){t<m&&(v[t][r]=h[t][r]),r<p&&(g[t][r]=1);continue}t<m&&(v[t][r]=0),r<p&&(g[t][r]=h[t][r])}// l matrix
var M=new f({data:g,size:y}),F=new f({data:v,size:x}),B=[];for(t=0,d=b.length;t<d;t++)B[b[t]]=t;// return matrices
return{L:M,U:F,p:B,toString:function(){return"L: "+this.L.toString()+"\nU: "+this.U.toString()+"\nP: "+this.p}}}});/**
 * Permutes a vector; x = P'b. In MATLAB notation, x(p)=b.
 *
 * @param {Array} p           The permutation vector of length n. null value denotes identity
 * @param {Array} b           The input vector
 *
 * @return {Array}            The output vector x = P'b
 */function l5(e,t){var r,n=t.length,i=[];// check permutation vector was provided, p = null denotes identity
if(e)for(r=0;r<n;r++)i[e[r]]=t[r];else for(r=0;r<n;r++)i[r]=t[r];return i}var l8="lusolve",l6=ta(l8,["typed","matrix","lup","slu","usolve","lsolve","DenseMatrix"],e=>{var{typed:t,matrix:r,lup:n,slu:i,usolve:a,lsolve:o,DenseMatrix:s}=e,u=lK({DenseMatrix:s});/**
   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.
   *
   * Syntax:
   *
   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b
   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)
   *
   * Examples:
   *
   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]
   *
   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]
   *
   *    const f = math.lup(m)
   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]
   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = math.lusolve(a, b)  // [[2], [5]]
   *
   * See also:
   *
   *    lup, slu, lsolve, usolve
   *
   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition
   * @param {Matrix | Array} b               Column Vector
   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix
   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.
   *
   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b
   */return t(l8,{"Array, Array | Matrix":function(e,t){var i=n(e=r(e));return c(i.L,i.U,i.p,null,t).valueOf()},"DenseMatrix, Array | Matrix":function(e,t){var r=n(e);return c(r.L,r.U,r.p,null,t)},"SparseMatrix, Array | Matrix":function(e,t){var r=n(e);return c(r.L,r.U,r.p,null,t)},"SparseMatrix, Array | Matrix, number, number":function(e,t,r,n){var a=i(e,r,n);return c(a.L,a.U,a.p,a.q,t)},"Object, Array | Matrix":function(e,t){return c(e.L,e.U,e.p,e.q,t)}});function l(e){if(g(e))return e;if(h(e))return r(e);throw TypeError("Invalid Matrix LU decomposition")}function c(e,t,r,n,i){// verify decomposition
e=l(e),t=l(t),r&&((i=u(e,i,!0))._data=l5(r,i._data));// use backward substitution to resolve U * x = y
var s=a(t,o(e,i));return n&&(s._data=l5(n,s._data)),s}}),l7="lyap",l9=ta(l7,["typed","matrix","sylvester","multiply","transpose"],e=>{var{typed:t,matrix:r,sylvester:n,multiply:i,transpose:a}=e;/**
   *
   * Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P, where
   * Q is an input matrix. When Q is symmetric, P is also symmetric. Notice
   * that different equivalent definitions exist for the Continuous-time
   * Lyapunov equation.
   * https://en.wikipedia.org/wiki/Lyapunov_equation
   *
   * Syntax:
   *
   *     math.lyap(A, Q)
   *
   * Examples:
   *
   *     const A = [[-2, 0], [1, -4]]
   *     const Q = [[3, 1], [1, 3]]
   *     const P = math.lyap(A, Q)
   *
   * See also:
   *
   *     sylvester, schur
   *
   * @param {Matrix | Array} A  Matrix A
   * @param {Matrix | Array} Q  Matrix Q
   * @return {Matrix | Array} Matrix P solution to the Continuous-time Lyapunov equation AP+PA'=Q
   */return t(l7,{"Matrix, Matrix":function(e,t){return n(e,a(e),i(-1,t))},"Array, Matrix":function(e,t){return n(r(e),a(r(e)),i(-1,t))},"Matrix, Array":function(e,t){return n(e,a(r(e)),r(i(-1,t)))},"Array, Array":function(e,t){return n(r(e),a(r(e)),r(i(-1,t))).toArray()}})}),ce=ta("mad",["typed","abs","map","median","subtract"],e=>{var{typed:t,abs:r,map:n,median:i,subtract:a}=e;/**
   * Compute the median absolute deviation of a matrix or a list with values.
   * The median absolute deviation is defined as the median of the absolute
   * deviations from the median.
   *
   * Syntax:
   *
   *     math.mad(a, b, c, ...)
   *     math.mad(A)
   *
   * Examples:
   *
   *     math.mad(10, 20, 30)             // returns 10
   *     math.mad([1, 2, 3])              // returns 1
   *     math.mad([[1, 2, 3], [4, 5, 6]]) // returns 1.5
   *
   * See also:
   *
   *     median, mean, std, abs
   *
   * @param {Array | Matrix} array
   *                        A single matrix or multiple scalar values.
   * @return {*} The median absolute deviation.
   */return t("mad",{// mad([a, b, c, d, ...])
"Array | Matrix":o,// mad(a, b, c, d, ...)
"...":function(e){return o(e)}});function o(e){if(0===(e=e3(e.valueOf())).length)throw Error("Cannot calculate median absolute deviation (mad) of an empty array");try{var t=i(e);return i(n(e,function(e){return r(a(e,t))}))}catch(e){if(e instanceof TypeError&&-1!==e.message.indexOf("median"))throw TypeError(e.message.replace("median","mad"));throw t4(e,"mad")}}}),ct=ta("map",["typed"],e=>{var{typed:t}=e;/**
   * Create a new matrix or array with the results of a callback function executed on
   * each entry of a given matrix/array.
   *
   * For each entry of the input, the callback is invoked with three arguments:
   * the value of the entry, the index at which that entry occurs, and the full
   * matrix/array being traversed. Note that because the matrix/array might be
   * multidimensional, the "index" argument is always an array of numbers giving
   * the index in each dimension. This is true even for vectors: the "index"
   * argument is an array of length 1, rather than simply a number.
   *
   * Syntax:
   *
   *    math.map(x, callback)
   *
   * Examples:
   *
   *    math.map([1, 2, 3], function(value) {
   *      return value * value
   *    })  // returns [1, 4, 9]
   *
   *    // The callback is normally called with three arguments:
   *    //    callback(value, index, Array)
   *    // If you want to call with only one argument, use:
   *    math.map([1, 2, 3], x => math.format(x)) // returns ['1', '2', '3']
   *
   * See also:
   *
   *    filter, forEach, sort
   *
   * @param {Matrix | Array} x    The input to iterate on.
   * @param {Function} callback
   *     The function to call (as described above) on each entry of the input
   * @return {Matrix | array}
   *     Transformed map of x; always has the same type and shape as x
   */return t("map",{"Array, function":cr,"Matrix, function":function(e,t){return e.map(t)}})});/**
 * Map for a multi dimensional array
 * @param {Array} array
 * @param {Function} callback
 * @return {Array}
 * @private
 */function cr(e,t){return function r(n,i){return Array.isArray(n)?n.map(function(e,t){// we create a copy of the index array and append the new index value
return r(e,i.concat(t))}):rd(t,n,i,e,"map")}(e,[])}var cn="matrix",ci=ta(cn,["typed","Matrix","DenseMatrix","SparseMatrix"],e=>{var{typed:t,Matrix:r,DenseMatrix:n,SparseMatrix:i}=e;/**
   * Create a Matrix. The function creates a new `math.Matrix` object from
   * an `Array`. A Matrix has utility functions to manipulate the data in the
   * matrix, like getting the size and getting or setting values in the matrix.
   * Supported storage formats are 'dense' and 'sparse'.
   *
   * Syntax:
   *
   *    math.matrix()                         // creates an empty matrix using default storage format (dense).
   *    math.matrix(data)                     // creates a matrix with initial data using default storage format (dense).
   *    math.matrix('dense')                  // creates an empty matrix using the given storage format.
   *    math.matrix(data, 'dense')            // creates a matrix with initial data using the given storage format.
   *    math.matrix(data, 'sparse')           // creates a sparse matrix with initial data.
   *    math.matrix(data, 'sparse', 'number') // creates a sparse matrix with initial data, number data type.
   *
   * Examples:
   *
   *    let m = math.matrix([[1, 2], [3, 4]])
   *    m.size()                        // Array [2, 2]
   *    m.resize([3, 2], 5)
   *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]
   *    m.get([1, 0])                    // number 3
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, number, string, unit, sparse
   *
   * @param {Array | Matrix} [data]    A multi dimensional array
   * @param {string} [format]          The Matrix storage format, either `'dense'` or `'sparse'`
   * @param {string} [datatype]        Type of the values
   *
   * @return {Matrix} The created matrix
   */return t(cn,{"":function(){return a([])},string:function(e){return a([],e)},"string, string":function(e,t){return a([],e,t)},Array:function(e){return a(e)},Matrix:function(e){return a(e,e.storage())},"Array | Matrix, string":a,"Array | Matrix, string, string":a});/**
   * Create a new Matrix with given storage format
   * @param {Array} data
   * @param {string} [format]
   * @param {string} [datatype]
   * @returns {Matrix} Returns a new Matrix
   * @private
   */function a(e,t,r){// get storage format constructor
if("dense"===t||"default"===t||void 0===t)return new n(e,r);if("sparse"===t)return new i(e,r);throw TypeError("Unknown matrix type "+JSON.stringify(t)+".")}}),ca=ta("Matrix",[],()=>{/**
   * @constructor Matrix
   *
   * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional
   * array. A matrix can be constructed as:
   *
   *     let matrix = math.matrix(data)
   *
   * Matrix contains the functions to resize, get and set values, get the size,
   * clone the matrix and to convert the matrix to a vector, array, or scalar.
   * Furthermore, one can iterate over the matrix using map and forEach.
   * The internal Array of the Matrix can be accessed using the function valueOf.
   *
   * Example usage:
   *
   *     let matrix = math.matrix([[1, 2], [3, 4]])
   *     matix.size()              // [2, 2]
   *     matrix.resize([3, 2], 5)
   *     matrix.valueOf()          // [[1, 2], [3, 4], [5, 5]]
   *     matrix.subset([1,2])       // 3 (indexes are zero-based)
   *
   */function e(){if(!(this instanceof e))throw SyntaxError("Constructor must be called with the new operator")}return(/**
   * Attach type information
   */e.prototype.type="Matrix",e.prototype.isMatrix=!0,/**
   * Get the storage format used by the matrix.
   *
   * Usage:
   *     const format = matrix.storage()   // retrieve storage format
   *
   * @return {string}           The storage format.
   */e.prototype.storage=function(){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke storage on a Matrix interface")},/**
   * Get the datatype of the data stored in the matrix.
   *
   * Usage:
   *     const format = matrix.datatype()    // retrieve matrix datatype
   *
   * @return {string}           The datatype.
   */e.prototype.datatype=function(){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke datatype on a Matrix interface")},/**
   * Create a new Matrix With the type of the current matrix instance
   * @param {Array | Object} data
   * @param {string} [datatype]
   */e.prototype.create=function(e,t){throw Error("Cannot invoke create on a Matrix interface")},/**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     const subset = matrix.subset(index)               // retrieve subset
   *     const value = matrix.subset(index, replacement)   // replace subset
   *
   * @param {Index} index
   * @param {Array | Matrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */e.prototype.subset=function(e,t,r){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke subset on a Matrix interface")},/**
   * Get a single element from the matrix.
   * @param {number[]} index   Zero-based index
   * @return {*} value
   */e.prototype.get=function(e){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke get on a Matrix interface")},/**
   * Replace a single element in the matrix.
   * @param {number[]} index   Zero-based index
   * @param {*} value
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be left undefined.
   * @return {Matrix} self
   */e.prototype.set=function(e,t,r){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke set on a Matrix interface")},/**
   * Resize the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @param {number[]} size           The new size the matrix should have.
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix}                 The resized matrix
   */e.prototype.resize=function(e,t){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke resize on a Matrix interface")},/**
   * Reshape the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (reshape in place).
   *
   * @param {number[]} size           The new size the matrix should have.
   * @param {boolean} [copy]          Return a reshaped copy of the matrix
   *
   * @return {Matrix}                 The reshaped matrix
   */e.prototype.reshape=function(e,t){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke reshape on a Matrix interface")},/**
   * Create a clone of the matrix
   * @return {Matrix} clone
   */e.prototype.clone=function(){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke clone on a Matrix interface")},/**
   * Retrieve the size of the matrix.
   * @returns {number[]} size
   */e.prototype.size=function(){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke size on a Matrix interface")},/**
   * Create a new matrix with the results of the callback function executed on
   * each entry of the matrix.
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
   *
   * @return {Matrix} matrix
   */e.prototype.map=function(e,t){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke map on a Matrix interface")},/**
   * Execute a callback function on each entry of the matrix.
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   */e.prototype.forEach=function(e){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke forEach on a Matrix interface")},/**
   * Iterate over the matrix elements
   * @return {Iterable<{ value, index: number[] }>}
   */e.prototype[Symbol.iterator]=function(){// must be implemented by each of the Matrix implementations
throw Error("Cannot iterate a Matrix interface")},/**
   * Create an Array with a copy of the data of the Matrix
   * @returns {Array} array
   */e.prototype.toArray=function(){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke toArray on a Matrix interface")},/**
   * Get the primitive value of the Matrix: a multidimensional array
   * @returns {Array} array
   */e.prototype.valueOf=function(){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke valueOf on a Matrix interface")},/**
   * Get a string representation of the matrix, with optional formatting options.
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */e.prototype.format=function(e){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke format on a Matrix interface")},/**
   * Get a string representation of the matrix
   * @returns {string} str
   */e.prototype.toString=function(){// must be implemented by each of the Matrix implementations
throw Error("Cannot invoke toString on a Matrix interface")},e)},{isClass:!0}),co="matrixFromColumns",cs=ta(co,["typed","matrix","flatten","size"],e=>{var{typed:t,matrix:r,flatten:n,size:i}=e;/**
   * Create a dense matrix from vectors as individual columns.
   * If you pass row vectors, they will be transposed (but not conjugated!)
   *
   * Syntax:
   *
   *    math.matrixFromColumns(...arr)
   *    math.matrixFromColumns(col1, col2)
   *    math.matrixFromColumns(col1, col2, col3)
   *
   * Examples:
   *
   *    math.matrixFromColumns([1, 2, 3], [[4],[5],[6]])
   *    math.matrixFromColumns(...vectors)
   *
   * See also:
   *
   *    matrix, matrixFromRows, matrixFromFunction, zeros
   *
   * @param {... Array | Matrix} cols Multiple columns
   * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned
   */return t(co,{"...Array":function(e){return a(e)},"...Matrix":function(e){return r(a(e.map(e=>e.toArray())))}});function a(e){if(0===e.length)throw TypeError("At least one column is needed to construct a matrix.");for(var t=o(e[0]),r=[],i=0;i<t;i++)r[i]=[];// loop columns
for(var a of e){var s=o(a);if(s!==t)throw TypeError("The vectors had different length: "+(0|t)+" ≠ "+(0|s));// push a value to each row
for(var u=n(a),l=0;l<t;l++)r[l].push(u[l])}return r}function o(e){var t=i(e);if(1===t.length)return t[0];if(2===t.length){// 2D vector
if(1===t[0])return t[1];if(1===t[1])return t[0];throw TypeError("At least one of the arguments is not a vector.")}throw TypeError("Only one- or two-dimensional vectors are supported.")}}),cu="matrixFromFunction",cl=ta(cu,["typed","matrix","isZero"],e=>{var{typed:t,matrix:r,isZero:n}=e;/**
   * Create a matrix by evaluating a generating function at each index.
   * The simplest overload returns a multi-dimensional array as long as `size` is an array.
   * Passing `size` as a Matrix or specifying a `format` will result in returning a Matrix.
   *
   * Syntax:
   *
   *    math.matrixFromFunction(size, fn)
   *    math.matrixFromFunction(size, fn, format)
   *    math.matrixFromFunction(size, fn, format, datatype)
   *    math.matrixFromFunction(size, format, fn)
   *    math.matrixFromFunction(size, format, datatype, fn)
   *
   * Examples:
   *
   *    math.matrixFromFunction([3,3], i => i[0] - i[1]) // an antisymmetric matrix
   *    math.matrixFromFunction([100, 100], 'sparse', i => i[0] - i[1] === 1 ? 4 : 0) // a sparse subdiagonal matrix
   *    math.matrixFromFunction([5], i => math.random()) // a random vector
   *
   * See also:
   *
   *    matrix, zeros
   *
   * @param {Array | Matrix} size   The size of the matrix to be created
   * @param {function} fn           Callback function invoked for every entry in the matrix
   * @param {string} [format]       The Matrix storage format, either `'dense'` or `'sparse'`
   * @param {string} [datatype]     Type of the values
   * @return {Array | Matrix} Returns the created matrix
   */return t(cu,{"Array | Matrix, function, string, string":function(e,t,r,n){return i(e,t,r,n)},"Array | Matrix, function, string":function(e,t,r){return i(e,t,r)},"Matrix, function":function(e,t){return i(e,t,"dense")},"Array, function":function(e,t){return i(e,t,"dense").toArray()},"Array | Matrix, string, function":function(e,t,r){return i(e,r,t)},"Array | Matrix, string, string, function":function(e,t,r,n){return i(e,n,t,r)}});function i(e,t,i,a){var o;return(o=void 0!==a?r(i,a):r(i)).resize(e),o.forEach(function(e,r){var i=t(r);n(i)||o.set(r,i)}),o}}),cc="matrixFromRows",cf=ta(cc,["typed","matrix","flatten","size"],e=>{var{typed:t,matrix:r,flatten:n,size:i}=e;/**
   * Create a dense matrix from vectors as individual rows.
   * If you pass column vectors, they will be transposed (but not conjugated!)
   *
   * Syntax:
   *
   *    math.matrixFromRows(...arr)
   *    math.matrixFromRows(row1, row2)
   *    math.matrixFromRows(row1, row2, row3)
   *
   * Examples:
   *
   *    math.matrixFromRows([1, 2, 3], [[4],[5],[6]])
   *    math.matrixFromRows(...vectors)
   *
   * See also:
   *
   *    matrix, matrixFromColumns, matrixFromFunction, zeros
   *
   * @param {... Array | Matrix} rows  Multiple rows
   * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned
   */return t(cc,{"...Array":function(e){return a(e)},"...Matrix":function(e){return r(a(e.map(e=>e.toArray())))}});function a(e){if(0===e.length)throw TypeError("At least one row is needed to construct a matrix.");var t=o(e[0]),r=[];for(var i of e){var a=o(i);if(a!==t)throw TypeError("The vectors had different length: "+(0|t)+" ≠ "+(0|a));r.push(n(i))}return r}function o(e){var t=i(e);if(1===t.length)return t[0];if(2===t.length){// 2D vector
if(1===t[0])return t[1];if(1===t[1])return t[0];throw TypeError("At least one of the arguments is not a vector.")}throw TypeError("Only one- or two-dimensional vectors are supported.")}}),cp="median",cm=ta(cp,["typed","add","divide","compare","partitionSelect"],e=>{var{typed:t,add:r,divide:n,compare:i,partitionSelect:a}=e;/**
   * Recursively calculate the median of an n-dimensional array
   * @param {Array} array
   * @return {Number} median
   * @private
   */function o(e){try{var t=(e=e3(e.valueOf())).length;if(0===t)throw Error("Cannot calculate median of an empty array");if(t%2==0){for(var r=t/2-1,n=a(e,r+1),o=e[r],l=0;l<r;++l)i(e[l],o)>0&&(o=e[l]);return u(o,n)}// odd: return the middle value
var c=a(e,(t-1)/2);return s(c)}catch(e){throw t4(e,"median")}}// helper function to type check the middle value of the array
var s=t({"number | BigNumber | Complex | Unit":function(e){return e}}),u=t({"number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit":function(e,t){return n(r(e,t),2)}});/**
   * Compute the median of a matrix or a list with values. The values are
   * sorted and the middle value is returned. In case of an even number of
   * values, the average of the two middle values is returned.
   * Supported types of values are: Number, BigNumber, Unit
   *
   * In case of a (multi dimensional) array or matrix, the median of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.median(a, b, c, ...)
   *     math.median(A)
   *
   * Examples:
   *
   *     math.median(5, 2, 7)        // returns 5
   *     math.median([3, -1, 5, 7])  // returns 4
   *
   * See also:
   *
   *     mean, min, max, sum, prod, std, variance, quantileSeq
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The median
   */return t(cp,{// median([a, b, c, d, ...])
"Array | Matrix":o,// median([a, b, c, d, ...], dim)
"Array | Matrix, number | BigNumber":function(e,t){// TODO: implement median(A, dim)
throw Error("median(A, dim) is not yet supported");// return reduce(arguments[0], arguments[1], ...)
},// median(a, b, c, d, ...)
"...":function(e){if(t_(e))throw TypeError("Scalar values expected in function median");return o(e)}})}),cd="mode",ch=ta(cd,["typed","isNaN","isNumeric"],e=>{var{typed:t,isNaN:r,isNumeric:n}=e;/**
  * Computes the mode of a set of numbers or a list with values(numbers or characters).
  * If there are multiple modes, it returns a list of those values.
  *
  * Syntax:
  *
  *     math.mode(a, b, c, ...)
  *     math.mode(A)
  *
  * Examples:
  *
  *     math.mode(2, 1, 4, 3, 1)                            // returns [1]
  *     math.mode([1, 2.7, 3.2, 4, 2.7])                    // returns [2.7]
  *     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]
  *     math.mode('a','a','b','c')                           // returns ["a"]
  *     math.mode(1, 1.5, 'abc')                             // returns [1, 1.5, "abc"]
  *
  * See also:
  *
  *     median,
  *     mean
  *
  * @param {... *} args  A single matrix
  * @return {*} The mode of all values
  */return t(cd,{"Array | Matrix":i,"...":function(e){return i(e)}});/**
   * Calculates the mode in an 1-dimensional array
   * @param {Array} values
   * @return {Array} mode
   * @private
   */function i(e){if(0===(e=e3(e.valueOf())).length)throw Error("Cannot calculate mode of an empty array");for(var t={},i=[],a=0,o=0;o<e.length;o++){var s=e[o];if(n(s)&&r(s))throw Error("Cannot calculate mode of an array containing NaN values");s in t||(t[s]=0),t[s]++,t[s]===a?i.push(s):t[s]>a&&(a=t[s],i=[s])}return i}}),cg="multinomial",cy=ta(cg,["typed","add","divide","multiply","factorial","isInteger","isPositive"],e=>{var{typed:t,add:r,divide:n,multiply:i,factorial:a,isInteger:o,isPositive:s}=e;/**
   * Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities.
   *
   * multinomial takes one array of integers as an argument.
   * The following condition must be enforced: every ai <= 0
   *
   * Syntax:
   *
   *     math.multinomial(a) // a is an array type
   *
   * Examples:
   *
   *    math.multinomial([1,2,1]) // returns 12
   *
   * See also:
   *
   *    combinations, factorial
   *
   * @param {number[] | BigNumber[]} a    Integer numbers of objects in the subset
   * @return {Number | BigNumber}         Multinomial coefficient.
   */return t(cg,{"Array | Matrix":function(e){var t=0,u=1;return tz(e,function(e){if(!o(e)||!s(e))throw TypeError("Positive integer value expected in function multinomial");t=r(t,e),u=i(u,a(e))}),n(a(t),u)}})}),cv="multiply",cx=ta(cv,["typed","matrix","addScalar","multiplyScalar","equalScalar","dot"],e=>{var{typed:t,matrix:r,addScalar:n,multiplyScalar:i,equalScalar:a,dot:o}=e,s=iL({typed:t,equalScalar:a}),u=iq({typed:t});function l(e,t){// check left operand dimensions
switch(e.length){case 1:// check size2
switch(t.length){case 1:// Vector x Vector
if(e[0]!==t[0])throw RangeError("Dimension mismatch in multiplication. Vectors must have the same length");break;case 2:// Vector x Matrix
if(e[0]!==t[0])throw RangeError("Dimension mismatch in multiplication. Vector length ("+e[0]+") must match Matrix rows ("+t[0]+")");break;default:throw Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+t.length+" dimensions)")}break;case 2:// check size2
switch(t.length){case 1:// Matrix x Vector
if(e[1]!==t[0])throw RangeError("Dimension mismatch in multiplication. Matrix columns ("+e[1]+") must match Vector length ("+t[0]+")");break;case 2:// Matrix x Matrix
if(e[1]!==t[0])throw RangeError("Dimension mismatch in multiplication. Matrix A columns ("+e[1]+") must match Matrix B rows ("+t[0]+")");break;default:throw Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+t.length+" dimensions)")}break;default:throw Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has "+e.length+" dimensions)")}}/**
   * C = A * B
   *
   * @param {Matrix} a            Matrix         (MxN)
   * @param {Matrix} b            Dense Vector   (N)
   *
   * @return {Matrix}             Dense Vector   (M)
   */var c=t("_multiplyMatrixVector",{"DenseMatrix, any":/**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix  (MxN)
   * @param {Matrix} b            Dense Vector (N)
   *
   * @return {Matrix}             Dense Vector (M)
   */function(e,r){// a dense
var a,o=e._data,s=e._size,u=e._datatype,l=r._data,c=r._datatype,f=s[0],p=s[1],m=n,d=i;// process data types
u&&c&&u===c&&"string"==typeof u&&(// datatype
a=u,// find signatures that matches (dt, dt)
m=t.find(n,[a,a]),d=t.find(i,[a,a]));// loop matrix a rows
for(var h=[],g=0;g<f;g++){// loop matrix a columns
for(var y=o[g],v=d(y[0],l[0]),x=1;x<p;x++)v=m(v,d(y[x],l[x]));h[g]=v}// return matrix
return e.createDenseMatrix({data:h,size:[f],datatype:a})},"SparseMatrix, any":/**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix    (MxN)
   * @param {Matrix} b            Dense Vector (N)
   *
   * @return {Matrix}             SparseMatrix    (M, 1)
   */function(e,r){// a sparse
var o,s=e._values,u=e._index,l=e._ptr,c=e._datatype;// validate a matrix
if(!s)throw Error("Cannot multiply Pattern only Matrix times Dense Matrix");// b dense
var f=r._data,p=r._datatype,m=e._size[0],d=r._size[0],h=[],g=[],y=[],v=n,x=i,b=a,N=0;c&&p&&c===p&&"string"==typeof c&&(// datatype
o=c,// find signatures that matches (dt, dt)
v=t.find(n,[o,o]),x=t.find(i,[o,o]),b=t.find(a,[o,o]),// convert 0 to the same datatype
N=t.convert(0,o));// workspace
var w=[],D=[];// update ptr
y[0]=0;// rows in b
for(var E=0;E<d;E++){// b[ib]
var A=f[E];// check b[ib] != 0, avoid loops
if(!b(A,N))for(var S=l[E],C=l[E+1],M=S;M<C;M++){// a row
var F=u[M];// check value exists in current j
D[F]?w[F]=v(w[F],x(A,s[M])):(// ia is new entry in j
D[F]=!0,// add i to pattern of C
g.push(F),// x(ia) = A
w[F]=x(A,s[M]))}}// copy values from x to column jb of c
for(var B=g.length,T=0;T<B;T++){// row
var O=g[T];// copy value
h[T]=w[O]}// return sparse matrix
return(// update ptr
y[1]=g.length,e.createSparseMatrix({values:h,index:g,ptr:y,size:[m,1],datatype:o}))}}),f=t("_multiplyMatrixMatrix",{"DenseMatrix, DenseMatrix":/**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix    (MxN)
   * @param {Matrix} b            DenseMatrix    (NxC)
   *
   * @return {Matrix}             DenseMatrix    (MxC)
   */function(e,r){// a dense
var a,o=e._data,s=e._size,u=e._datatype,l=r._data,c=r._size,f=r._datatype,p=s[0],m=s[1],d=c[1],h=n,g=i;// process data types
u&&f&&u===f&&"string"==typeof u&&(// datatype
a=u,// find signatures that matches (dt, dt)
h=t.find(n,[a,a]),g=t.find(i,[a,a]));// loop matrix a rows
for(var y=[],v=0;v<p;v++){// current row
var x=o[v];// initialize row array
y[v]=[];// loop matrix b columns
for(var b=0;b<d;b++){// loop matrix a columns
for(var N=g(x[0],l[0][b]),w=1;w<m;w++)N=h(N,g(x[w],l[w][b]));y[v][b]=N}}// return matrix
return e.createDenseMatrix({data:y,size:[p,d],datatype:a})},"DenseMatrix, SparseMatrix":/**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix    (MxN)
   * @param {Matrix} b            SparseMatrix   (NxC)
   *
   * @return {Matrix}             SparseMatrix   (MxC)
   */function(e,r){// a dense
var o,s=e._data,u=e._size,l=e._datatype,c=r._values,f=r._index,p=r._ptr,m=r._size,d=r._datatype;// validate b matrix
if(!c)throw Error("Cannot multiply Dense Matrix times Pattern only Matrix");// rows & columns
var h=u[0],g=m[1],y=n,v=i,x=a,b=0;l&&d&&l===d&&"string"==typeof l&&(// datatype
o=l,// find signatures that matches (dt, dt)
y=t.find(n,[o,o]),v=t.find(i,[o,o]),x=t.find(a,[o,o]),// convert 0 to the same datatype
b=t.convert(0,o));// loop b columns
for(var N=[],w=[],D=[],E=r.createSparseMatrix({values:N,index:w,ptr:D,size:[h,g],datatype:o}),A=0;A<g;A++){// update ptr
D[A]=w.length;// indeces in column jb
var S=p[A],C=p[A+1];// do not process column jb if no data exists
if(C>S)// loop a rows
for(var M=0,F=0;F<h;F++){// values in b column j
for(var B=F+1,T=void 0,O=S;O<C;O++){// row
var _=f[O];// check value has been initialized
M!==B?(// first value in column jb
T=v(s[F][_],c[O]),// update mark
M=B):T=y(T,v(s[F][_],c[O]))}// check column has been processed and value != 0
M!==B||x(T,b)||(// push row & value
w.push(F),N.push(T))}}// return sparse matrix
return(// update ptr
D[g]=w.length,E)},"SparseMatrix, DenseMatrix":/**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix      (MxN)
   * @param {Matrix} b            DenseMatrix       (NxC)
   *
   * @return {Matrix}             SparseMatrix      (MxC)
   */function(e,r){// a sparse
var o,s=e._values,u=e._index,l=e._ptr,c=e._datatype;// validate a matrix
if(!s)throw Error("Cannot multiply Pattern only Matrix times Dense Matrix");// b dense
var f=r._data,p=r._datatype,m=e._size[0],d=r._size[0],h=r._size[1],g=n,y=i,v=a,x=0;c&&p&&c===p&&"string"==typeof c&&(// datatype
o=c,// find signatures that matches (dt, dt)
g=t.find(n,[o,o]),y=t.find(i,[o,o]),v=t.find(a,[o,o]),// convert 0 to the same datatype
x=t.convert(0,o));// loop b columns
for(var b=[],N=[],w=[],D=e.createSparseMatrix({values:b,index:N,ptr:w,size:[m,h],datatype:o}),E=[],A=[],S=0;S<h;S++){// update ptr
w[S]=N.length;// rows in jb
for(var C=S+1,M=0;M<d;M++){// b[ib, jb]
var F=f[M][S];// check b[ib, jb] != 0, avoid loops
if(!v(F,x))for(var B=l[M],T=l[M+1],O=B;O<T;O++){// a row
var _=u[O];// check value exists in current j
A[_]!==C?(// ia is new entry in j
A[_]=C,// add i to pattern of C
N.push(_),// x(ia) = A
E[_]=y(F,s[O])):E[_]=g(E[_],y(F,s[O]))}}// copy values from x to column jb of c
for(var z=w[S],q=N.length,k=z;k<q;k++){// row
var I=N[k];// copy value
b[k]=E[I]}}// return sparse matrix
return(// update ptr
w[h]=N.length,D)},"SparseMatrix, SparseMatrix":/**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix      (MxN)
   * @param {Matrix} b            SparseMatrix      (NxC)
   *
   * @return {Matrix}             SparseMatrix      (MxC)
   */function(e,r){// a sparse
var a,o,s,u,l,c,f,p,m,d=e._values,h=e._index,g=e._ptr,y=e._datatype,v=r._values,x=r._index,b=r._ptr,N=r._datatype,w=e._size[0],D=r._size[1],E=d&&v,A=n,S=i;y&&N&&y===N&&"string"==typeof y&&(// datatype
a=y,// find signatures that matches (dt, dt)
A=t.find(n,[a,a]),S=t.find(i,[a,a]));// loop b columns
for(var C=E?[]:void 0,M=[],F=[],B=e.createSparseMatrix({values:C,index:M,ptr:F,size:[w,D],datatype:a}),T=E?[]:void 0,O=[],_=0;_<D;_++){// update ptr
F[_]=M.length;// mark in workspace for current column
var z=_+1;// B values & index in j
for(c=b[_],f=b[_+1],l=c;l<f;l++)// check we need to process values
if(// b row
m=x[l],E)for(s=g[m],u=g[m+1],o=s;o<u;o++)// check value exists in current j
O[// row
p=h[o]]!==z?(// ia is new entry in j
O[p]=z,// add i to pattern of C
M.push(p),// x(ia) = A
T[p]=S(v[l],d[o])):T[p]=A(T[p],S(v[l],d[o]));else for(s=g[m],u=g[m+1],o=s;o<u;o++)// check value exists in current j
O[// row
p=h[o]]!==z&&(// ia is new entry in j
O[p]=z,// add i to pattern of C
M.push(p));// check we need to process matrix values (pattern matrix)
if(E)for(var q=F[_],k=M.length,I=q;I<k;I++){// row
var R=M[I];// copy value
C[I]=T[R]}}// return sparse matrix
return(// update ptr
F[D]=M.length,B)}});/**
   * Multiply two or more values, `x * y`.
   * For matrices, the matrix product is calculated.
   *
   * Syntax:
   *
   *    math.multiply(x, y)
   *    math.multiply(x, y, z, ...)
   *
   * Examples:
   *
   *    math.multiply(4, 5.2)        // returns number 20.8
   *    math.multiply(2, 3, 4)       // returns number 24
   *
   *    const a = math.complex(2, 3)
   *    const b = math.complex(4, 1)
   *    math.multiply(a, b)          // returns Complex 5 + 14i
   *
   *    const c = [[1, 2], [4, 3]]
   *    const d = [[1, 2, 3], [3, -4, 7]]
   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]
   *
   *    const e = math.unit('2.1 km')
   *    math.multiply(3, e)          // returns Unit 6.3 km
   *
   * See also:
   *
   *    divide, prod, cross, dot
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`
   */return t(cv,i,{// we extend the signatures of multiplyScalar with signatures dealing with matrices
"Array, Array":t.referTo("Matrix, Matrix",e=>(t,n)=>{// check dimensions
    l(eG(t),eG(n));// use dense matrix implementation
    var i=e(r(t),r(n));// return array or scalar
    return g(i)?i.valueOf():i}),"Matrix, Matrix":function(e,r){// dimensions
var a=e.size(),s=r.size();return(// process dimensions
(// check dimensions
l(a,s),1===a.length)?// process y dimensions
1===s.length?/**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (N)
   * @param {Matrix} b            Dense Vector   (N)
   *
   * @return {number}             Scalar value
   */function(e,t,r){// check empty vector
if(0===r)throw Error("Cannot multiply two empty vectors");return o(e,t)}(e,r,a[0]):/**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (M)
   * @param {Matrix} b            Matrix         (MxN)
   *
   * @return {Matrix}             Dense Vector   (N)
   */function(e,r){// process storage
if("dense"!==r.storage())throw Error("Support for SparseMatrix not implemented");return(/**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (M)
   * @param {Matrix} b            Dense Matrix   (MxN)
   *
   * @return {Matrix}             Dense Vector   (N)
   */function(e,r){// a dense
var a,o=e._data,s=e._size,u=e._datatype,l=r._data,c=r._size,f=r._datatype,p=s[0],m=c[1],d=n,h=i;// process data types
u&&f&&u===f&&"string"==typeof u&&(// datatype
a=u,// find signatures that matches (dt, dt)
d=t.find(n,[a,a]),h=t.find(i,[a,a]));// loop matrix columns
for(var g=[],y=0;y<m;y++){// loop vector
for(var v=h(o[0],l[0][y]),x=1;x<p;x++)v=d(v,h(o[x],l[x][y]));g[y]=v}// return matrix
return e.createDenseMatrix({data:g,size:[m],datatype:a})}(e,r))}(e,r):// process y dimensions
1===s.length?c(e,r):f(e,r))},"Matrix, Array":t.referTo("Matrix,Matrix",e=>(t,n)=>e(t,r(n))),"Array, Matrix":t.referToSelf(e=>(t,n)=>e(r(t,n.storage()),n)),"SparseMatrix, any":function(e,t){return s(e,t,i,!1)},"DenseMatrix, any":function(e,t){return u(e,t,i,!1)},"any, SparseMatrix":function(e,t){return s(t,e,i,!0)},"any, DenseMatrix":function(e,t){return u(t,e,i,!0)},"Array, any":function(e,t){// use matrix implementation
return u(r(e),t,i,!1).valueOf()},"any, Array":function(e,t){// use matrix implementation
return u(r(t),e,i,!0).valueOf()},"any, any":i,"any, any, ...any":t.referToSelf(e=>(t,r,n)=>{for(var i=e(t,r),a=0;a<n.length;a++)i=e(i,n[a]);return i})})}),cb=ta("multiplyScalar",["typed"],e=>{var{typed:t}=e;/**
   * Multiply two scalar values, `x * y`.
   * This function is meant for internal use: it is used by the public function
   * `multiply`
   *
   * This function does not support collections (Array or Matrix).
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to multiply
   * @param  {number | BigNumber | Fraction | Complex} y          Second value to multiply
   * @return {number | BigNumber | Fraction | Complex | Unit}     Multiplication of `x` and `y`
   * @private
   */return t("multiplyScalar",{"number, number":nX,"Complex, Complex":function(e,t){return e.mul(t)},"BigNumber, BigNumber":function(e,t){return e.times(t)},"Fraction, Fraction":function(e,t){return e.mul(t)},"number | Fraction | BigNumber | Complex, Unit":(e,t)=>t.multiply(e),"Unit, number | Fraction | BigNumber | Complex | Unit":(e,t)=>e.multiply(t)})}),cN="norm",cw=ta(cN,["typed","abs","add","pow","conj","sqrt","multiply","equalScalar","larger","smaller","matrix","ctranspose","eigs"],e=>{var{typed:t,abs:r,add:n,pow:i,conj:a,sqrt:o,multiply:s,equalScalar:u,larger:l,smaller:c,matrix:f,ctranspose:p,eigs:m}=e;/**
   * Calculate the norm of a number, vector or matrix.
   *
   * The second parameter p is optional. If not provided, it defaults to 2.
   *
   * Syntax:
   *
   *    math.norm(x)
   *    math.norm(x, p)
   *
   * Examples:
   *
   *    math.abs(-3.5)                         // returns 3.5
   *    math.norm(-3.5)                        // returns 3.5
   *
   *    math.norm(math.complex(3, -4))         // returns 5
   *
   *    math.norm([1, 2, -3], Infinity)        // returns 3
   *    math.norm([1, 2, -3], -Infinity)       // returns 1
   *
   *    math.norm([3, 4], 2)                   // returns 5
   *
   *    math.norm([[1, 2], [3, 4]], 1)          // returns 6
   *    math.norm([[1, 2], [3, 4]], 'inf')     // returns 7
   *    math.norm([[1, 2], [3, 4]], 'fro')     // returns 5.477225575051661
   *
   * See also:
   *
   *    abs, hypot
   *
   * @param  {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the norm
   * @param  {number | BigNumber | string} [p=2]
   *            Vector space.
   *            Supported numbers include Infinity and -Infinity.
   *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)
   * @return {number | BigNumber} the p-norm
   */return t(cN,{number:Math.abs,Complex:function(e){return e.abs()},BigNumber:function(e){// norm(x) = abs(x)
return e.abs()},boolean:function(e){// norm(x) = abs(x)
return Math.abs(e)},Array:function(e){return d(f(e),2)},Matrix:function(e){return d(e,2)},"Array, number | BigNumber | string":function(e,t){return d(f(e),t)},"Matrix, number | BigNumber | string":function(e,t){return d(e,t)}});/**
   * Calculate the norm for an array
   * @param {Matrix} x
   * @param {number | string} p
   * @returns {number} Returns the norm
   * @private
   */function d(e,t){// size
var f=e.size();// check if it is a vector
if(1===f.length)return(/**
   * Calculate the norm for a vector
   * @param {Matrix} x
   * @param {number | string} p
   * @returns {number} Returns the norm
   * @private
   */function(e,t){// check p
if(t===Number.POSITIVE_INFINITY||"inf"===t)return a=0,// skip zeros since abs(0) === 0
e.forEach(function(e){var t=r(e);l(t,a)&&(a=t)},!0),a;if(t===Number.NEGATIVE_INFINITY||"-inf"===t)return(// skip zeros since abs(0) === 0
e.forEach(function(e){var t=r(e);(!o||c(t,o))&&(o=t)},!0),o||0);if("fro"===t)return d(e,2);if("number"==typeof t&&!isNaN(t)){// check p != 0
if(!u(t,0)){// norm(x, p) = sum(abs(xi) ^ p) ^ 1/p
var a,o,s=0;return(// skip zeros since abs(0) === 0
e.forEach(function(e){s=n(i(r(e),t),s)},!0),i(s,1/t))}return Number.POSITIVE_INFINITY}// invalid parameter value
throw Error("Unsupported parameter value")}(e,t));// MxN matrix
if(2===f.length){if(f[0]&&f[1])return(/**
   * Calculate the norm for a 2D Matrix (M*N)
   * @param {Matrix} x
   * @param {number | string} p
   * @returns {number} Returns the norm
   * @private
   */function(e,t){var i,u,c,f,d;// check p
if(1===t)return i=[],u=0,// skip zeros since abs(0) == 0
e.forEach(function(e,t){var a=t[1],o=n(i[a]||0,r(e));l(o,u)&&(u=o),i[a]=o},!0),u;if(t===Number.POSITIVE_INFINITY||"inf"===t)return c=[],f=0,// skip zeros since abs(0) == 0
e.forEach(function(e,t){var i=t[0],a=n(c[i]||0,r(e));l(a,f)&&(f=a),c[i]=a},!0),f;if("fro"===t)return d=0,e.forEach(function(e,t){d=n(d,s(e,a(e)))}),r(o(d));if(2===t)return(/**
   * Calculate the norm L2 for a matrix
   * @param {Matrix} x
   * @returns {number} Returns the norm
   * @private
   */function(e){// norm(x) = sqrt( max eigenvalue of A*.A)
var t=e.size();if(t[0]!==t[1])throw RangeError("Invalid matrix dimensions");var n=m(s(p(e),e)).values.toArray();return r(o(n[n.length-1]))}(e));// invalid parameter value
throw Error("Unsupported parameter value "+t)}(e,t));throw RangeError("Invalid matrix dimensions")}}}),cD=ta("not",["typed"],e=>{var{typed:t}=e;/**
   * Logical `not`. Flips boolean value of a given parameter.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.not(x)
   *
   * Examples:
   *
   *    math.not(2)      // returns false
   *    math.not(0)      // returns true
   *    math.not(true)   // returns false
   *
   *    a = [2, -7, 0]
   *    math.not(a)      // returns [false, false, true]
   *
   * See also:
   *
   *    and, or, xor
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when input is a zero or empty value.
   */return t("not",{"null | undefined":()=>!0,number:iZ,Complex:function(e){return 0===e.re&&0===e.im},BigNumber:function(e){return e.isZero()||e.isNaN()},Unit:t.referToSelf(e=>r=>t.find(e,r.valueType())(r.value)),"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),cE="nthRoot",cA=ta(cE,["typed","matrix","equalScalar","BigNumber","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,BigNumber:i,concat:a}=e,o=iT({typed:t}),s=iU({typed:t,equalScalar:n}),u=i$({typed:t,equalScalar:n}),l=iL({typed:t,equalScalar:n}),c=iI({typed:t,matrix:r,concat:a});/**
   * Calculate the nth root of a value.
   * The principal nth root of a positive real number A, is the positive real
   * solution of the equation
   *
   *     x^root = A
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *     math.nthRoot(a)
   *     math.nthRoot(a, root)
   *
   * Examples:
   *
   *     math.nthRoot(9, 2)    // returns 3 (since 3^2 == 9)
   *     math.sqrt(9)          // returns 3 (since 3^2 == 9)
   *     math.nthRoot(64, 3)   // returns 4 (since 4^3 == 64)
   *
   * See also:
   *
   *     sqrt, pow
   *
   * @param {number | BigNumber | Array | Matrix | Complex} a
   *              Value for which to calculate the nth root
   * @param {number | BigNumber} [root=2]    The root.
   * @return {number | Complex | Array | Matrix} Returns the nth root of `a`
   */function f(){throw Error("Complex number not supported in function nthRoot. Use nthRoots instead.")}return t(cE,{number:n5,"number, number":n5,BigNumber:e=>p(e,new i(2)),"BigNumber, BigNumber":p,Complex:f,"Complex, number":f,Array:t.referTo("DenseMatrix,number",e=>t=>e(r(t),2).valueOf()),DenseMatrix:t.referTo("DenseMatrix,number",e=>t=>e(t,2)),SparseMatrix:t.referTo("SparseMatrix,number",e=>t=>e(t,2)),"SparseMatrix, SparseMatrix":t.referToSelf(e=>(t,r)=>{// density must be one (no zeros in matrix)
    if(1===r.density())return u(t,r,e);throw Error("Root must be non-zero")}),"DenseMatrix, SparseMatrix":t.referToSelf(e=>(t,r)=>{// density must be one (no zeros in matrix)
    if(1===r.density())return o(t,r,e,!1);throw Error("Root must be non-zero")}),"Array, SparseMatrix":t.referTo("DenseMatrix,SparseMatrix",e=>(t,n)=>e(r(t),n)),"number | BigNumber, SparseMatrix":t.referToSelf(e=>(t,r)=>{// density must be one (no zeros in matrix)
    if(1===r.density())return l(r,t,e,!0);throw Error("Root must be non-zero")})},c({scalar:"number | BigNumber",SD:s,Ss:l,sS:!1}));/**
   * Calculate the nth root of a for BigNumbers, solve x^root == a
   * https://rosettacode.org/wiki/Nth_root#JavaScript
   * @param {BigNumber} a
   * @param {BigNumber} root
   * @private
   */function p(e,t){var r=i.precision,n=i.clone({precision:r+2}),a=new i(0),o=new n(1),s=t.isNegative();if(s&&(t=t.neg()),t.isZero())throw Error("Root must be non-zero");if(e.isNegative()&&!t.abs().mod(2).equals(1))throw Error("Root must be odd when a is negative.");// edge cases zero and infinity
if(e.isZero())return s?new n(1/0):0;if(!e.isFinite())return s?a:e;var u=e.abs().pow(o.div(t));return(// If a < 0, we require that root is an odd integer,
// so (-1) ^ (1/root) = -1
u=e.isNeg()?u.neg():u,new i((s?o.div(u):u).toPrecision(r)))}}),cS="nthRoots",cC=ta(cS,["config","typed","divideScalar","Complex"],e=>{var{typed:t,config:r,divideScalar:n,Complex:i}=e,a=[function(e){return new i(e,0)},function(e){return new i(0,e)},function(e){return new i(-e,0)},function(e){return new i(0,-e)}];/**
   * Calculate the nth root of a Complex Number a using De Movire's Theorem.
   * @param  {Complex} a
   * @param  {number} root
   * @return {Array} array of n Complex Roots
   */function o(e,t){if(t<0)throw Error("Root must be greater than zero");if(0===t)throw Error("Root must be non-zero");if(t%1!=0)throw Error("Root must be an integer");if(0===e||0===e.abs())return[new i(0,0)];var r,n="number"==typeof e;// determine the offset (argument of a)/(pi/2)
(n||0===e.re||0===e.im)&&(r=n?2*+(e<0):0===e.im?2*+(e.re<0):2*+(e.im<0)+1);for(var o=e.arg(),s=e.abs(),u=[],l=Math.pow(s,1/t),c=0;c<t;c++){var f=(r+4*c)/t;/**
       * If (offset + 4*k)/root is an integral multiple of pi/2
       * then we can produce a more exact result.
       */if(f===Math.round(f)){u.push(a[f%4](l));continue}u.push(new i({r:l,phi:(o+2*Math.PI*c)/t}))}return u}/**
   * Calculate the nth roots of a value.
   * An nth root of a positive real number A,
   * is a positive real solution of the equation "x^root = A".
   * This function returns an array of complex values.
   *
   * Syntax:
   *
   *    math.nthRoots(x)
   *    math.nthRoots(x, root)
   *
   * Examples:
   *
   *    math.nthRoots(1)
   *    // returns [
   *    //   {re: 1, im: 0},
   *    //   {re: -1, im: 0}
   *    // ]
   *    math.nthRoots(1, 3)
   *    // returns [
   *    //   { re: 1, im: 0 },
   *    //   { re: -0.4999999999999998, im: 0.8660254037844387 },
   *    //   { re: -0.5000000000000004, im: -0.8660254037844385 }
   *    // ]
   *
   * See also:
   *
   *    nthRoot, pow, sqrt
   *
   * @param {number | BigNumber | Fraction | Complex} x Number to be rounded
   * @param {number} [root=2] Optional root, default value is 2
   * @return {number | BigNumber | Fraction | Complex} Returns the nth roots
   */return t(cS,{Complex:function(e){return o(e,2)},"Complex, number":o})}),cM=ta("number",["typed"],e=>{var{typed:t}=e,r=t("number",{"":function(){return 0},number:function(e){return e},string:function(e){if("NaN"===e)return NaN;var t,r,n=(r=(t=e).match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/))?{input:t,radix:({"0b":2,"0o":8,"0x":16})[r[1]],integerPart:r[2],fractionalPart:r[3]}:null;if(n)return(/**
 * Makes a number from a radix, and integer part, and a fractional part
 * @param {parts} [x] parts of the number string (from getNonDecimalNumberParts)
 * @returns {number} the number
 */function(e){for(var t=parseInt(e.integerPart,e.radix),r=0,n=0;n<e.fractionalPart.length;n++)r+=parseInt(e.fractionalPart[n],e.radix)/Math.pow(e.radix,n+1);var i=t+r;if(isNaN(i))throw SyntaxError('String "'+e.input+'" is not a valid number');return i}(n));var i=0,a=e.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);a&&(// x includes a size suffix like 0xffffi32, so we extract
// the suffix and remove it from x
i=Number(a[2]),e=a[1]);var o=Number(e);if(isNaN(o))throw SyntaxError('String "'+e+'" is not a valid number');if(a){// x is a signed bin, oct, or hex literal
// num is the value of string x if x is interpreted as unsigned
if(o>2**i-1)throw SyntaxError('String "'.concat(e,'" is out of range'));// check if the bit at index size - 1 is set and if so do the twos complement
o>=2**(i-1)&&(o-=2**i)}return o},BigNumber:function(e){return e.toNumber()},Fraction:function(e){return e.valueOf()},Unit:t.referToSelf(e=>t=>{var r=t.clone();return r.value=e(t.value),r}),null:function(e){return 0},"Unit, string | Unit":function(e,t){return e.toNumber(t)},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))});return(// reviver function to parse a JSON object like:
//
//     {"mathjs":"number","value":"2.3"}
//
// into a number 2.3
r.fromJSON=function(e){return parseFloat(e.value)},r)}),cF=ta("numeric",["number","?bignumber","?fraction"],e=>{var{number:t,bignumber:r,fraction:n}=e,i={string:!0,number:!0,BigNumber:!0,Fraction:!0},a={number:e=>t(e),BigNumber:r?e=>r(e):ni,Fraction:n?e=>n(e):na};/**
   * Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.
   *
   * Syntax:
   *
   *    math.numeric(x)
   *
   * Examples:
   *
   *    math.numeric('4')                           // returns 4
   *    math.numeric('4', 'number')                 // returns 4
   *    math.numeric('4', 'BigNumber')              // returns BigNumber 4
   *    math.numeric('4', 'Fraction')               // returns Fraction 4
   *    math.numeric(4, 'Fraction')                 // returns Fraction 4
   *    math.numeric(math.fraction(2, 5), 'number') // returns 0.4
   *
   * See also:
   *
   *    number, fraction, bignumber, string, format
   *
   * @param {string | number | BigNumber | Fraction } value
   *              A numeric value or a string containing a numeric value
   * @param {string} outputType
   *              Desired numeric output type.
   *              Available values: 'number', 'BigNumber', or 'Fraction'
   * @return {number | BigNumber | Fraction}
   *              Returns an instance of the numeric in the requested type
   */return function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"number",r=arguments.length>2?arguments[2]:void 0;if(void 0!==r)throw SyntaxError("numeric() takes one or two arguments");var n=Y(e);if(!(n in i))throw TypeError("Cannot convert "+e+' of type "'+n+'"; valid input types are '+Object.keys(i).join(", "));if(!(t in a))throw TypeError("Cannot convert "+e+' to type "'+t+'"; valid output types are '+Object.keys(a).join(", "));return t===n?e:a[t](e)}}),cB=ta("oct",["typed","format"],e=>{var{typed:t,format:r}=e;return t("oct",{"number | BigNumber":function(e){return r(e,{notation:"oct"})},"number | BigNumber, number":function(e,t){return r(e,{notation:"oct",wordSize:t})}})}),cT=ta("ones",["typed","config","matrix","BigNumber"],e=>{var{typed:t,config:r,matrix:n,BigNumber:i}=e;/**
   * Create a matrix filled with ones. The created matrix can have one or
   * multiple dimensions.
   *
   * Syntax:
   *
   *    math.ones(m)
   *    math.ones(m, format)
   *    math.ones(m, n)
   *    math.ones(m, n, format)
   *    math.ones([m, n])
   *    math.ones([m, n], format)
   *    math.ones([m, n, p, ...])
   *    math.ones([m, n, p, ...], format)
   *
   * Examples:
   *
   *    math.ones()                    // returns []
   *    math.ones(3)                   // returns [1, 1, 1]
   *    math.ones(3, 2)                // returns [[1, 1], [1, 1], [1, 1]]
   *    math.ones(3, 2, 'dense')       // returns Dense Matrix [[1, 1], [1, 1], [1, 1]]
   *
   *    const A = [[1, 2, 3], [4, 5, 6]]
   *    math.ones(math.size(A))       // returns [[1, 1, 1], [1, 1, 1]]
   *
   * See also:
   *
   *    zeros, identity, size, range
   *
   * @param {...(number|BigNumber) | Array} size    The size of each dimension of the matrix
   * @param {string} [format]           The Matrix storage format
   *
   * @return {Array | Matrix | number}  A matrix filled with ones
   */return t("ones",{"":function(){return"Array"===r.matrix?a([]):a([],"default")},// math.ones(m, n, p, ..., format)
// TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
"...number | BigNumber | string":function(e){if("string"==typeof e[e.length-1]){var t=e.pop();return a(e,t)}return"Array"===r.matrix?a(e):a(e,"default")},Array:a,Matrix:function(e){var t=e.storage();return a(e.valueOf(),t)},"Array | Matrix, string":function(e,t){return a(e.valueOf(),t)}});/**
   * Create an Array or Matrix with ones
   * @param {Array} size
   * @param {string} [format='default']
   * @return {Array | Matrix}
   * @private
   */function a(e,t){var r,a=(r=!1,e.forEach(function(e,t,n){c(e)&&(r=!0,n[t]=e.toNumber())}),r)?new i(1):1;if(// validate arguments
function(e){e.forEach(function(e){if("number"!=typeof e||!eh(e)||e<0)throw Error("Parameters in function ones must be positive integers")})}(e),t){// return a matrix
var o=n(t);return e.length>0?o.resize(e,a):o}// return an Array
var s=[];return e.length>0?eX(s,e,a):s}}),cO=ta("or",["typed","matrix","equalScalar","DenseMatrix","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,DenseMatrix:i,concat:a}=e,o=i5({typed:t}),s=oU({typed:t,equalScalar:n}),u=i6({typed:t,DenseMatrix:i}),l=iI({typed:t,matrix:r,concat:a});/**
   * Logical `or`. Test if at least one value is defined with a nonzero/nonempty value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.or(x, y)
   *
   * Examples:
   *
   *    math.or(2, 4)   // returns true
   *
   *    a = [2, 5, 0]
   *    b = [0, 22, 0]
   *    c = 0
   *
   *    math.or(a, b)   // returns [true, true, false]
   *    math.or(b, c)   // returns [false, true, false]
   *
   * See also:
   *
   *    and, not, xor
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when one of the inputs is defined with a nonzero/nonempty value.
   */return t("or",{"number, number":iG,"Complex, Complex":function(e,t){return 0!==e.re||0!==e.im||0!==t.re||0!==t.im},"BigNumber, BigNumber":function(e,t){return!e.isZero()&&!e.isNaN()||!t.isZero()&&!t.isNaN()},"Unit, Unit":t.referToSelf(e=>(t,r)=>e(t.value||0,r.value||0))},l({SS:s,DS:o,Ss:u}))}),c_="partitionSelect",cz=ta(c_,["typed","isNumeric","isNaN","compare"],e=>{var{typed:t,isNumeric:r,isNaN:n,compare:i}=e,a=(e,t)=>-i(e,t);/**
   * Partition-based selection of an array or 1D matrix.
   * Will find the kth smallest value, and mutates the input array.
   * Uses Quickselect.
   *
   * Syntax:
   *
   *    math.partitionSelect(x, k)
   *    math.partitionSelect(x, k, compare)
   *
   * Examples:
   *
   *    math.partitionSelect([5, 10, 1], 2)                               // returns 10
   *    math.partitionSelect(['C', 'B', 'A', 'D'], 1, math.compareText)   // returns 'B'
   *
   *    function sortByLength (a, b) {
   *      return a.length - b.length
   *    }
   *    math.partitionSelect(['Langdon', 'Tom', 'Sara'], 2, sortByLength) // returns 'Langdon'
   *
   *    // the input array is mutated
   *    arr = [5, 2, 1]
   *    math.partitionSelect(arr, 0) // returns 1, arr is now: [1, 2, 5]
   *    math.partitionSelect(arr, 1, 'desc') // returns 2, arr is now: [5, 2, 1]
   *
   * See also:
   *
   *    sort
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to sort
   * @param {Number} k            The kth smallest value to be retrieved zero-based index
   * @param {Function | 'asc' | 'desc'} [compare='asc']
   *        An optional comparator function. The function is called as
   *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,
   *        and 0 when a == b.
   * @return {*} Returns the kth lowest value.
   */return t(c_,{"Array | Matrix, number":function(e,t){return o(e,t,i)},"Array | Matrix, number, string":function(e,t,r){if("asc"===r)return o(e,t,i);if("desc"===r)return o(e,t,a);throw Error('Compare string must be "asc" or "desc"')},"Array | Matrix, number, function":o});function o(e,t,r){if(!eh(t)||t<0)throw Error("k must be a non-negative integer");if(g(e)){if(e.size().length>1)throw Error("Only one dimensional matrices supported");return s(e.valueOf(),t,r)}if(Array.isArray(e))return s(e,t,r)}/**
   * Quickselect algorithm.
   * Code adapted from:
   * https://blog.teamleadnet.com/2012/07/quick-select-algorithm-find-kth-element.html
   *
   * @param {Array} arr
   * @param {Number} k
   * @param {Function} compare
   * @private
   */function s(e,t,i){if(t>=e.length)throw Error("k out of bounds");// check for NaN values since these can cause an infinite while loop
for(var a=0;a<e.length;a++)if(r(e[a])&&n(e[a]))return e[a];// return NaN
// if from == to we reached the kth element
for(var o=0,s=e.length-1;o<s;){// stop if the reader and writer meets
for(var u=o,l=s,c=e[Math.floor(Math.random()*(s-o+1))+o];u<l;)if(i(e[u],c)>=0){// put the large values at the end
var f=e[l];e[l]=e[u],e[u]=f,--l}else++u;i(e[u],c)>0&&--u,t<=u?s=u:o=u+1}return e[t]}}),cq="permutations",ck=ta(cq,["typed","factorial"],e=>{var{typed:t,factorial:r}=e;/**
   * Compute the number of ways of obtaining an ordered subset of `k` elements
   * from a set of `n` elements.
   *
   * Permutations only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   * Syntax:
   *
   *     math.permutations(n)
   *     math.permutations(n, k)
   *
   * Examples:
   *
   *    math.permutations(5)     // 120
   *    math.permutations(5, 3)  // 60
   *
   * See also:
   *
   *    combinations, combinationsWithRep, factorial
   *
   * @param {number | BigNumber} n   The number of objects in total
   * @param {number | BigNumber} [k] The number of objects in the subset
   * @return {number | BigNumber}    The number of permutations
   */return t(cq,{"number | BigNumber":r,"number, number":function(e,t){if(!eh(e)||e<0||!eh(t)||t<0)throw TypeError("Positive integer value expected in function permutations");if(t>e)throw TypeError("second argument k must be less than or equal to first argument n");// Permute n objects, k at a time
return o_(e-t+1,e)},"BigNumber, BigNumber":function(e,t){var r,n;if(!cI(e)||!cI(t))throw TypeError("Positive integer value expected in function permutations");if(t.gt(e))throw TypeError("second argument k must be less than or equal to first argument n");for(r=e.mul(0).add(1),n=e.minus(t).plus(1);n.lte(e);n=n.plus(1))r=r.times(n);return r}})});/**
 * Test whether BigNumber n is a positive integer
 * @param {BigNumber} n
 * @returns {boolean} isPositiveInteger
 */function cI(e){return e.isInteger()&&e.gte(0)}var cR={},cP=i("cmoHh"),cj=i("euRi5"),cU=i("hDsEw"),cL=i("3J2Zm"),c$=i("6Px8M"),cH=i("lDm0S"),cZ={};!/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/function(e,t,r){//
// The following constants are related to IEEE 754 limits.
//
var n,a="random",o=r.pow(256,6),s=r.pow(2,52),u=2*s;// node.js crypto module, initialized at the bottom.
//
// seedrandom()
// This is the seedrandom function described above.
//
function l(i,l,d){var h=[],g=p(//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function e(t,r){var n,i=[],a=typeof t;if(r&&"object"==a)for(n in t)try{i.push(e(t[n],r-1))}catch(e){}return i.length?i:"string"==a?t:t+"\x00"}((l=!0==l?{entropy:!0}:l||{}).entropy?[i,m(t)]:null==i?//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function(){try{var r;return n&&(r=n.randomBytes)?r=r(256):(r=new Uint8Array(256),(e.crypto||e.msCrypto).getRandomValues(r)),m(r)}catch(r){var i=e.navigator,a=i&&i.plugins;return[+new Date,e,a,e.screen,m(t)]}}():i,3),h),y=new c(h),v=function(){for(var e=y.g(6),t=o,r=0;e<s;)e=(e+r)*256,t*=256,r=y.g(1);for(;e>=u;)e/=2,t/=2,r>>>=1;return(e+r)/t;// Form the number within [0, 1).
};// Calling convention: what to return as a function of prng, seed, is_math.
return v.int32=function(){return 0|y.g(4)},v.quick=function(){return y.g(4)/4294967296},v.double=v,// Mix the randomness into accumulated entropy.
p(m(y.S),t),(l.pass||d||function(e,t,n,i){return(// If called as a method of Math (Math.seedrandom()), mutate
// Math.random because that is how seedrandom.js has worked since v1.0.
(i&&(i.S&&f(i,y),// Only provide the .state method if requested via options.state.
e.state=function(){return f(y,{})}),n)?(r[a]=e,t):e)})(v,g,"global"in l?l.global:this==r,l.state)}//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function c(e){var t,r=e.length,n=this,i=0,a=n.i=n.j=0,o=n.S=[];// Set up S using the standard key scheduling algorithm.
for(r||(e=[r++]);i<256;)o[i]=i++;for(i=0;i<256;i++)o[i]=o[a=255&a+e[i%r]+(t=o[i])],o[a]=t;// The "g" method returns the next (count) outputs as one number.
(n.g=function(e){for(// Using instance members instead of closure state nearly doubles speed.
var t,r=0,i=n.i,a=n.j,o=n.S;e--;)t=o[i=255&i+1],r=256*r+o[255&(o[i]=o[a=255&a+t])+(o[a]=t)];return n.i=i,n.j=a,r;// For robust unpredictability, the function call below automatically
// discards an initial batch of values.  This is called RC4-drop[256].
// See http://google.com/search?q=rsa+fluhrer+response&btnI
})(256)}//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function f(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function p(e,t){for(var r,n=e+"",i=0;i<n.length;)t[255&i]=255&(r^=19*t[255&i])+n.charCodeAt(i++);return m(t)}//
// tostring()
// Converts an array of charcodes to a string
//
function m(e){return String.fromCharCode.apply(0,e)}//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if(//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
p(r.random(),t),cZ){cZ=l;// When in node.js, try using crypto package for autoseeding.
try{n=i("kjyEk")}catch(e){}}else"function"==typeof define&&define.amd?define(function(){return l}):r["seed"+a]=l;// End anonymous scope, and pass initial values.
}(// otherwise `this` in Node and other environments
"undefined"!=typeof self?self:cZ,[],Math// math: package containing random, pow, and seedrandom
),cZ.alea=cP,cZ.xor128=cj,cZ.xorwow=cU,cZ.xorshift7=cL,cZ.xor4096=c$,cZ.tychei=cH;var cG=/*@__PURE__*/e(cR=cZ)(Date.now());function cV(t){var r;return r=null===t?cG:/*@__PURE__*/e(cR)(String(t)),// wrapper function so the rng can be updated via generator
function(){return r()}}var cW="pickRandom",cY=ta(cW,["typed","config","?on"],e=>{var{typed:t,config:r,on:n}=e,i=cV(r.randomSeed);/**
   * Random pick one or more values from a one dimensional array.
   * Array elements are picked using a random function with uniform or weighted distribution.
   *
   * Syntax:
   *
   *     math.pickRandom(array)
   *     math.pickRandom(array, number)
   *     math.pickRandom(array, weights)
   *     math.pickRandom(array, number, weights)
   *     math.pickRandom(array, weights, number)
   *     math.pickRandom(array, { weights, number, elementWise })
   *
   * Examples:
   *
   *     math.pickRandom([3, 6, 12, 2])                  // returns one of the values in the array
   *     math.pickRandom([3, 6, 12, 2], 2)               // returns an array of two of the values in the array
   *     math.pickRandom([3, 6, 12, 2], { number: 2 })   // returns an array of two of the values in the array
   *     math.pickRandom([3, 6, 12, 2], [1, 3, 2, 1])    // returns one of the values in the array with weighted distribution
   *     math.pickRandom([3, 6, 12, 2], 2, [1, 3, 2, 1]) // returns an array of two of the values in the array with weighted distribution
   *     math.pickRandom([3, 6, 12, 2], [1, 3, 2, 1], 2) // returns an array of two of the values in the array with weighted distribution
   *
   *     math.pickRandom([{x: 1.0, y: 2.0}, {x: 1.1, y: 2.0}], { elementWise: false })
   *         // returns one of the items in the array
   *
   * See also:
   *
   *     random, randomInt
   *
   * @param {Array | Matrix} array     A one dimensional array
   * @param {Int} number               An int or float
   * @param {Array | Matrix} weights   An array of ints or floats
   * @return {number | Array}          Returns a single random value from array when number is undefined.
   *                                   Returns an array with the configured number of elements when number is defined.
   */return n&&n("config",function(e,t){e.randomSeed!==t.randomSeed&&(i=cV(e.randomSeed))}),t(cW,{"Array | Matrix":function(e){return a(e,{})},"Array | Matrix, Object":function(e,t){return a(e,t)},"Array | Matrix, number":function(e,t){return a(e,{number:t})},"Array | Matrix, Array | Matrix":function(e,t){return a(e,{weights:t})},"Array | Matrix, Array | Matrix, number":function(e,t,r){return a(e,{number:r,weights:t})},"Array | Matrix, number, Array | Matrix":function(e,t,r){return a(e,{number:t,weights:r})}});/**
   * @param {Array | Matrix} possibles
   * @param {{
   *   number?: number,
   *   weights?: Array | Matrix,
   *   elementWise: boolean
   * }} options
   * @returns {number | Array}
   * @private
   */function a(e,t){var r,{number:n,weights:a,elementWise:o=!0}=t,s=void 0===n;s&&(n=1);var u=g(e)?e.create:g(a)?a.create:null;e=e.valueOf(),a&&(a=a.valueOf()),!0===o&&(e=e3(e),a=e3(a));var c=0;if(void 0!==a){if(a.length!==e.length)throw Error("Weights must have the same length as possibles");for(var f=0,p=a.length;f<p;f++){if(!l(a[f])||a[f]<0)throw Error("Weights must be an array of positive numbers");c+=a[f]}}for(var m=e.length,d=[];d.length<n;){if(void 0===a)r=e[Math.floor(i()*m)];else for(var h=i()*c,y=0,v=e.length;y<v;y++)if((h-=a[y])<0){r=e[y];break}d.push(r)}return s?d[0]:u?u(d):d}}),cJ="pinv",cX=ta(cJ,["typed","matrix","inv","deepEqual","equal","dotDivide","dot","ctranspose","divideScalar","multiply","add","Complex"],e=>{var{typed:t,matrix:r,inv:n,deepEqual:i,equal:a,dotDivide:o,dot:s,ctranspose:u,divideScalar:l,multiply:c,add:f,Complex:p}=e;/**
   * Calculate the Moore–Penrose inverse of a matrix.
   *
   * Syntax:
   *
   *     math.pinv(x)
   *
   * Examples:
   *
   *     math.pinv([[1, 2], [3, 4]])          // returns [[-2, 1], [1.5, -0.5]]
   *     math.pinv([[1, 0], [0, 1], [0, 1]])  // returns [[1, 0, 0], [0, 0.5, 0.5]]
   *     math.pinv(4)                         // returns 0.25
   *
   * See also:
   *
   *     inv
   *
   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
   * @return {number | Complex | Array | Matrix} The inverse of `x`.
   */return t(cJ,{"Array | Matrix":function(e){var t=g(e)?e.size():eG(e);switch(t.length){case 1:// vector
if(h(e))return u(e);// null vector
if(1===t[0])return n(e);// invertible matrix
return o(u(e),s(e,e));case 2:if(h(e))return u(e);// zero matrixx
var i=t[0],a=t[1];if(i===a)try{return n(e);// invertible matrix
}catch(e){if(e instanceof Error&&e.message.match(/Cannot calculate inverse, determinant is zero/));else throw e}if(g(e))return r(m(e.valueOf(),i,a),e.storage());return m(e,i,a);default:// multi dimensional array
throw RangeError("Matrix must be two dimensional (size: "+eP(t)+")")}},any:function(e){return(// scalar
a(e,0)?J(e):l(1,e)// zero
)}});/**
   * Calculate the Moore–Penrose inverse of a matrix
   * @param {Array[]} mat     A matrix
   * @param {number} rows     Number of rows
   * @param {number} cols     Number of columns
   * @return {Array[]} pinv    Pseudoinverse matrix
   * @private
   */function m(e,t,r){var i,{C:a,F:l}=(i=/**
   * Calculate the reduced row echelon form of a matrix
   *
   * Modified from https://rosettacode.org/wiki/Reduced_row_echelon_form
   *
   * @param {Array[]} mat     A matrix
   * @param {number} rows     Number of rows
   * @param {number} cols     Number of columns
   * @return {Array[]}        Reduced row echelon form
   * @private
   */function(e,t,r){for(var n=J(e),i=0,a=0;a<t&&!(r<=i);a++){for(var s=a;d(n[s][i]);)if(t===++s&&(s=a,r===++i))return n;[n[s],n[a]]=[n[a],n[s]];for(var u=n[a][i],l=0;l<r;l++)n[a][l]=o(n[a][l],u);for(var p=0;p<t;p++)if(p!==a){u=n[p][i];for(var m=0;m<r;m++)n[p][m]=f(n[p][m],c(-1,c(u,n[a][m])))}i++}return n}(e,t,r),{C:e.map((e,r)=>e.filter((e,r)=>r<t&&!d(s(i[r],i[r])))),F:i.filter((e,t)=>!d(s(i[t],i[t])))}),p=c(n(c(u(a),a)),u(a)),m=c(u(l),n(c(l,u(l))));// TODO: Use SVD instead (may improve precision)
return c(m,p)}function d(e){return a(f(e,p(1,1)),f(0,p(1,1)))}function h(e){return i(f(e,p(1,1)),f(c(e,0),p(1,1)))}}),cQ="polynomialRoot",cK=ta(cQ,["typed","isZero","equalScalar","add","subtract","multiply","divide","sqrt","unaryMinus","cbrt","typeOf","im","re"],e=>{var{typed:t,isZero:r,equalScalar:n,add:i,subtract:a,multiply:o,divide:s,sqrt:u,unaryMinus:l,cbrt:c,typeOf:f,im:p,re:m}=e;/**
   * Finds the numerical values of the distinct roots of a polynomial with real or complex coefficients.
   * Currently operates only on linear, quadratic, and cubic polynomials using the standard
   * formulas for the roots.
   *
   * Syntax:
   *
   *     math.polynomialRoot(constant, linearCoeff, quadraticCoeff, cubicCoeff)
   *
   * Examples:
   *     // linear
   *     math.polynomialRoot(6, 3)                                        // [-2]
   *     math.polynomialRoot(math.complex(6,3), 3)                        // [-2 - i]
   *     math.polynomialRoot(math.complex(6,3), math.complex(2,1))        // [-3 + 0i]
   *     // quadratic
   *     math.polynomialRoot(2, -3, 1)                                    // [2, 1]
   *     math.polynomialRoot(8, 8, 2)                                     // [-2]
   *     math.polynomialRoot(-2, 0, 1)                                    // [1.4142135623730951, -1.4142135623730951]
   *     math.polynomialRoot(2, -2, 1)                                    // [1 + i, 1 - i]
   *     math.polynomialRoot(math.complex(1,3), math.complex(-3, -2), 1)  // [2 + i, 1 + i]
   *     // cubic
   *     math.polynomialRoot(-6, 11, -6, 1)                               // [1, 3, 2]
   *     math.polynomialRoot(-8, 0, 0, 1)                                 // [-1 - 1.7320508075688774i, 2, -1 + 1.7320508075688774i]
   *     math.polynomialRoot(0, 8, 8, 2)                                  // [0, -2]
   *     math.polynomialRoot(1, 1, 1, 1)                                  // [-1 + 0i, 0 - i, 0 + i]
   *
   * See also:
   *     cbrt, sqrt
   *
   * @param {... number | Complex} coeffs
   *     The coefficients of the polynomial, starting with with the constant coefficent, followed
   *     by the linear coefficient and subsequent coefficients of increasing powers.
   * @return {Array} The distinct roots of the polynomial
   */return t(cQ,{"number|Complex, ...number|Complex":(e,t)=>{for(var d=[e,...t];d.length>0&&r(d[d.length-1]);)d.pop();if(d.length<2)throw RangeError("Polynomial [".concat(e,", ").concat(t,"] must have a non-zero non-constant coefficient"));switch(d.length){case 2:// linear
return[l(s(d[0],d[1]))];case 3:// quadratic
var[h,g,y]=d,v=o(2,y),x=o(g,g),b=o(4,y,h);if(n(x,b))return[s(l(g),v)];var N=u(a(x,b));return[s(a(N,g),v),s(a(l(N),g),v)];case 4:// cubic, cf. https://en.wikipedia.org/wiki/Cubic_equation
var[w,D,E,A]=d,S=l(o(3,A)),C=o(E,E),M=o(3,A,D),F=i(o(2,E,E,E),o(27,A,A,w)),B=o(9,A,E,D);if(n(C,M)&&n(F,B))return[s(E,S)];var T=a(C,M),O=a(F,B);if(n(i(o(18,A,E,D,w),o(E,E,D,D)),i(o(4,E,E,E,w),o(4,A,D,D,D),o(27,A,A,w,w))))return[s(a(o(4,A,E,D),i(o(9,A,A,w),o(E,E,E))),o(A,T)),// simple root
s(a(o(9,A,w),o(E,D)),o(2,T))// double root
];return c(n(C,M)?O:s(i(O,u(a(o(O,O),o(4,T,T,T)))),2),!0).toArray().map(e=>s(i(E,e,s(T,e)),S)).map(e=>"Complex"===f(e)&&n(m(e),m(e)+p(e))?m(e):e);default:throw RangeError("only implemented for cubic or lower-order polynomials, not ".concat(d))}}})}),c0=ta("pow",["typed","config","identity","multiply","matrix","inv","fraction","number","Complex"],e=>{var{typed:t,config:r,identity:n,multiply:i,matrix:a,inv:o,number:s,fraction:u,Complex:l}=e;/**
   * Calculates the power of x to y, `x ^ y`.
   *
   * Matrix exponentiation is supported for square matrices `x` and integers `y`:
   * when `y` is nonnegative, `x` may be any square matrix; and when `y` is
   * negative, `x` must be invertible, and then this function returns
   * inv(x)^(-y).
   *
   * For cubic roots of negative numbers, the function returns the principal
   * root by default. In order to let the function return the real root,
   * math.js can be configured with `math.config({predictable: true})`.
   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.
   *
   * Syntax:
   *
   *    math.pow(x, y)
   *
   * Examples:
   *
   *    math.pow(2, 3)               // returns number 8
   *
   *    const a = math.complex(2, 3)
   *    math.pow(a, 2)                // returns Complex -5 + 12i
   *
   *    const b = [[1, 2], [4, 3]]
   *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]
   *
   *    const c = [[1, 2], [4, 3]]
   *    math.pow(c, -1)               // returns Array [[-0.6, 0.4], [0.8, -0.2]]
   *
   * See also:
   *
   *    multiply, sqrt, cbrt, nthRoot
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
   * @param  {number | BigNumber | Complex} y                          The exponent
   * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`
   */return t("pow",{"number, number":c,"Complex, Complex":function(e,t){return e.pow(t)},"BigNumber, BigNumber":function(e,t){return t.isInteger()||e>=0||r.predictable?e.pow(t):new l(e.toNumber(),0).pow(t.toNumber(),0)},"Fraction, Fraction":function(e,t){var n=e.pow(t);if(null!=n)return n;if(!r.predictable)return c(e.valueOf(),t.valueOf());throw Error("Result of pow is non-rational and cannot be expressed as a fraction")},"Array, number":f,"Array, BigNumber":function(e,t){return f(e,t.toNumber())},"Matrix, number":p,"Matrix, BigNumber":function(e,t){return p(e,t.toNumber())},"Unit, number | BigNumber":function(e,t){return e.pow(t)}});/**
   * Calculates the power of x to y, x^y, for two numbers.
   * @param {number} x
   * @param {number} y
   * @return {number | Complex} res
   * @private
   */function c(e,t){// Alternatively could define a 'realmode' config option or something, but
// 'predictable' will work for now
if(r.predictable&&!eh(t)&&e<0)try{var n=u(t),i=s(n);if((t===i||1e-14>Math.abs((t-i)/t))&&n.d%2==1)return(n.n%2==0?1:-1)*Math.pow(-e,t)}catch(e){// fraction() throws an error if y is Infinity, etc.
}return(// **for predictable mode** x^Infinity === NaN if x < -1
// N.B. this behavour is different from `Math.pow` which gives
// (-2)^Infinity === Infinity
r.predictable&&(e<-1&&t===1/0||e>-1&&e<0&&t===-1/0)?NaN:eh(t)||e>=0||r.predictable?n9(e,t):// TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow
// x^Infinity === 0 if -1 < x < 1
// A real number 0 is returned instead of complex(0)
e*e<1&&t===1/0||e*e>1&&t===-1/0?0:new l(e,0).pow(t,0))}/**
   * Calculate the power of a 2d array
   * @param {Array} x     must be a 2 dimensional, square matrix
   * @param {number} y    a integer value (positive if `x` is not invertible)
   * @returns {Array}
   * @private
   */function f(e,t){if(!eh(t))throw TypeError("For A^b, b must be an integer (value is "+t+")");// verify that A is a 2 dimensional square matrix
var r=eG(e);if(2!==r.length)throw Error("For A^b, A must be 2 dimensional (A has "+r.length+" dimensions)");if(r[0]!==r[1])throw Error("For A^b, A must be square (size is "+r[0]+"x"+r[1]+")");if(t<0)try{return f(o(e),-t)}catch(e){if("Cannot calculate inverse, determinant is zero"===e.message)throw TypeError("For A^b, when A is not invertible, b must be a positive integer (value is "+t+")");throw e}for(var a=n(r[0]).valueOf(),s=e;t>=1;)(1&t)==1&&(a=i(s,a)),t>>=1,s=i(s,s);return a}/**
   * Calculate the power of a 2d matrix
   * @param {Matrix} x     must be a 2 dimensional, square matrix
   * @param {number} y    a positive, integer value
   * @returns {Matrix}
   * @private
   */function p(e,t){return a(f(e.valueOf(),t))}}),c1="prod",c2=ta(c1,["typed","config","multiplyScalar","numeric"],e=>{var{typed:t,config:r,multiplyScalar:n,numeric:i}=e;/**
   * Compute the product of a matrix or a list with values.
   * In case of a multidimensional array or matrix, the sum of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.prod(a, b, c, ...)
   *     math.prod(A)
   *
   * Examples:
   *
   *     math.multiply(2, 3)           // returns 6
   *     math.prod(2, 3)               // returns 6
   *     math.prod(2, 3, 4)            // returns 24
   *     math.prod([2, 3, 4])          // returns 24
   *     math.prod([[2, 5], [4, 3]])   // returns 120
   *
   * See also:
   *
   *    mean, median, min, max, sum, std, variance
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The product of all values
   */return t(c1,{// prod([a, b, c, d, ...])
"Array | Matrix":a,// prod([a, b, c, d, ...], dim)
"Array | Matrix, number | BigNumber":function(e,t){// TODO: implement prod(A, dim)
throw Error("prod(A, dim) is not yet supported");// return reduce(arguments[0], arguments[1], math.prod)
},// prod(a, b, c, d, ...)
"...":function(e){return a(e)}});/**
   * Recursively calculate the product of an n-dimensional array
   * @param {Array} array
   * @return {number} prod
   * @private
   */function a(e){var t;if(tz(e,function(e){try{t=void 0===t?e:n(t,e)}catch(t){throw t4(t,"prod",e)}}),"string"==typeof t&&(t=i(t,r.number)),void 0===t)throw Error("Cannot calculate prod of an empty array");return t}}),c3=ta("qr",["typed","matrix","zeros","identity","isZero","equal","sign","sqrt","conj","unaryMinus","addScalar","divideScalar","multiplyScalar","subtractScalar","complex"],t=>{var{typed:r,matrix:n,zeros:i,identity:a,isZero:s,equal:u,sign:l,sqrt:c,conj:f,unaryMinus:p,addScalar:m,divideScalar:d,multiplyScalar:h,subtractScalar:g,complex:y}=t;/**
   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in
   * two matrices (`Q`, `R`) where `Q` is an
   * orthogonal matrix and `R` is an upper triangular matrix.
   *
   * Syntax:
   *
   *    math.qr(A)
   *
   * Example:
   *
   *    const m = [
   *      [1, -1,  4],
   *      [1,  4, -2],
   *      [1,  4,  2],
   *      [1,  -1, 0]
   *    ]
   *    const result = math.qr(m)
   *    // r = {
   *    //   Q: [
   *    //     [0.5, -0.5,   0.5],
   *    //     [0.5,  0.5,  -0.5],
   *    //     [0.5,  0.5,   0.5],
   *    //     [0.5, -0.5,  -0.5],
   *    //   ],
   *    //   R: [
   *    //     [2, 3,  2],
   *    //     [0, 5, -2],
   *    //     [0, 0,  4],
   *    //     [0, 0,  0]
   *    //   ]
   *    // }
   *
   * See also:
   *
   *    lup, lusolve
   *
   * @param {Matrix | Array} A    A two dimensional matrix or array
   * for which to get the QR decomposition.
   *
   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal
   * matrix and R: the upper triangular matrix
   */return /*@__PURE__*/e(o)(r("qr",{DenseMatrix:function(e){return x(e)},SparseMatrix:function(e){return function(e){throw Error("qr not implemented for sparse matrices yet")}(0)},Array:function(e){// lup, use matrix implementation
var t=x(n(e));// result
return{Q:t.Q.valueOf(),R:t.R.valueOf()}}}),{_denseQRimpl:v});function v(e){// rows & columns (m x n)
var t,r,n,o=e._size[0],y=e._size[1],v=a([o],"dense"),x=v._data,b=e.clone(),N=b._data,w=i([o],"");// m
for(n=0;n<Math.min(y,o);++n){/*
       * **k-th Household matrix**
       *
       * The matrix I - 2*v*transpose(v)
       * x     = first column of A
       * x1    = first element of x
       * alpha = x1 / |x1| * |x|
       * e1    = tranpose([1, 0, 0, ...])
       * u     = x - alpha * e1
       * v     = u / |u|
       *
       * Household matrix = I - 2 * v * tranpose(v)
       *
       *  * Initially Q = I and R = A.
       *  * Household matrix is a reflection in a plane normal to v which
       *    will zero out all but the top right element in R.
       *  * Appplying reflection to both Q and R will not change product.
       *  * Repeat this process on the (1,1) minor to get R as an upper
       *    triangular matrix.
       *  * Reflections leave the magnitude of the columns of Q unchanged
       *    so Q remains othoganal.
       *
       */var D=N[n][n],E=p(u(D,0)?1:l(D)),A=f(E),S=0;for(t=n;t<o;t++)S=m(S,h(N[t][n],f(N[t][n])));var C=h(E,c(S));if(!s(C)){// first element in vector u
var M=g(D,C);for(// w = v * u1 / |u|    (only elements k to (rows-1) are used)
w[n]=1,t=n+1;t<o;t++)w[t]=d(N[t][n],M);// tau = - conj(u1 / alpha)
var F=p(f(d(M,C))),B=void 0;/*
         * tau and w have been choosen so that
         *
         * 2 * v * tranpose(v) = tau * w * tranpose(w)
         *//*
         * -- calculate R = R - tau * w * tranpose(w) * R --
         * Only do calculation with rows k to (rows-1)
         * Additionally columns 0 to (k-1) will not be changed by this
         *   multiplication so do not bother recalculating them
         */for(r=n;r<y;r++){// calculate jth element of [tranpose(w) * R]
for(B=0,t=n;t<o;t++)B=m(B,h(f(w[t]),N[t][r]));for(// calculate the jth element of [tau * transpose(w) * R]
B=h(B,F),t=n;t<o;t++)N[t][r]=h(g(N[t][r],h(w[t],B)),A)}/*
         * -- calculate Q = Q - tau * Q * w * transpose(w) --
         * Q is a square matrix (rows x rows)
         * Only do calculation with columns k to (rows-1)
         * Additionally rows 0 to (k-1) will not be changed by this
         *   multiplication so do not bother recalculating them
         */for(t=0;t<o;t++){// calculate ith element of [Q * w]
for(B=0,r=n;r<o;r++)B=m(B,h(x[t][r],w[r]));for(// calculate the ith element of [tau * Q * w]
B=h(B,F),r=n;r<o;++r)x[t][r]=d(g(x[t][r],h(B,f(w[r]))),A)}}}// return matrices
return{Q:v,R:b,toString:function(){return"Q: "+this.Q.toString()+"\nR: "+this.R.toString()}}}function x(e){var t=v(e),r=t.R._data;if(e._data.length>0)for(var n="Complex"===r[0][0].type?y(0):0,i=0;i<r.length;++i)for(var a=0;a<i&&a<(r[0]||[]).length;++a)r[i][a]=n;return t}});/**
 * This is a util function for generating a random matrix recursively.
 * @param {number[]} size
 * @param {function} random
 * @returns {Array}
 */function c4(e,t){var r=[];if((e=e.slice(0)).length>1)for(var n=0,i=e.shift();n<i;n++)r.push(c4(e,t));else for(var a=0,o=e.shift();a<o;a++)r.push(t());return r}var c5="random",c8=ta(c5,["typed","config","?on"],e=>{var{typed:t,config:r,on:n}=e,i=cV(r.randomSeed);/**
   * Return a random number larger or equal to `min` and smaller than `max`
   * using a uniform distribution.
   *
   * Syntax:
   *
   *     math.random()                // generate a random number between 0 and 1
   *     math.random(max)             // generate a random number between 0 and max
   *     math.random(min, max)        // generate a random number between min and max
   *     math.random(size)            // generate a matrix with random numbers between 0 and 1
   *     math.random(size, max)       // generate a matrix with random numbers between 0 and max
   *     math.random(size, min, max)  // generate a matrix with random numbers between min and max
   *
   * Examples:
   *
   *     math.random()       // returns a random number between 0 and 1
   *     math.random(100)    // returns a random number between 0 and 100
   *     math.random(30, 40) // returns a random number between 30 and 40
   *     math.random([2, 3]) // returns a 2x3 matrix with random numbers between 0 and 1
   *
   * See also:
   *
   *     randomInt, pickRandom
   *
   * @param {Array | Matrix} [size] If provided, an array or matrix with given
   *                                size and filled with random values is returned
   * @param {number} [min]  Minimum boundary for the random value, included
   * @param {number} [max]  Maximum boundary for the random value, excluded
   * @return {number | Array | Matrix} A random number
   */return n&&n("config",function(e,t){e.randomSeed!==t.randomSeed&&(i=cV(e.randomSeed))}),t(c5,{"":()=>0+1*i(),number:e=>0+i()*(e-0),"number, number":(e,t)=>e+i()*(t-e),"Array | Matrix":e=>a(e,0,1),"Array | Matrix, number":(e,t)=>a(e,0,t),"Array | Matrix, number, number":(e,t,r)=>a(e,t,r)});function a(e,t,r){var n=c4(e.valueOf(),()=>t+i()*(r-t));return g(e)?e.create(n):n}}),c6="randomInt",c7=ta(c6,["typed","config","?on"],e=>{var{typed:t,config:r,on:n}=e,i=cV(r.randomSeed);/**
   * Return a random integer number larger or equal to `min` and smaller than `max`
   * using a uniform distribution.
   *
   * Syntax:
   *
   *     math.randomInt()                // generate a random integer between 0 and 1
   *     math.randomInt(max)             // generate a random integer between 0 and max
   *     math.randomInt(min, max)        // generate a random integer between min and max
   *     math.randomInt(size)            // generate a matrix with random integer between 0 and 1
   *     math.randomInt(size, max)       // generate a matrix with random integer between 0 and max
   *     math.randomInt(size, min, max)  // generate a matrix with random integer between min and max
   *
   * Examples:
   *
   *     math.randomInt(100)    // returns a random integer between 0 and 100
   *     math.randomInt(30, 40) // returns a random integer between 30 and 40
   *     math.randomInt([2, 3]) // returns a 2x3 matrix with random integers between 0 and 1
   *
   * See also:
   *
   *     random, pickRandom
   *
   * @param {Array | Matrix} [size] If provided, an array or matrix with given
   *                                size and filled with random values is returned
   * @param {number} [min]  Minimum boundary for the random value, included
   * @param {number} [max]  Maximum boundary for the random value, excluded
   * @return {number | Array | Matrix} A random integer value
   */return n&&n("config",function(e,t){e.randomSeed!==t.randomSeed&&(i=cV(e.randomSeed))}),t(c6,{"":()=>o(0,1),number:e=>o(0,e),"number, number":(e,t)=>o(e,t),"Array | Matrix":e=>a(e,0,1),"Array | Matrix, number":(e,t)=>a(e,0,t),"Array | Matrix, number, number":(e,t,r)=>a(e,t,r)});function a(e,t,r){var n=c4(e.valueOf(),()=>o(t,r));return g(e)?e.create(n):n}function o(e,t){return Math.floor(e+i()*(t-e))}}),c9=ta("Range",[],()=>{/**
   * Create a range. A range has a start, step, and end, and contains functions
   * to iterate over the range.
   *
   * A range can be constructed as:
   *
   *     const range = new Range(start, end)
   *     const range = new Range(start, end, step)
   *
   * To get the result of the range:
   *     range.forEach(function (x) {
   *         console.log(x)
   *     })
   *     range.map(function (x) {
   *         return math.sin(x)
   *     })
   *     range.toArray()
   *
   * Example usage:
   *
   *     const c = new Range(2, 6)       // 2:1:5
   *     c.toArray()                     // [2, 3, 4, 5]
   *     const d = new Range(2, -3, -1)  // 2:-1:-2
   *     d.toArray()                     // [2, 1, 0, -1, -2]
   *
   * @class Range
   * @constructor Range
   * @param {number} start  included lower bound
   * @param {number} end    excluded upper bound
   * @param {number} [step] step size, default value is 1
   */function Range(e,t,r){if(!(this instanceof Range))throw SyntaxError("Constructor must be called with the new operator");var n=null!=e,i=null!=t,a=null!=r;if(n){if(c(e))e=e.toNumber();else if("number"!=typeof e)throw TypeError("Parameter start must be a number")}if(i){if(c(t))t=t.toNumber();else if("number"!=typeof t)throw TypeError("Parameter end must be a number")}if(a){if(c(r))r=r.toNumber();else if("number"!=typeof r)throw TypeError("Parameter step must be a number")}this.start=n?parseFloat(e):0,this.end=i?parseFloat(t):0,this.step=a?parseFloat(r):1}return(/**
   * Attach type information
   */Range.prototype.type="Range",Range.prototype.isRange=!0,/**
   * Parse a string into a range,
   * The string contains the start, optional step, and end, separated by a colon.
   * If the string does not contain a valid range, null is returned.
   * For example str='0:2:11'.
   * @memberof Range
   * @param {string} str
   * @return {Range | null} range
   */Range.parse=function(e){if("string"!=typeof e)return null;var t=e.split(":").map(function(e){return parseFloat(e)});if(t.some(function(e){return isNaN(e)}))return null;switch(t.length){case 2:return new Range(t[0],t[1]);case 3:return new Range(t[0],t[2],t[1]);default:return null}},/**
   * Create a clone of the range
   * @return {Range} clone
   */Range.prototype.clone=function(){return new Range(this.start,this.end,this.step)},/**
   * Retrieve the size of the range.
   * Returns an array containing one number, the number of elements in the range.
   * @memberof Range
   * @returns {number[]} size
   */Range.prototype.size=function(){var e=0,t=this.start,r=this.step,n=this.end-t;return eg(r)===eg(n)?e=Math.ceil(n/r):0===n&&(e=0),isNaN(e)&&(e=0),[e]},/**
   * Calculate the minimum value in the range
   * @memberof Range
   * @return {number | undefined} min
   */Range.prototype.min=function(){var e=this.size()[0];return e>0?this.step>0?this.start:this.start+(e-1)*this.step:void 0},/**
   * Calculate the maximum value in the range
   * @memberof Range
   * @return {number | undefined} max
   */Range.prototype.max=function(){var e=this.size()[0];return e>0?this.step>0?this.start+(e-1)*this.step:this.start:void 0},/**
   * Execute a callback function for each value in the range.
   * @memberof Range
   * @param {function} callback   The callback method is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Range being traversed.
   */Range.prototype.forEach=function(e){var t=this.start,r=this.step,n=this.end,i=0;if(r>0)for(;t<n;)e(t,[i],this),t+=r,i++;else if(r<0)for(;t>n;)e(t,[i],this),t+=r,i++},/**
   * Execute a callback function for each value in the Range, and return the
   * results as an array
   * @memberof Range
   * @param {function} callback   The callback method is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @returns {Array} array
   */Range.prototype.map=function(e){var t=[];return this.forEach(function(r,n,i){t[n[0]]=e(r,n,i)}),t},/**
   * Create an Array with a copy of the Ranges data
   * @memberof Range
   * @returns {Array} array
   */Range.prototype.toArray=function(){var e=[];return this.forEach(function(t,r){e[r[0]]=t}),e},/**
   * Get the primitive value of the Range, a one dimensional array
   * @memberof Range
   * @returns {Array} array
   */Range.prototype.valueOf=function(){// TODO: implement a caching mechanism for range.valueOf()
return this.toArray()},/**
   * Get a string representation of the range, with optional formatting options.
   * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'
   * @memberof Range
   * @param {Object | number | function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */Range.prototype.format=function(e){var t=eD(this.start,e);return 1!==this.step&&(t+=":"+eD(this.step,e)),t+=":"+eD(this.end,e)},/**
   * Get a string representation of the range.
   * @memberof Range
   * @returns {string}
   */Range.prototype.toString=function(){return this.format()},/**
   * Get a JSON representation of the range
   * @memberof Range
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
   */Range.prototype.toJSON=function(){return{mathjs:"Range",start:this.start,end:this.end,step:this.step}},/**
   * Instantiate a Range from a JSON object
   * @memberof Range
   * @param {Object} json A JSON object structured as:
   *                      `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
   * @return {Range}
   */Range.fromJSON=function(e){return new Range(e.start,e.end,e.step)},Range)},{isClass:!0}),fe=ta("re",["typed"],e=>{var{typed:t}=e;/**
   * Get the real part of a complex number.
   * For a complex number `a + bi`, the function returns `a`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.re(x)
   *
   * Examples:
   *
   *    const a = math.complex(2, 3)
   *    math.re(a)                     // returns number 2
   *    math.im(a)                     // returns number 3
   *
   *    math.re(math.complex('-5.2i')) // returns number 0
   *    math.re(math.complex(2.4))     // returns number 2.4
   *
   * See also:
   *
   *    im, conj, abs, arg
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Array | Matrix} The real part of x
   */return t("re",{"number | BigNumber | Fraction":e=>e,Complex:e=>e.re,"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),ft=ta("replacer",[],()=>function(e,t){return(// the numeric values Infinitiy, -Infinity, and NaN cannot be serialized to JSON
    "number"==typeof t&&(!isFinite(t)||isNaN(t))?{mathjs:"number",value:String(t)}:t)}),fr="reshape",fn=ta(fr,["typed","isInteger","matrix"],e=>{var{typed:t,isInteger:r}=e;/**
   * Reshape a multi dimensional array to fit the specified dimensions
   *
   * Syntax:
   *
   *     math.reshape(x, sizes)
   *
   * Examples:
   *
   *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3])
   *     // returns Array  [[1, 2, 3], [4, 5, 6]]
   *
   *     math.reshape([[1, 2], [3, 4]], [1, 4])
   *     // returns Array  [[1, 2, 3, 4]]
   *
   *     math.reshape([[1, 2], [3, 4]], [4])
   *     // returns Array [1, 2, 3, 4]
   *
   *     const x = math.matrix([1, 2, 3, 4, 5, 6, 7, 8])
   *     math.reshape(x, [2, 2, 2])
   *     // returns Matrix [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
   *
   *    math.reshape([1, 2, 3, 4], [-1, 2])
   *    // returns Matrix [[1, 2], [3, 4]]
   *
   * See also:
   *
   *     size, squeeze, resize
   *
   * @param {Array | Matrix | *} x  Matrix to be reshaped
   * @param {number[]} sizes        One dimensional array with integral sizes for
   *                                each dimension. One -1 is allowed as wildcard,
   *                                which calculates this dimension automatically.
   *
   * @return {* | Array | Matrix}   A reshaped clone of matrix `x`
   *
   * @throws {TypeError}            If `sizes` does not contain solely integers
   * @throws {DimensionError}       If the product of the new dimension sizes does
   *                                not equal that of the old ones
   */return t(fr,{"Matrix, Array":function(e,t){return e.reshape(t,!0)},"Array, Array":function(e,t){return t.forEach(function(e){if(!r(e))throw TypeError("Invalid size for dimension: "+e)}),eQ(e,t)}})}),fi=ta("resize",["config","matrix"],e=>{var{config:t,matrix:r}=e;/**
   * Resize a matrix
   *
   * Syntax:
   *
   *     math.resize(x, size)
   *     math.resize(x, size, defaultValue)
   *
   * Examples:
   *
   *     math.resize([1, 2, 3, 4, 5], [3]) // returns Array  [1, 2, 3]
   *     math.resize([1, 2, 3], [5], 0)    // returns Array  [1, 2, 3, 0, 0]
   *     math.resize(2, [2, 3], 0)         // returns Matrix [[2, 0, 0], [0, 0, 0]]
   *     math.resize("hello", [8], "!")    // returns string 'hello!!!'
   *
   * See also:
   *
   *     size, squeeze, subset, reshape
   *
   * @param {Array | Matrix | *} x             Matrix to be resized
   * @param {Array | Matrix} size              One dimensional array with numbers
   * @param {number | string} [defaultValue=0] Zero by default, except in
   *                                           case of a string, in that case
   *                                           defaultValue = ' '
   * @return {* | Array | Matrix} A resized clone of matrix `x`
   */// TODO: rework resize to a typed-function
return function(e,n,i){if(2!=arguments.length&&3!=arguments.length)throw new uW("resize",arguments.length,2,3);// check x is a Matrix
if(g(n)&&(n=n.valueOf()),c(n[0])&&(n=n.map(function(e){return c(e)?e.toNumber():e})),g(e))return e.resize(n,i,!0);if("string"==typeof e)return(/**
   * Resize a string
   * @param {string} str
   * @param {number[]} size
   * @param {string} [defaultChar=' ']
   * @private
   */function(e,t,r){if(void 0!==r){if("string"!=typeof r||1!==r.length)throw TypeError("Single character expected as defaultValue")}else r=" ";if(1!==t.length)throw new eH(t.length,1);var n=t[0];if("number"!=typeof n||!eh(n))throw TypeError("Invalid size, must contain positive integers (size: "+eP(t)+")");if(e.length>n)return e.substring(0,n);if(!(e.length<n))return e;for(var i=e,a=0,o=n-e.length;a<o;a++)i+=r;return i}(e,n,i));// check result should be a matrix
var a=!Array.isArray(e)&&"Array"!==t.matrix;if(0===n.length){// output a scalar
for(;Array.isArray(e);)e=e[0];return J(e)}// output an array/matrix
Array.isArray(e)||(e=[e]);var o=eX(e=J(e),n,i);return a?r(o):o}}),fa=ta("ResultSet",[],()=>{/**
   * A ResultSet contains a list or results
   * @class ResultSet
   * @param {Array} entries
   * @constructor ResultSet
   */function e(t){if(!(this instanceof e))throw SyntaxError("Constructor must be called with the new operator");this.entries=t||[]}return(/**
   * Attach type information
   */e.prototype.type="ResultSet",e.prototype.isResultSet=!0,/**
   * Returns the array with results hold by this ResultSet
   * @memberof ResultSet
   * @returns {Array} entries
   */e.prototype.valueOf=function(){return this.entries},/**
   * Returns the stringified results of the ResultSet
   * @memberof ResultSet
   * @returns {string} string
   */e.prototype.toString=function(){return"["+this.entries.join(", ")+"]"},/**
   * Get a JSON representation of the ResultSet
   * @memberof ResultSet
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "ResultSet", "entries": [...]}`
   */e.prototype.toJSON=function(){return{mathjs:"ResultSet",entries:this.entries}},/**
   * Instantiate a ResultSet from a JSON object
   * @memberof ResultSet
   * @param {Object} json  A JSON object structured as:
   *                       `{"mathjs": "ResultSet", "entries": [...]}`
   * @return {ResultSet}
   */e.fromJSON=function(t){return new e(t.entries)},e)},{isClass:!0}),fo="rightArithShift",fs=ta(fo,["typed","matrix","equalScalar","zeros","DenseMatrix","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,zeros:i,DenseMatrix:a,concat:o}=e,s=iT({typed:t}),u=iU({typed:t,equalScalar:n}),l=lj({typed:t,equalScalar:n}),c=i_({typed:t,DenseMatrix:a}),f=iL({typed:t,equalScalar:n}),p=iq({typed:t}),m=iI({typed:t,matrix:r,concat:o}),d=lU({typed:t,matrix:r});/**
   * Bitwise right arithmetic shift of a value x by y number of bits, `x >> y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.rightArithShift(x, y)
   *
   * Examples:
   *
   *    math.rightArithShift(4, 2)               // returns number 1
   *
   *    math.rightArithShift([16, -32, 64], 4)   // returns Array [1, -2, 4]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitOr, bitXor, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x Value to be shifted
   * @param  {number | BigNumber} y Amount of shifts
   * @return {number | BigNumber | Array | Matrix} `x` zero-filled shifted right `y` times
   */return t(fo,{"number, number":oc,"BigNumber, BigNumber":on,"SparseMatrix, number | BigNumber":t.referToSelf(e=>(t,r)=>// check scalar
        n(r,0)?t.clone():f(t,r,e,!1)),"DenseMatrix, number | BigNumber":t.referToSelf(e=>(t,r)=>// check scalar
        n(r,0)?t.clone():p(t,r,e,!1)),"number | BigNumber, SparseMatrix":t.referToSelf(e=>(t,r)=>// check scalar
        n(t,0)?i(r.size(),r.storage()):c(r,t,e,!0)),"number | BigNumber, DenseMatrix":t.referToSelf(e=>(t,r)=>// check scalar
        n(t,0)?i(r.size(),r.storage()):p(r,t,e,!0))},d,m({SS:l,DS:s,SD:u}))}),fu="rightLogShift",fl=ta(fu,["typed","matrix","equalScalar","zeros","DenseMatrix","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,zeros:i,DenseMatrix:a,concat:o}=e,s=iT({typed:t}),u=iU({typed:t,equalScalar:n}),l=lj({typed:t,equalScalar:n}),c=i_({typed:t,DenseMatrix:a}),f=iL({typed:t,equalScalar:n}),p=iq({typed:t}),m=iI({typed:t,matrix:r,concat:o}),d=lU({typed:t,matrix:r});/**
   * Bitwise right logical shift of value x by y number of bits, `x >>> y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.rightLogShift(x, y)
   *
   * Examples:
   *
   *    math.rightLogShift(4, 2)               // returns number 1
   *
   *    math.rightLogShift([16, 32, 64], 4)    // returns Array [1, 2, 4]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitOr, bitXor, leftShift, rightLogShift
   *
   * @param  {number | Array | Matrix} x Value to be shifted
   * @param  {number} y Amount of shifts
   * @return {number | Array | Matrix} `x` zero-filled shifted right `y` times
   */return t(fu,{"number, number":of,// 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
"SparseMatrix, number | BigNumber":t.referToSelf(e=>(t,r)=>// check scalar
        n(r,0)?t.clone():f(t,r,e,!1)),"DenseMatrix, number | BigNumber":t.referToSelf(e=>(t,r)=>// check scalar
        n(r,0)?t.clone():p(t,r,e,!1)),"number | BigNumber, SparseMatrix":t.referToSelf(e=>(t,r)=>// check scalar
        n(t,0)?i(r.size(),r.storage()):c(r,t,e,!0)),"number | BigNumber, DenseMatrix":t.referToSelf(e=>(t,r)=>// check scalar
        n(t,0)?i(r.size(),r.storage()):p(r,t,e,!0))},d,m({SS:l,DS:s,SD:u}))}),fc="rotate",ff=ta(fc,["typed","multiply","rotationMatrix"],e=>{var{typed:t,multiply:r,rotationMatrix:n}=e;/**
     * Rotate a vector of size 1x2 counter-clockwise by a given angle
     * Rotate a vector of size 1x3 counter-clockwise by a given angle around the given axis
     *
     * Syntax:
     *
     *    math.rotate(w, theta)
     *    math.rotate(w, theta, v)
     *
     * Examples:
     *
     *    math.rotate([11, 12], math.pi / 2)                           // returns [-12, 11]
     *    math.rotate(matrix([11, 12]), math.pi / 2)                   // returns [-12, 11]
     *
     *    math.rotate([1, 0, 0], unit('90deg'), [0, 0, 1])             // returns [0, 1, 0]
     *    math.rotate(matrix([1, 0, 0]), unit('90deg'), [0, 0, 1])     // returns Matrix [0, 1, 0]
     *
     *    math.rotate([1, 0], math.complex(1 + i))                     // returns [cos(1 + i) - sin(1 + i), sin(1 + i) + cos(1 + i)]
     *
     * See also:
     *
     *    matrix, rotationMatrix
     *
     * @param {Array | Matrix} w                             Vector to rotate
     * @param {number | BigNumber | Complex | Unit} theta    Rotation angle
     * @param {Array | Matrix} [v]                           Rotation axis
     * @return {Array | Matrix}                              Multiplication of the rotation matrix and w
     */return t(fc,{"Array , number | BigNumber | Complex | Unit":function(e,t){return i(e,2),r(n(t),e).toArray()},"Matrix , number | BigNumber | Complex | Unit":function(e,t){return i(e,2),r(n(t),e)},"Array, number | BigNumber | Complex | Unit, Array | Matrix":function(e,t,a){return i(e,3),r(n(t,a),e)},"Matrix, number | BigNumber | Complex | Unit, Array | Matrix":function(e,t,a){return i(e,3),r(n(t,a),e)}});function i(e,t){var r=Array.isArray(e)?eG(e):e.size();if(r.length>2||2===r.length&&1!==r[1]||r[0]!==t)throw RangeError("Vector must be of dimensions 1x".concat(t))}}),fp="rotationMatrix",fm=ta(fp,["typed","config","multiplyScalar","addScalar","unaryMinus","norm","matrix","BigNumber","DenseMatrix","SparseMatrix","cos","sin"],e=>{var{typed:t,config:r,multiplyScalar:n,addScalar:i,unaryMinus:a,norm:o,BigNumber:s,matrix:u,DenseMatrix:l,SparseMatrix:f,cos:p,sin:m}=e;/**
   * Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians).
   * Create a 2-dimensional counter-clockwise rotation matrix (3x3) by a given angle (expressed in radians) around a given axis (1x3).
   *
   * Syntax:
   *
   *    math.rotationMatrix(theta)
   *    math.rotationMatrix(theta, format)
   *    math.rotationMatrix(theta, [v])
   *    math.rotationMatrix(theta, [v], format)
   *
   * Examples:
   *
   *    math.rotationMatrix(math.pi / 2)                      // returns [[0, -1], [1, 0]]
   *    math.rotationMatrix(math.bignumber(1))                // returns [[bignumber(cos(1)), bignumber(-sin(1))], [bignumber(sin(1)), bignumber(cos(1))]]
   *    math.rotationMatrix(math.complex(1 + i))              // returns [[cos(1 + i), -sin(1 + i)], [sin(1 + i), cos(1 + i)]]
   *    math.rotationMatrix(math.unit('1rad'))                // returns [[cos(1), -sin(1)], [sin(1), cos(1)]]
   *
   *    math.rotationMatrix(math.pi / 2, [0, 1, 0])           // returns [[0, 0, 1], [0, 1, 0], [-1, 0, 0]]
   *    math.rotationMatrix(math.pi / 2, matrix([0, 1, 0]))   // returns matrix([[0, 0, 1], [0, 1, 0], [-1, 0, 0]])
   *
   *
   * See also:
   *
   *    matrix, cos, sin
   *
   *
   * @param {number | BigNumber | Complex | Unit} theta    Rotation angle
   * @param {Array | Matrix} [v]                           Rotation axis
   * @param {string} [format]                              Result Matrix storage format
   * @return {Array | Matrix}                              Rotation matrix
   */return t(fp,{"":function(){return"Matrix"===r.matrix?u([]):[]},string:function(e){return u(e)},"number | BigNumber | Complex | Unit":function(e){return d(e,"Matrix"===r.matrix?"dense":void 0)},"number | BigNumber | Complex | Unit, string":function(e,t){return d(e,t)},"number | BigNumber | Complex | Unit, Array":function(e,t){var r=u(t);return h(r),v(e,r,void 0)},"number | BigNumber | Complex | Unit, Matrix":function(e,t){h(t);var n=t.storage()||("Matrix"===r.matrix?"dense":void 0);return v(e,t,n)},"number | BigNumber | Complex | Unit, Array, string":function(e,t,r){var n=u(t);return h(n),v(e,n,r)},"number | BigNumber | Complex | Unit, Matrix, string":function(e,t,r){return h(t),v(e,t,r)}});/**
   * Returns 2x2 matrix of 2D rotation of angle theta
   *
   * @param {number | BigNumber | Complex | Unit} theta  The rotation angle
   * @param {string} format                              The result Matrix storage format
   * @returns {Matrix}
   * @private
   */function d(e,t){var r=c(e)?new s(-1):-1,i=p(e),a=m(e);return y([[i,n(r,a)],[a,i]],t)}function h(e){var t=e.size();if(t.length<1||3!==t[0])throw RangeError("Vector must be of dimensions 1x3")}function g(e){return e.reduce((e,t)=>n(e,t))}function y(e,t){if(t){if("sparse"===t)return new f(e);if("dense"===t)return new l(e);throw TypeError('Unknown matrix type "'.concat(t,'"'))}return e}/**
   * Returns a 3x3 matrix of rotation of angle theta around vector v
   *
   * @param {number | BigNumber | Complex | Unit} theta The rotation angle
   * @param {Matrix} v                                  The rotation axis vector
   * @param {string} format                             The storage format of the resulting matrix
   * @returns {Matrix}
   * @private
   */function v(e,t,r){var n=o(t);if(0===n)throw RangeError("Rotation around zero vector");var u=c(e)?s:null,l=u?new u(1):1,f=u?new u(-1):-1,d=u?new u(t.get([0])/n):t.get([0])/n,h=u?new u(t.get([1])/n):t.get([1])/n,v=u?new u(t.get([2])/n):t.get([2])/n,x=p(e),b=i(l,a(x)),N=m(e);return y([[i(x,g([d,d,b])),i(g([d,h,b]),g([f,v,N])),i(g([d,v,b]),g([h,N]))],[i(g([d,h,b]),g([v,N])),i(x,g([h,h,b])),i(g([h,v,b]),g([f,d,N]))],[i(g([d,v,b]),g([f,h,N])),i(g([h,v,b]),g([d,N])),i(x,g([v,v,b]))]],r)}}),fd="Number of decimals in function round must be an integer",fh="round",fg=ta(fh,["typed","matrix","equalScalar","zeros","BigNumber","DenseMatrix"],e=>{var{typed:t,matrix:r,equalScalar:n,zeros:i,BigNumber:a,DenseMatrix:o}=e,s=iL({typed:t,equalScalar:n}),u=i6({typed:t,DenseMatrix:o}),l=iq({typed:t});/**
   * Round a value towards the nearest rounded value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.round(x)
   *    math.round(x, n)
   *    math.round(unit, valuelessUnit)
   *    math.round(unit, n, valuelessUnit)
   *
   * Examples:
   *
   *    math.round(3.22)             // returns number 3
   *    math.round(3.82)             // returns number 4
   *    math.round(-4.2)             // returns number -4
   *    math.round(-4.7)             // returns number -5
   *    math.round(3.22, 1)          // returns number 3.2
   *    math.round(3.88, 1)          // returns number 3.9
   *    math.round(-4.21, 1)         // returns number -4.2
   *    math.round(-4.71, 1)         // returns number -4.7
   *    math.round(math.pi, 3)       // returns number 3.142
   *    math.round(123.45678, 2)     // returns number 123.46
   *
   *    const c = math.complex(3.2, -2.7)
   *    math.round(c)                // returns Complex 3 - 3i
   *
   *    const unit = math.unit('3.241 cm')
   *    const cm = math.unit('cm')
   *    const mm = math.unit('mm')
   *    math.round(unit, 1, cm)      // returns Unit 3.2 cm
   *    math.round(unit, 1, mm)      // returns Unit 32.4 mm
   *
   *    math.round([3.2, 3.8, -4.7]) // returns Array [3, 4, -5]
   *
   * See also:
   *
   *    ceil, fix, floor
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x  Value to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @param  {Unit} [valuelessUnit]                                        A valueless unit
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
   */return t(fh,{number:ie,"number, number":ie,"number, BigNumber":function(e,t){if(!t.isInteger())throw TypeError(fd);return new a(e).toDecimalPlaces(t.toNumber())},Complex:function(e){return e.round()},"Complex, number":function(e,t){if(t%1)throw TypeError(fd);return e.round(t)},"Complex, BigNumber":function(e,t){if(!t.isInteger())throw TypeError(fd);var r=t.toNumber();return e.round(r)},BigNumber:function(e){return e.toDecimalPlaces(0)},"BigNumber, BigNumber":function(e,t){if(!t.isInteger())throw TypeError(fd);return e.toDecimalPlaces(t.toNumber())},Fraction:function(e){return e.round()},"Fraction, number":function(e,t){if(t%1)throw TypeError(fd);return e.round(t)},"Fraction, BigNumber":function(e,t){if(!t.isInteger())throw TypeError(fd);return e.round(t.toNumber())},"Unit, number, Unit":t.referToSelf(e=>function(t,r,n){var i=t.toNumeric(n);return n.multiply(e(i,r))}),"Unit, BigNumber, Unit":t.referToSelf(e=>(t,r,n)=>e(t,r.toNumber(),n)),"Unit, Unit":t.referToSelf(e=>(t,r)=>e(t,0,r)),"Array | Matrix, number, Unit":t.referToSelf(e=>(t,r,n)=>tq(t,t=>e(t,r,n),!0)),"Array | Matrix, BigNumber, Unit":t.referToSelf(e=>(t,r,n)=>e(t,r.toNumber(),n)),"Array | Matrix, Unit":t.referToSelf(e=>(t,r)=>e(t,0,r)),"Array | Matrix":t.referToSelf(e=>t=>tq(t,e,!0)),"SparseMatrix, number | BigNumber":t.referToSelf(e=>(t,r)=>s(t,r,e,!1)),"DenseMatrix, number | BigNumber":t.referToSelf(e=>(t,r)=>l(t,r,e,!1)),"Array, number | BigNumber":t.referToSelf(e=>(t,n)=>l(r(t),n,e,!1).valueOf()),"number | Complex | BigNumber | Fraction, SparseMatrix":t.referToSelf(e=>(t,r)=>// check scalar is zero
        n(t,0)?i(r.size(),r.storage()):u(r,t,e,!0)),"number | Complex | BigNumber | Fraction, DenseMatrix":t.referToSelf(e=>(t,r)=>// check scalar is zero
        n(t,0)?i(r.size(),r.storage()):l(r,t,e,!0)),"number | Complex | BigNumber | Fraction, Array":t.referToSelf(e=>(t,n)=>l(r(n),t,e,!0).valueOf())})}),fy="schur",fv=ta(fy,["typed","matrix","identity","multiply","qr","norm","subtract"],e=>{var{typed:t,matrix:r,identity:n,multiply:i,qr:a,norm:o,subtract:s}=e;/**
   *
   * Performs a real Schur decomposition of the real matrix A = UTU' where U is orthogonal
   * and T is upper quasi-triangular.
   * https://en.wikipedia.org/wiki/Schur_decomposition
   *
   * Syntax:
   *
   *     math.schur(A)
   *
   * Examples:
   *
   *     const A = [[1, 0], [-4, 3]]
   *     math.schur(A) // returns {T: [[3, 4], [0, 1]], R: [[0, 1], [-1, 0]]}
   *
   * See also:
   *
   *     sylvester, lyap, qr
   *
   * @param {Array | Matrix} A  Matrix A
   * @return {{U: Array | Matrix, T: Array | Matrix}} Object containing both matrix U and T of the Schur Decomposition A=UTU'
   */return t(fy,{Array:function(e){var t=u(r(e));return{U:t.U.valueOf(),T:t.T.valueOf()}},Matrix:function(e){return u(e)}});function u(e){var t,r=e.size()[0],u=e,l=n(r),c=0;do{t=u;var f=a(u),p=f.Q;if(u=i(f.R,p),l=i(l,p),c++>100)break}while(o(s(u,t))>1e-4)return{U:l,T:u}}}),fx=ta("sec",["typed","BigNumber"],e=>{var{typed:t,BigNumber:r}=e,n=o8({typed:t});/**
   * Calculate the secant of a value, defined as `sec(x) = 1/cos(x)`.
   *
   * To avoid confusion with the matrix secant, this function does not
   * apply to matrices.
   *
   * Syntax:
   *
   *    math.sec(x)
   *
   * Examples:
   *
   *    math.sec(2)      // returns number -2.4029979617223822
   *    1 / math.cos(2)  // returns number -2.4029979617223822
   *
   * See also:
   *
   *    cos, csc, cot
   *
   * @param {number | BigNumber | Complex | Unit} x  Function input
   * @return {number | BigNumber | Complex} Secant of x
   */return t("sec",{number:iv,Complex:e=>e.sec(),BigNumber:e=>new r(1).div(e.cos())},n)}),fb="sech",fN=ta(fb,["typed","BigNumber"],e=>{var{typed:t,BigNumber:r}=e;/**
   * Calculate the hyperbolic secant of a value,
   * defined as `sech(x) = 1 / cosh(x)`.
   *
   * To avoid confusion with the matrix hyperbolic secant, this function does
   * not apply to matrices.
   *
   * Syntax:
   *
   *    math.sech(x)
   *
   * Examples:
   *
   *    // sech(x) = 1/ cosh(x)
   *    math.sech(0.5)       // returns 0.886818883970074
   *    1 / math.cosh(0.5)   // returns 0.886818883970074
   *
   * See also:
   *
   *    cosh, csch, coth
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic secant of x
   */return t(fb,{number:ix,Complex:e=>e.sech(),BigNumber:e=>new r(1).div(e.cosh())})}),fw="setCartesian",fD=ta(fw,["typed","size","subset","compareNatural","Index","DenseMatrix"],e=>{var{typed:t,size:r,subset:n,compareNatural:i,Index:a,DenseMatrix:o}=e;/**
   * Create the cartesian product of two (multi)sets.
   * Multi-dimension arrays will be converted to single-dimension arrays
   * and the values will be sorted in ascending order before the operation.
   *
   * Syntax:
   *
   *    math.setCartesian(set1, set2)
   *
   * Examples:
   *
   *    math.setCartesian([1, 2], [3, 4])        // returns [[1, 3], [1, 4], [2, 3], [2, 4]]
   *    math.setCartesian([4, 3], [2, 1])        // returns [[3, 1], [3, 2], [4, 1], [4, 2]]
   *
   * See also:
   *
   *    setUnion, setIntersect, setDifference, setPowerset
   *
   * @param {Array | Matrix}    a1  A (multi)set
   * @param {Array | Matrix}    a2  A (multi)set
   * @return {Array | Matrix}    The cartesian product of two (multi)sets
   */return t(fw,{"Array | Matrix, Array | Matrix":function(e,t){var s=[];if(0!==n(r(e),new a(0))&&0!==n(r(t),new a(0))){// if any of them is empty, return empty
var u=e3(Array.isArray(e)?e:e.toArray()).sort(i),l=e3(Array.isArray(t)?t:t.toArray()).sort(i);s=[];for(var c=0;c<u.length;c++)for(var f=0;f<l.length;f++)s.push([u[c],l[f]])}return(// return an array, if both inputs were arrays
Array.isArray(e)&&Array.isArray(t)?s:new o(s))}})}),fE="setDifference",fA=ta(fE,["typed","size","subset","compareNatural","Index","DenseMatrix"],e=>{var{typed:t,size:r,subset:n,compareNatural:i,Index:a,DenseMatrix:o}=e;/**
   * Create the difference of two (multi)sets: every element of set1, that is not the element of set2.
   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
   *
   * Syntax:
   *
   *    math.setDifference(set1, set2)
   *
   * Examples:
   *
   *    math.setDifference([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2]
   *    math.setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2]
   *
   * See also:
   *
   *    setUnion, setIntersect, setSymDifference
   *
   * @param {Array | Matrix}    a1  A (multi)set
   * @param {Array | Matrix}    a2  A (multi)set
   * @return {Array | Matrix}    The difference of two (multi)sets
   */return t(fE,{"Array | Matrix, Array | Matrix":function(e,t){var s;if(0===n(r(e),new a(0)))s=[];else{if(0===n(r(t),new a(0)))return e3(e.toArray());var u,l=e9(e3(Array.isArray(e)?e:e.toArray()).sort(i)),c=e9(e3(Array.isArray(t)?t:t.toArray()).sort(i));s=[];for(var f=0;f<l.length;f++){u=!1;for(var p=0;p<c.length;p++)if(0===i(l[f].value,c[p].value)&&l[f].identifier===c[p].identifier){// the identifier is always a decimal int
u=!0;break}u||s.push(l[f])}}return(// return an array, if both inputs were arrays
Array.isArray(e)&&Array.isArray(t)?te(s):new o(te(s)))}})}),fS="setDistinct",fC=ta(fS,["typed","size","subset","compareNatural","Index","DenseMatrix"],e=>{var{typed:t,size:r,subset:n,compareNatural:i,Index:a,DenseMatrix:o}=e;/**
   * Collect the distinct elements of a multiset.
   * A multi-dimension array will be converted to a single-dimension array before the operation.
   *
   * Syntax:
   *
   *    math.setDistinct(set)
   *
   * Examples:
   *
   *    math.setDistinct([1, 1, 1, 2, 2, 3])        // returns [1, 2, 3]
   *
   * See also:
   *
   *    setMultiplicity
   *
   * @param {Array | Matrix}    a  A multiset
   * @return {Array | Matrix}    A set containing the distinc elements of the multiset
   */return t(fS,{"Array | Matrix":function(e){var t;if(0===n(r(e),new a(0)))t=[];else{var s=e3(Array.isArray(e)?e:e.toArray()).sort(i);(t=[]).push(s[0]);for(var u=1;u<s.length;u++)0!==i(s[u],s[u-1])&&t.push(s[u])}return(// return an array, if the input was an array
Array.isArray(e)?t:new o(t))}})}),fM="setIntersect",fF=ta(fM,["typed","size","subset","compareNatural","Index","DenseMatrix"],e=>{var{typed:t,size:r,subset:n,compareNatural:i,Index:a,DenseMatrix:o}=e;/**
   * Create the intersection of two (multi)sets.
   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
   *
   * Syntax:
   *
   *    math.setIntersect(set1, set2)
   *
   * Examples:
   *
   *    math.setIntersect([1, 2, 3, 4], [3, 4, 5, 6])            // returns [3, 4]
   *    math.setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [3, 4]
   *
   * See also:
   *
   *    setUnion, setDifference
   *
   * @param {Array | Matrix}    a1  A (multi)set
   * @param {Array | Matrix}    a2  A (multi)set
   * @return {Array | Matrix}    The intersection of two (multi)sets
   */return t(fM,{"Array | Matrix, Array | Matrix":function(e,t){var s;if(0===n(r(e),new a(0))||0===n(r(t),new a(0)))s=[];else{var u=e9(e3(Array.isArray(e)?e:e.toArray()).sort(i)),l=e9(e3(Array.isArray(t)?t:t.toArray()).sort(i));s=[];for(var c=0;c<u.length;c++)for(var f=0;f<l.length;f++)if(0===i(u[c].value,l[f].value)&&u[c].identifier===l[f].identifier){// the identifier is always a decimal int
s.push(u[c]);break}}return(// return an array, if both inputs were arrays
Array.isArray(e)&&Array.isArray(t)?te(s):new o(te(s)))}})}),fB="setIsSubset",fT=ta(fB,["typed","size","subset","compareNatural","Index"],e=>{var{typed:t,size:r,subset:n,compareNatural:i,Index:a}=e;/**
   * Check whether a (multi)set is a subset of another (multi)set. (Every element of set1 is the element of set2.)
   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
   *
   * Syntax:
   *
   *    math.setIsSubset(set1, set2)
   *
   * Examples:
   *
   *    math.setIsSubset([1, 2], [3, 4, 5, 6])        // returns false
   *    math.setIsSubset([3, 4], [3, 4, 5, 6])        // returns true
   *
   * See also:
   *
   *    setUnion, setIntersect, setDifference
   *
   * @param {Array | Matrix}    a1  A (multi)set
   * @param {Array | Matrix}    a2  A (multi)set
   * @return {boolean} Returns true when a1 is a subset of a2, returns false otherwise
   */return t(fB,{"Array | Matrix, Array | Matrix":function(e,t){if(0===n(r(e),new a(0)))return!0;if(0===n(r(t),new a(0)))return!1;for(var o,s=e9(e3(Array.isArray(e)?e:e.toArray()).sort(i)),u=e9(e3(Array.isArray(t)?t:t.toArray()).sort(i)),l=0;l<s.length;l++){o=!1;for(var c=0;c<u.length;c++)if(0===i(s[l].value,u[c].value)&&s[l].identifier===u[c].identifier){// the identifier is always a decimal int
o=!0;break}if(!1===o)return!1}return!0}})}),fO="setMultiplicity",f_=ta(fO,["typed","size","subset","compareNatural","Index"],e=>{var{typed:t,size:r,subset:n,compareNatural:i,Index:a}=e;/**
   * Count the multiplicity of an element in a multiset.
   * A multi-dimension array will be converted to a single-dimension array before the operation.
   *
   * Syntax:
   *
   *    math.setMultiplicity(element, set)
   *
   * Examples:
   *
   *    math.setMultiplicity(1, [1, 2, 2, 4])    // returns 1
   *    math.setMultiplicity(2, [1, 2, 2, 4])    // returns 2
   *
   * See also:
   *
   *    setDistinct, setSize
   *
   * @param {number | BigNumber | Fraction | Complex} e  An element in the multiset
   * @param {Array | Matrix}     a  A multiset
   * @return {number}            The number of how many times the multiset contains the element
   */return t(fO,{"number | BigNumber | Fraction | Complex, Array | Matrix":function(e,t){if(0===n(r(t),new a(0)))return 0;for(var o=e3(Array.isArray(t)?t:t.toArray()),s=0,u=0;u<o.length;u++)0===i(o[u],e)&&s++;return s}})}),fz="setPowerset",fq=ta(fz,["typed","size","subset","compareNatural","Index"],e=>{var{typed:t,size:r,subset:n,compareNatural:i,Index:a}=e;/**
   * Create the powerset of a (multi)set. (The powerset contains very possible subsets of a (multi)set.)
   * A multi-dimension array will be converted to a single-dimension array before the operation.
   *
   * Syntax:
   *
   *    math.setPowerset(set)
   *
   * Examples:
   *
   *    math.setPowerset([1, 2, 3])        // returns [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]
   *
   * See also:
   *
   *    setCartesian
   *
   * @param {Array | Matrix}    a  A (multi)set
   * @return {Array}    The powerset of the (multi)set
   */return t(fz,{"Array | Matrix":function(e){if(0===n(r(e),new a(0)))return[];for(var t=e3(Array.isArray(e)?e:e.toArray()).sort(i),o=[],s=0;s.toString(2).length<=t.length;)o.push(// create subset
function(e,t){for(var r=[],n=0;n<t.length;n++)"1"===t[n]&&r.push(e[n]);return r}(t,s.toString(2).split("").reverse())),s++;// can not return a matrix, because of the different size of the subarrays
return(// sort subsests by length
function(e){for(var t=[],r=e.length-1;r>0;r--)for(var n=0;n<r;n++)e[n].length>e[n+1].length&&(t=e[n],e[n]=e[n+1],e[n+1]=t);return e}(o))}})}),fk="setSize",fI=ta(fk,["typed","compareNatural"],e=>{var{typed:t,compareNatural:r}=e;/**
   * Count the number of elements of a (multi)set. When a second parameter is 'true', count only the unique values.
   * A multi-dimension array will be converted to a single-dimension array before the operation.
   *
   * Syntax:
   *
   *    math.setSize(set)
   *    math.setSize(set, unique)
   *
   * Examples:
   *
   *    math.setSize([1, 2, 2, 4])          // returns 4
   *    math.setSize([1, 2, 2, 4], true)    // returns 3
   *
   * See also:
   *
   *    setUnion, setIntersect, setDifference
   *
   * @param {Array | Matrix} a  A multiset
   * @param {boolean} [unique]  If true, only the unique values are counted. False by default
   * @return {number}           The number of elements of the (multi)set
   */return t(fk,{"Array | Matrix":function(e){return Array.isArray(e)?e3(e).length:e3(e.toArray()).length},"Array | Matrix, boolean":function(e,t){if(!1===t||0===e.length)return Array.isArray(e)?e3(e).length:e3(e.toArray()).length;for(var n=e3(Array.isArray(e)?e:e.toArray()).sort(r),i=1,a=1;a<n.length;a++)0!==r(n[a],n[a-1])&&i++;return i}})}),fR="setSymDifference",fP=ta(fR,["typed","size","concat","subset","setDifference","Index"],e=>{var{typed:t,size:r,concat:n,subset:i,setDifference:a,Index:o}=e;/**
   * Create the symmetric difference of two (multi)sets.
   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
   *
   * Syntax:
   *
   *    math.setSymDifference(set1, set2)
   *
   * Examples:
   *
   *    math.setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2, 5, 6]
   *    math.setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2, 5, 6]
   *
   * See also:
   *
   *    setUnion, setIntersect, setDifference
   *
   * @param {Array | Matrix}    a1  A (multi)set
   * @param {Array | Matrix}    a2  A (multi)set
   * @return {Array | Matrix}    The symmetric difference of two (multi)sets
   */return t(fR,{"Array | Matrix, Array | Matrix":function(e,t){if(0===i(r(e),new o(0)))return e3(t);if(0===i(r(t),new o(0)))return e3(e);var s=e3(e),u=e3(t);return n(a(s,u),a(u,s))}})}),fj="setUnion",fU=ta(fj,["typed","size","concat","subset","setIntersect","setSymDifference","Index"],e=>{var{typed:t,size:r,concat:n,subset:i,setIntersect:a,setSymDifference:o,Index:s}=e;/**
   * Create the union of two (multi)sets.
   * Multi-dimension arrays will be converted to single-dimension arrays before the operation.
   *
   * Syntax:
   *
   *    math.setUnion(set1, set2)
   *
   * Examples:
   *
   *    math.setUnion([1, 2, 3, 4], [3, 4, 5, 6])            // returns [1, 2, 3, 4, 5, 6]
   *    math.setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])    // returns [1, 2, 3, 4, 5, 6]
   *
   * See also:
   *
   *    setIntersect, setDifference
   *
   * @param {Array | Matrix}    a1  A (multi)set
   * @param {Array | Matrix}    a2  A (multi)set
   * @return {Array | Matrix}    The union of two (multi)sets
   */return t(fj,{"Array | Matrix, Array | Matrix":function(e,t){if(0===i(r(e),new s(0)))return e3(t);if(0===i(r(t),new s(0)))return e3(e);var u=e3(e),l=e3(t);return n(o(u,l),a(u,l))}})}),fL="sign",f$=ta(fL,["typed","BigNumber","Fraction","complex"],e=>{var{typed:t,BigNumber:r,complex:n,Fraction:i}=e;/**
   * Compute the sign of a value. The sign of a value x is:
   *
   * -  1 when x > 0
   * - -1 when x < 0
   * -  0 when x == 0
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sign(x)
   *
   * Examples:
   *
   *    math.sign(3.5)               // returns 1
   *    math.sign(-4.2)              // returns -1
   *    math.sign(0)                 // returns 0
   *
   *    math.sign([3, 5, -2, 0, 2])  // returns [1, 1, -1, 0, 1]
   *
   * See also:
   *
   *    abs
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
   *            The number for which to determine the sign
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
   *            The sign of `x`
   */return t(fL,{number:n8,Complex:function(e){return 0===e.im?n(n8(e.re)):e.sign()},BigNumber:function(e){return new r(e.cmp(0))},Fraction:function(e){return new i(e.s,1)},// deep map collection, skip zeros since sign(0) = 0
"Array | Matrix":t.referToSelf(e=>t=>tq(t,e,!0)),Unit:t.referToSelf(e=>r=>{if(!r._isDerived()&&0!==r.units[0].unit.offset)throw TypeError("sign is ambiguous for units with offset");return t.find(e,r.valueType())(r.value)})})}),fH=ta("sin",["typed"],e=>{var{typed:t}=e,r=o8({typed:t});/**
   * Calculate the sine of a value.
   *
   * To avoid confusion with the matrix sine, this function does not apply
   * to matrices.
   *
   * Syntax:
   *
   *    math.sin(x)
   *
   * Examples:
   *
   *    math.sin(2)                      // returns number 0.9092974268256813
   *    math.sin(math.pi / 4)            // returns number 0.7071067811865475
   *    math.sin(math.unit(90, 'deg'))   // returns number 1
   *    math.sin(math.unit(30, 'deg'))   // returns number 0.5
   *
   *    const angle = 0.2
   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number ~1
   *
   * See also:
   *
   *    cos, tan
   *
   * @param {number | BigNumber | Complex | Unit} x  Function input
   * @return {number | BigNumber | Complex} Sine of x
   */return t("sin",{number:Math.sin,"Complex | BigNumber":e=>e.sin()},r)}),fZ="sinh",fG=ta(fZ,["typed"],e=>{var{typed:t}=e;/**
   * Calculate the hyperbolic sine of a value,
   * defined as `sinh(x) = 1/2 * (exp(x) - exp(-x))`.
   *
   * To avoid confusion with the matrix hyperbolic sine, this function does
   * not apply to matrices.
   *
   * Syntax:
   *
   *    math.sinh(x)
   *
   * Examples:
   *
   *    math.sinh(0.5)       // returns number 0.5210953054937474
   *
   * See also:
   *
   *    cosh, tanh
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic sine of x
   */return t(fZ,{number:ib,"Complex | BigNumber":e=>e.sinh()})}),fV="size",fW=ta(fV,["typed","config","?matrix"],e=>{var{typed:t,config:r,matrix:n}=e;/**
   * Calculate the size of a matrix or scalar.
   *
   * Syntax:
   *
   *     math.size(x)
   *
   * Examples:
   *
   *     math.size(2.3)                  // returns []
   *     math.size('hello world')        // returns [11]
   *
   *     const A = [[1, 2, 3], [4, 5, 6]]
   *     math.size(A)                    // returns [2, 3]
   *     math.size(math.range(1,6))      // returns [5]
   *
   * See also:
   *
   *     count, resize, squeeze, subset
   *
   * @param {boolean | number | Complex | Unit | string | Array | Matrix} x  A matrix
   * @return {Array | Matrix} A vector with size of `x`.
   */return t(fV,{Matrix:function(e){return e.create(e.size())},Array:eG,string:function(e){return"Array"===r.matrix?[e.length]:n([e.length])},"number | Complex | BigNumber | Unit | boolean | null":function(e){// scalar
return"Array"===r.matrix?[]:n?n([]):no()}})});/**
 * Depth-first search and postorder of a tree rooted at node j
 *
 * @param {Number}  j               The tree node
 * @param {Number}  k
 * @param {Array}   w               The workspace array
 * @param {Number}  head            The index offset within the workspace for the head array
 * @param {Number}  next            The index offset within the workspace for the next array
 * @param {Array}   post            The post ordering array
 * @param {Number}  stack           The index offset within the workspace for the stack array
 *
 * Reference: http://faculty.cse.tamu.edu/davis/publications.html
 */function fY(e,t,r,n,i,a,o){// variables
var s=0;// while (stack is not empty)
for(// place j on the stack
r[o]=e;s>=0;){// p = top of stack
var u=r[o+s],l=r[n+u];-1===l?(// p has no unordered children left
s--,// node p is the kth postordered node
a[t++]=u):(// remove i from children of p
r[n+u]=r[i+l],// start dfs on child node i
r[o+ ++s]=l)}return t}var fJ=ta("csAmd",["add","multiply","transpose"],e=>{var{add:t,multiply:r,transpose:n}=e;/**
   * Approximate minimum degree ordering. The minimum degree algorithm is a widely used
   * heuristic for finding a permutation P so that P*A*P' has fewer nonzeros in its factorization
   * than A. It is a gready method that selects the sparsest pivot row and column during the course
   * of a right looking sparse Cholesky factorization.
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   *
   * @param {Number} order    0: Natural, 1: Cholesky, 2: LU, 3: QR
   * @param {Matrix} m        Sparse Matrix
   */return function(e,o){// check input parameters
if(!o||e<=0||e>3)return null;// a matrix arrays
var s,u,l,c,f,p,m,d,h,g,y,v,x,b,N,w,D=o._size,E=D[0],A=D[1],S=0,C=Math.max(16,10*Math.sqrt(A));C=Math.min(A-2,C);// create target matrix C
var M=/**
   * Creates the matrix that will be used by the approximate minimum degree ordering algorithm. The function accepts the matrix M as input and returns a permutation
   * vector P. The amd algorithm operates on a symmetrix matrix, so one of three symmetric matrices is formed.
   *
   * Order: 0
   *   A natural ordering P=null matrix is returned.
   *
   * Order: 1
   *   Matrix must be square. This is appropriate for a Cholesky or LU factorization.
   *   P = M + M'
   *
   * Order: 2
   *   Dense columns from M' are dropped, M recreated from M'. This is appropriatefor LU factorization of unsymmetric matrices.
   *   P = M' * M
   *
   * Order: 3
   *   This is best used for QR factorization or LU factorization is matrix M has no dense rows. A dense row is a row with more than 10*sqr(columns) entries.
   *   P = M' * M
   */function(e,i,a,o,s){// compute A'
var u=n(i);// check order = 1, matrix must be square
if(1===e&&o===a)return t(i,u);// check order = 2, drop dense columns from M'
if(2===e){// loop A' columns (rows)
for(var l=u._index,c=u._ptr,f=0,p=0;p<a;p++){// column j of AT starts here
var m=c[p];// skip dense col j
if(// new column j starts here
c[p]=f,!(c[p+1]-m>s))// map rows in column j of A
for(var d=c[p+1];m<d;m++)l[f++]=l[m]}// finalize AT
c[a]=f,// recreate A from new transpose matrix
i=n(u)}// use A' * A, square or rectangular matrix
return r(u,i)}(e,o,E,A,C);!/**
 * Keeps entries in the matrix when the callback function returns true, removes the entry otherwise
 *
 * @param {Matrix}   a              The sparse matrix
 * @param {function} callback       The callback function, function will be invoked with the following args:
 *                                    - The entry row
 *                                    - The entry column
 *                                    - The entry value
 *                                    - The state parameter
 * @param {any}      other          The state
 *
 * @return                          The number of nonzero elements in the matrix
 *
 * Reference: http://faculty.cse.tamu.edu/davis/publications.html
 */function(e,t,r){// loop columns
for(var n=e._values,i=e._index,a=e._ptr,o=e._size[1],s=0,u=0;u<o;u++){// get current location of col j
var l=a[u];for(// record new location of col j
a[u]=s;l<a[u+1];l++)t(i[l],u,n?n[l]:1,null)&&(// keep A(i,j)
i[s]=i[l],n&&(n[s]=n[l]),// increment nonzero items
s++)}// return number of nonzero items
// finalize A
a[o]=s,// trim arrays
i.splice(s,i.length-s),n&&n.splice(s,n.length-s)}(M,a,0);// while (selecting pivots) do
for(// C matrix arrays
var F=M._index,B=M._ptr,T=B[A],O=[],_=[],z=A+1,q=2*(A+1),k=3*(A+1),I=4*(A+1),R=5*(A+1),P=6*(A+1),j=7*(A+1),U=/**
   * Initialize quotient graph. There are four kind of nodes and elements that must be represented:
   *
   *  - A live node is a node i (or a supernode) that has not been selected as a pivot nad has not been merged into another supernode.
   *  - A dead node i is one that has been removed from the graph, having been absorved into r = flip(ptr[i]).
   *  - A live element e is one that is in the graph, having been formed when node e was selected as the pivot.
   *  - A dead element e is one that has benn absorved into a subsequent element s = flip(ptr[e]).
   */function(e,t,r,n,a,o,s,u,l,c,f,p){// Initialize quotient graph
for(var m=0;m<e;m++)r[n+m]=t[m+1]-t[m];r[n+e]=0;// initialize workspace
for(var d=0;d<=e;d++)// degree list i is empty
r[a+d]=-1,o[d]=-1,r[s+d]=-1,// hash list i is empty
r[u+d]=-1,// node i is just one node
r[l+d]=1,// node i is alive
r[c+d]=1,// Ek of node i is empty
r[f+d]=0,// degree of node i
r[p+d]=r[n+d];// clear w
var h=i(0,0,r,c,e);// return mark
return(// n is a dead element
r[f+e]=-2,// n is a root of assembly tree
t[e]=-1,// n is a dead element
r[c+e]=0,h)}(A,B,_,0,k,O,q,j,z,P,I,R),L=/**
   * Initialize degree lists. Each node is placed in its degree lists. Nodes of zero degree are eliminated immediately. Nodes with
   * degree >= dense are alsol eliminated and merged into a placeholder node n, a dead element. Thes nodes will appera last in the
   * output permutation p.
   */function(e,t,r,n,i,a,o,s,u,l,c){// loop columns
for(var f=0,p=0;p<e;p++){// degree @ i
var m=r[n+p];// check node i is empty
if(0===m)// element i is dead
r[i+p]=-2,f++,// i is a root of assembly tree
t[p]=-1,r[a+p]=0;else if(m>o)// absorb i into element n
r[s+p]=0,// node i is dead
r[i+p]=-1,f++,t[p]=-e-2,r[s+e]++;else{var d=r[u+m];-1!==d&&(l[d]=p),// put node i in degree list d
r[c+p]=r[u+m],r[u+m]=p}}return f}(A,B,_,R,I,P,C,z,k,O,q),$=0;L<A;){// select node of minimum approximate degree. amd() is now ready to start eliminating the graph. It first
// finds a node k of minimum degree and removes it from its degree list. The variable nel keeps track of thow
// many nodes have been eliminated.
for(l=-1;$<A&&-1===(l=_[k+$]);$++);-1!==_[q+l]&&(O[_[q+l]]=-1),// remove k from degree list
_[k+$]=_[q+l];// elenk = |Ek|
var H=_[I+l],Z=_[z+l];// W[nv + k] nodes of A eliminated
L+=Z;// Construct a new element. The new element Lk is constructed in place if |Ek| = 0. nv[i] is
// negated for all nodes i in Lk to flag them as members of this set. Each node i is removed from the
// degree lists. All elements e in Ek are absorved into element k.
var G=0;// flag k as in Lk
_[z+l]=-Z;var V=B[l],W=0===H?V:T,Y=W;for(c=1;c<=H+1;c++){for(c>H?(// search the nodes in k
p=l,// list of nodes starts at cindex[pj]
m=V,// length of list of nodes in k
d=_[0+l]-H):(m=B[// search the nodes in e
p=F[V++]],// length of list of nodes in e
d=_[0+p]),f=1;f<=d;f++)// check  node i dead, or seen
(h=_[z+(s=F[m++])])<=0||(// W[degree + Lk] += size of node i
G+=h,// negate W[nv + i] to denote i in Lk
_[z+s]=-h,// place i in Lk
F[Y++]=s,-1!==_[q+s]&&(O[_[q+s]]=O[s]),-1!==O[s]?_[q+O[s]]=_[q+s]:_[k+_[R+s]]=_[q+s]);p!==l&&(// absorb e into k
B[p]=-l-2,// e is now a dead element
_[P+p]=0)}// scan 1: find |Le\Lk|
for(0!==H&&(T=Y),// external degree of k - |Lk\i|
_[R+l]=G,// element k is in cindex[pk1..pk2-1]
B[l]=W,_[0+l]=Y-W,// k is now an element
_[I+l]=-2,// Find set differences. The scan1 function now computes the set differences |Le \ Lk| for all elements e. At the start of the
// scan, no entry in the w array is greater than or equal to mark.
// clear w if necessary
U=i(U,S,_,P,A),g=W;g<Y;g++)// check if W[elen + i] empty, skip it
if(!((y=_[I+(s=F[g])])<=0)){var J=U-// W[nv + i] was negated
(h=-_[z+s]);// scan Ei
for(V=B[s],v=B[s]+y-1;V<=v;V++)_[P+(p=F[V])]>=U?_[P+p]-=h:0!==_[P+p]&&(_[P+p]=_[R+p]+J)}// degree update
// The second pass computes the approximate degree di, prunes the sets Ei and Ai, and computes a hash
// function h(i) for all nodes in Lk.
// scan2: degree update
for(g=W;g<Y;g++){// scan Ei
for(N=0,x=(v=B[// consider node i in Lk
s=F[g]])+_[I+s]-1,b=v,w=0,V=v;V<=x;V++)// check e is an unabsorbed element
if(0!==_[P+(p=F[V])]){// dext = |Le\Lk|
var X=_[P+p]-U;X>0?(// sum up the set differences
w+=X,// keep e in Ei
F[b++]=p,// compute the hash of node i
N+=p):(// aggressive absorb. e->k
B[p]=-l-2,// e is a dead element
_[P+p]=0)}// W[elen + i] = |Ei|
_[I+s]=b-v+1;var Q=b,K=v+_[0+s];// prune edges in Ai
for(V=x+1;V<K;V++){// check node j dead or in Lk
var ee=_[z+(u=F[V])];ee<=0||(// degree(i) += |j|
w+=ee,// place j in node list of i
F[b++]=u,// compute hash for node i
N+=u)}// check for mass elimination
0===w?(// absorb i into k
B[s]=-l-2,// |Lk| -= |i|
G-=h=-_[z+s],// |k| += W[nv + i]
Z+=h,L+=h,_[z+s]=0,// node i is dead
_[I+s]=-1):(// update degree(i)
_[R+s]=Math.min(_[R+s],w),// move first node to end
F[b]=F[Q],// move 1st el. to end of Ei
F[Q]=F[v],// add k as 1st element in of Ei
F[v]=l,// new len of adj. list of node i
_[0+s]=b-v+1,// finalize hash of i
N=(N<0?-N:N)%A,// place i in hash bucket
_[q+s]=_[j+N],_[j+N]=s,// save hash of i in last[i]
O[s]=N)}// Supernode detection. Supernode detection relies on the hash function h(i) computed for each node i.
// If two nodes have identical adjacency lists, their hash functions wil be identical.
for(// finalize |Lk|
_[R+l]=G,// clear w
U=i(U+(S=Math.max(S,G)),S,_,P,A),g=W;g<Y;g++)// check i is dead, skip it
if(!(_[z+(s=F[g])]>=0))for(s=_[j+// scan hash bucket of node i
(N=O[s])],// hash bucket will be empty
_[j+N]=-1;-1!==s&&-1!==_[q+s];s=_[q+s],U++){for(d=_[0+s],y=_[I+s],V=B[s]+1;V<=B[s]+d-1;V++)_[P+F[V]]=U;var et=s;// compare i with all j
for(u=_[q+s];-1!==u;){var er=_[0+u]===d&&_[I+u]===y;for(V=B[u]+1;er&&V<=B[u]+d-1;V++)_[P+F[V]]!==U&&(er=0);// check i and j are identical
er?(// absorb j into i
B[u]=-s-2,_[z+s]+=_[z+u],_[z+u]=0,// node j is dead
_[I+u]=-1,// delete j from hash bucket
u=_[q+u],_[q+et]=u):(// j and i are different
et=u,u=_[q+u])}}// Finalize new element. The elimination of node k is nearly complete. All nodes i in Lk are scanned one last time.
// Node i is removed from Lk if it is dead. The flagged status of nv[i] is cleared.
for(V=W,g=W;g<Y;g++)// check  i is dead, skip it
(h=-_[z+(s=F[g])])<=0||(// restore W[nv + i]
_[z+s]=h,w=Math.min(// compute external degree(i)
w=_[R+s]+G-h,A-L-h),-1!==_[k+w]&&(O[_[k+w]]=s),// put i back in degree list
_[q+s]=_[k+w],O[s]=-1,_[k+w]=s,// find new minimum degree
$=Math.min($,w),_[R+s]=w,// place i in Lk
F[V++]=s);// # nodes absorbed into k
_[z+l]=Z,0==(_[0+l]=V-W)&&(// k is a root of the tree
B[l]=-1,// k is now a dead element
_[P+l]=0),0!==H&&(T=V)}// Postordering. The elimination is complete, but no permutation has been computed. All that is left
// of the graph is the assembly tree (ptr) and a set of dead nodes and elements (i is a dead node if
// nv[i] is zero and a dead element if nv[i] > 0). It is from this information only that the final permutation
// is computed. The tree is restored by unflipping all of ptr.
// fix assembly tree
for(s=0;s<A;s++)B[s]=-B[s]-2;for(u=0;u<=A;u++)_[k+u]=-1;// place unordered nodes in lists
for(u=A;u>=0;u--)// skip if j is an element
_[z+u]>0||(// place j in list of its parent
_[q+u]=_[k+B[u]],_[k+B[u]]=u);// place elements in lists
for(p=A;p>=0;p--)// skip unless e is an element
_[z+p]<=0||-1===B[p]||(// place e in list of its parent
_[q+p]=_[k+B[p]],_[k+B[p]]=p);// postorder the assembly tree
for(l=0,s=0;s<=A;s++)-1===B[s]&&(l=fY(s,l,_,k,q,O,P));// return P
return(// remove last item in array
O.splice(O.length-1,1),O)};function i(e,t,r,n,i){if(e<2||e+t<0){for(var a=0;a<i;a++)0!==r[n+a]&&(r[n+a]=1);e=2}// at this point, W [0..n-1] < mark holds
return e}function a(e,t){return e!==t}}),fX=ta("csCounts",["transpose"],e=>{var{transpose:t}=e;/**
   * Computes the column counts using the upper triangular part of A.
   * It transposes A internally, none of the input parameters are modified.
   *
   * @param {Matrix} a           The sparse matrix A
   *
   * @param {Matrix} ata         Count the columns of A'A instead
   *
   * @return                     An array of size n of the column counts or null on error
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */return function(e,r,n,i){// check inputs
if(!e||!r||!n)return null;// a matrix arrays
var a,o,s,u,l,c,f,p=e._size,m=p[0],d=p[1],h=4*d+(i?d+m+1:0),g=[],y=2*d,v=3*d,x=4*d,b=5*d+1;// clear workspace w[0..s-1]
for(s=0;s<h;s++)g[s]=-1;// allocate result
var N=[],w=t(e),D=w._index,E=w._ptr;// (n)
// find w[first + j]
for(s=0;s<d;s++)for(// colcount[j]=1 if j is a leaf
N[o=n[s]]=-1===g[v+o]?1:0;-1!==o&&-1===g[v+o];o=r[o])g[v+o]=s;// initialize ata if needed
if(i){// invert post
for(s=0;s<d;s++)g[n[s]]=s;// loop rows (columns in AT)
for(a=0;a<m;a++){// values in column i of AT
for(s=d,c=E[a],f=E[a+1],l=c;l<f;l++)s=Math.min(s,g[D[l]]);// place row i in linked list k
g[b+a]=g[x+s],g[x+s]=a}}// each node in its own set
for(a=0;a<d;a++)g[0+a]=a;for(s=0;s<d;s++){// J=j for LL'=A case
for(-1!==r[// j is the kth node in postordered etree
o=n[s]]&&N[r[o]]--,u=i?g[x+s]:o;-1!==u;u=i?g[b+u]:-1)for(l=E[u];l<E[u+1];l++){var A=/**
 * This function determines if j is a leaf of the ith row subtree.
 * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)
 *
 * @param {Number}  i               The ith row subtree
 * @param {Number}  j               The node to test
 * @param {Array}   w               The workspace array
 * @param {Number}  first           The index offset within the workspace for the first array
 * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array
 * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array
 * @param {Number}  ancestor        The index offset within the workspace for the ancestor array
 *
 * @return {Object}
 *
 * Reference: http://faculty.cse.tamu.edu/davis/publications.html
 */function(e,t,r,n,i,a,o){// our result
var s,u,l,c=0;// check j is a leaf
if(e<=t||r[n+t]<=r[i+e])return -1;// update max first[j] seen so far
r[i+e]=r[n+t];// jprev = previous leaf of ith subtree
var f=r[a+e];// check j is first or subsequent leaf
if(r[a+e]=t,-1===f)// 1st leaf, q = root of ith subtree
c=1,l=e;else{// q = least common ancester (jprev,j)
for(// update jleaf
c=2,l=f;l!==r[o+l];l=r[o+l]);for(s=f;s!==l;s=u)// path compression
u=r[o+s],r[o+s]=l}return{jleaf:c,q:l}}(a=D[l],o,g,v,d,y,0);A.jleaf>=1&&N[o]++,2===A.jleaf&&N[A.q]--}-1!==r[o]&&(g[0+o]=r[o])}// sum up colcount's of each child
for(o=0;o<d;o++)-1!==r[o]&&(N[r[o]]+=N[o]);return N}}),fQ=ta("csSqr",["add","multiply","transpose"],e=>{var{add:t,multiply:r,transpose:n}=e,i=fJ({add:t,multiply:r,transpose:n}),a=fX({transpose:n});/**
   * Symbolic ordering and analysis for QR and LU decompositions.
   *
   * @param {Number}  order           The ordering strategy (see csAmd for more details)
   * @param {Matrix}  a               The A matrix
   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or
   *                                  symbolic ordering and analysis for LU decomposition (false)
   *
   * @return {Object}                 The Symbolic ordering and analysis for matrix A
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */return function(e,t,r){// a arrays
var n,o=t._ptr,s=t._size[1],u={};// validate results
if(// fill-reducing ordering
u.q=i(e,t),e&&!u.q)return null;// QR symbolic analysis
if(r){// apply permutations if needed
var l=e?/**
 * Permutes a sparse matrix C = P * A * Q
 *
 * @param {SparseMatrix}  a         The Matrix A
 * @param {Array}   pinv            The row permutation vector
 * @param {Array}   q               The column permutation vector
 * @param {boolean} values          Create a pattern matrix (false), values and pattern otherwise
 *
 * @return {Matrix}                 C = P * A * Q, null on error
 *
 * Reference: http://faculty.cse.tamu.edu/davis/publications.html
 */function(e,t,r,n){e._values;// loop columns
for(var i=e._index,a=e._ptr,o=e._size,s=e._datatype,u=o[0],l=o[1],c=[],f=[],p=0,m=0;m<l;m++){// column k of C is column q[k] of A
f[m]=p;// loop values in column j of A
for(var d=r?r[m]:m,h=a[d],g=a[d+1],y=h;y<g;y++){// row i of A is row pinv[i] of C
var v=t?t[i[y]]:i[y];// index
c[p]=v,// increment number of nonzero elements
p++}}// return C matrix
return(// finalize the last column of C
f[l]=p,e.createSparseMatrix({values:null,index:c,ptr:f,size:[u,l],datatype:s}))}(t,null,u.q,0):t;// etree of C'*C, where C=A(:,q)
u.parent=/**
 * Computes the elimination tree of Matrix A (using triu(A)) or the
 * elimination tree of A'A without forming A'A.
 *
 * @param {Matrix}  a               The A Matrix
 * @param {boolean} ata             A value of true the function computes the etree of A'A
 *
 * Reference: http://faculty.cse.tamu.edu/davis/publications.html
 */function(e,t){// check inputs
if(!e)return null;// a arrays
var r,n,i=e._index,a=e._ptr,o=e._size,s=o[0],u=o[1],l=[],c=[];// check we are calculating A'A
if(t)for(r=0;r<s;r++)c[u+r]=-1;// loop columns
for(var f=0;f<u;f++){// node k has no parent yet
l[f]=-1,// nor does k have an ancestor
c[0+f]=-1;// values in column k
for(var p=a[f],m=a[f+1],d=p;d<m;d++){// row
var h=i[d];// traverse from i to k
for(// node
r=t?c[u+h]:h;-1!==r&&r<f;r=n)// inext = ancestor of i
n=c[0+r],// path compression
c[0+r]=f,-1===n&&(l[r]=f);t&&(c[u+h]=f)}}return l}(l,1);// post order elimination tree
var c=function(e,t){// check inputs
if(!e)return null;// vars
var r,n=0,i=[],a=[],o=2*t;// initialize workspace
for(r=0;r<t;r++)a[0+r]=-1;// traverse nodes in reverse order
for(r=t-1;r>=0;r--)// check j is a root
-1!==e[r]&&(// add j to list of its parent
a[t+r]=a[0+e[r]],a[0+e[r]]=r);// loop nodes
for(r=0;r<t;r++)// skip j if it is not a root
-1===e[r]&&// depth-first search
(n=fY(r,n,a,0,t,i,o));return i}(u.parent,s);// check we have everything needed to calculate number of nonzero elements
if(// col counts chol(C'*C)
u.cp=a(l,u.parent,c,1),l&&u.parent&&u.cp&&/**
   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent
   */function(e,t){// a arrays
var r,n,i,a,o,s=e._ptr,u=e._index,l=e._size,c=l[0],f=l[1];// initialize s arrays
t.pinv=[],t.leftmost=[];// vars
var p=t.parent,m=t.pinv,d=t.leftmost,h=[],g=c+f,y=c+2*f;// initialize w
for(n=0;n<f;n++)// queue k is empty
h[c+n]=-1,h[g+n]=-1,h[y+n]=0;// initialize row arrays
for(r=0;r<c;r++)d[r]=-1;// loop columns backwards
for(n=f-1;n>=0;n--)for(a=s[n],o=s[n+1],i=a;i<o;i++)d[u[i]]=n;// scan rows in reverse order
for(r=c-1;r>=0;r--)// row i is not yet ordered
m[r]=-1,-1!==(n=d[r])&&(0==h[y+n]++&&(h[g+n]=r),// put i at head of queue k
h[0+r]=h[c+n],h[c+n]=r);// find row permutation and nnz(V)
for(n=0,t.lnz=0,t.m2=c;n<f;n++)// skip if V(k+1:m,k) is empty
if(// remove row i from queue k
r=h[c+n],// count V(k,k) as nonzero
t.lnz++,r<0&&(r=t.m2++),// associate row i with V(:,k)
m[r]=n,!(--y[n]<=0)){// nque[k] is nnz (V(k+1:m,k))
t.lnz+=h[y+n];// move all rows to parent of k
var v=p[n];-1!==v&&(0===h[y+v]&&(h[g+v]=h[g+n]),h[0+h[g+n]]=h[c+v],h[c+v]=h[0+r],h[y+v]+=h[y+n])}for(r=0;r<c;r++)m[r]<0&&(m[r]=n++);return!0}(l,u))for(u.unz=0,n=0;n<s;n++)u.unz+=u.cp[n]}else // for LU factorization only, guess nnz(L) and nnz(U)
u.unz=4*o[s]+s,u.lnz=u.unz;// return result S
return u}});function fK(e,t){// mark w[j]
e[t]=-e[t]-2}function f0(e){// flip the value if it is negative
return e<0?-e-2:e}var f1=ta("csSpsolve",["divideScalar","multiply","subtract"],e=>{var{divideScalar:t,multiply:r,subtract:n}=e;/**
   * The function csSpsolve() computes the solution to G * x = bk, where bk is the
   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the
   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U
   * is upper triangular with the diagonal entry as the last entry in each column.
   *
   * @param {Matrix}  g               The G matrix
   * @param {Matrix}  b               The B matrix
   * @param {Number}  k               The kth column in B
   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n
   *                                  The first n entries is the nonzero pattern, the last n entries is the stack
   * @param {Array}   x               The soluton to the linear system G * x = b
   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b
   * @param {boolean} lo              The lower (true) upper triangular (false) flag
   *
   * @return {Number}                 The index for the nonzero pattern
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */return function(e,i,a,o,s,u,l){// g arrays
var c,f,p,m,d=e._values,h=e._index,g=e._ptr,y=e._size[1],v=i._values,x=i._index,b=i._ptr,N=function(e,t,r,n,i){// g arrays
var a,o,s,u=e._ptr,l=e._size,c=t._index,f=t._ptr,p=l[1],m=p;// loop column indeces in B
for(o=f[r],s=f[r+1],a=o;a<s;a++){// node i
var d=c[a];// check node i is marked
u[d]<0||(m=function(e,t,r,n,i){// g arrays
var a,o,s,u=t._index,l=t._ptr,c=t._size[1],f=0;// loop
for(// initialize the recursion stack
n[0]=e;f>=0;){// get j from the top of the recursion stack
e=n[f];// apply permutation vector
var p=i?i[e]:e;// check node j is marked
l[e]<0||(fK(l,e),// update stack (last n entries in xi)
n[c+f]=p<0?0:f0(l[p]));// node j done if no unvisited neighbors
var m=1;// examine all neighbors of j, stack (last n entries in xi)
for(o=n[c+f],s=p<0?0:f0(l[p+1]);o<s;o++)// check we have visited node i, skip it
if(!(l[// consider neighbor node i
a=u[o]]<0)){// pause depth-first search of node j, update stack (last n entries in xi)
n[c+f]=o,// start dfs at node i
n[++f]=a,// node j is not done
m=0;break}// check depth-first search at node j is done
m&&(// remove j from the recursion stack
f--,// and place in the output stack
n[--r]=e)}return r}(d,e,m,n,i))}// loop columns from top -> n - 1
for(a=m;a<p;a++)fK(u,n[a]);return m}(e,i,a,o,u);// clear x
for(c=N;c<y;c++)s[o[c]]=0;// scatter b
for(f=b[a],p=b[a+1],c=f;c<p;c++)s[x[c]]=v[c];// loop columns
for(var w=N;w<y;w++){// x array index for px
var D=o[w],E=u?u[D]:D;// check column J is empty
if(!(E<0))// loop
for(// column value indeces in G, p0 <= p < p1
f=g[E],p=g[E+1],// x(j) /= G(j,j)
s[D]=t(s[D],d[l?f:p-1]),// first entry L(j,j)
c=l?f+1:f,m=l?p:p-1;c<m;c++){// row
var A=h[c];// x(i) -= G(i,j) * x(j)
s[A]=n(s[A],r(d[c],s[D]))}}// return top of stack
return N}}),f2=ta("csLu",["abs","divideScalar","multiply","subtract","larger","largerEq","SparseMatrix"],e=>{var{abs:t,divideScalar:r,multiply:n,subtract:i,larger:a,largerEq:o,SparseMatrix:s}=e,u=f1({divideScalar:r,multiply:n,subtract:i});/**
   * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization
   * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L
   * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so
   * L * U = A(p, q), where p is the inverse of pinv.
   *
   * @param {Matrix}  m               The A Matrix to factorize
   * @param {Object}  s               The symbolic analysis from csSqr(). Provides the fill-reducing
   *                                  column ordering q
   * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)
   *
   * @return {Number}                 The numeric LU factorization of A or null
   *
   * Reference: http://faculty.cse.tamu.edu/davis/publications.html
   */return function(e,i,l){// validate input
if(!e)return null;// columns
var c,f,p,m=e._size[1],d=100,h=100;i&&(c=i.q,d=i.lnz||d,h=i.unz||h);// L arrays
var g=[],y=[],v=[],x=new s({values:g,index:y,ptr:v,size:[m,m]}),b=[],N=[],w=[],D=new s({values:b,index:N,ptr:w,size:[m,m]}),E=[],A=[],S=[];// (lnz)
// initialize variables
for(f=0;f<m;f++)// clear workspace
A[f]=0,// no rows pivotal yet
E[f]=-1,// no cols of L yet
v[f+1]=0;// reset number of nonzero elements in L and U
d=0,h=0;// compute L(:,k) and U(:,k)
for(var C=0;C<m;C++){// update ptr
v[C]=d,w[C]=h;// apply column permutations if needed
var M=c?c[C]:C,F=u(x,e,M,S,A,E,1),B=-1,T=-1;// loop xi[] from top -> n
for(p=F;p<m;p++)// check row i is not yet pivotal
if(E[// x[i] is nonzero
f=S[p]]<0){// absolute value of x[i]
var O=t(A[f]);// check absoulte value is greater than pivot value
a(O,T)&&(// largest pivot candidate so far
T=O,B=f)}else // x(i) is the entry U(pinv[i],k)
N[h]=E[f],b[h++]=A[f];// validate we found a valid pivot
if(-1===B||T<=0)return null;E[M]<0&&o(t(A[M]),n(T,l))&&(B=M);// the chosen pivot
var _=A[B];// L(k+1:n,k) = x / pivot
for(// last entry in U(:,k) is U(k,k)
N[h]=C,b[h++]=_,// ipiv is the kth pivot row
E[B]=C,// first entry in L(:,k) is L(k,k) = 1
y[d]=B,g[d++]=1,p=F;p<m;p++)E[// row
f=S[p]]<0&&(// save unpermuted row in L
y[d]=f,// scale pivot column
g[d++]=r(A[f],_)),// x[0..n-1] = 0 for next k
A[f]=0}// fix row indices of L for final pinv
for(p=0,// update ptr
v[m]=d,w[m]=h;p<d;p++)y[p]=E[y[p]];// return LU factor
return(// trim arrays
g.splice(d,g.length-d),y.splice(d,y.length-d),b.splice(h,b.length-h),N.splice(h,N.length-h),{L:x,U:D,pinv:E})}}),f3=ta("slu",["typed","abs","add","multiply","transpose","divideScalar","subtract","larger","largerEq","SparseMatrix"],e=>{var{typed:t,abs:r,add:n,multiply:i,transpose:a,divideScalar:o,subtract:s,larger:u,largerEq:l,SparseMatrix:c}=e,f=fQ({add:n,multiply:i,transpose:a}),p=f2({abs:r,divideScalar:o,multiply:i,subtract:s,larger:u,largerEq:l,SparseMatrix:c});/**
   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where
   *
   * `P * A * Q = L * U`
   *
   * Syntax:
   *
   *    math.slu(A, order, threshold)
   *
   * Examples:
   *
   *    const A = math.sparse([[4,3], [6, 3]])
   *    math.slu(A, 1, 0.001)
   *    // returns:
   *    // {
   *    //   L: [[1, 0], [1.5, 1]]
   *    //   U: [[4, 3], [0, -1.5]]
   *    //   p: [0, 1]
   *    //   q: [0, 1]
   *    // }
   *
   * See also:
   *
   *    lup, lsolve, usolve, lusolve
   *
   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.
   * @param {Number}       order          The Symbolic Ordering and Analysis order:
   *                                       0 - Natural ordering, no permutation vector q is returned
   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'
   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.
   *                                           This is appropriatefor LU factorization of unsymmetric matrices.
   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.
   *                                           A dense row is a row with more than 10*sqr(columns) entries.
   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)
   *
   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.
   */return t("slu",{"SparseMatrix, number, number":function(e,t,r){// verify order
if(!eh(t)||t<0||t>3)throw Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");// verify threshold
if(r<0||r>1)throw Error("Partial pivoting threshold must be a number from 0 to 1");// perform symbolic ordering and analysis
var n=f(t,e,!1),i=p(e,n,r);// return decomposition
return{L:i.L,U:i.U,p:i.pinv,q:n.q,toString:function(){return"L: "+this.L.toString()+"\nU: "+this.U.toString()+"\np: "+this.p.toString()+(this.q?"\nq: "+this.q.toString():"")+"\n"}}}})}),f4="smaller",f5=ta(f4,["typed","config","matrix","DenseMatrix","concat"],e=>{var{typed:t,config:r,matrix:n,DenseMatrix:i,concat:a}=e,o=i5({typed:t}),s=ov({typed:t,DenseMatrix:i}),u=i6({typed:t,DenseMatrix:i}),l=iI({typed:t,matrix:n,concat:a}),c=oL({typed:t});/**
   * Test whether value x is smaller than y.
   *
   * The function returns true when x is smaller than y and the relative
   * difference between x and y is smaller than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.smaller(x, y)
   *
   * Examples:
   *
   *    math.smaller(2, 3)            // returns true
   *    math.smaller(5, 2 * 2)        // returns false
   *
   *    const a = math.unit('5 cm')
   *    const b = math.unit('2 inch')
   *    math.smaller(a, b)            // returns true
   *
   * See also:
   *
   *    equal, unequal, smallerEq, smaller, smallerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
   */return t(f4,f8({typed:t,config:r}),{"boolean, boolean":(e,t)=>e<t,"BigNumber, BigNumber":function(e,t){return e.lt(t)&&!oC(e,t,r.epsilon)},"Fraction, Fraction":(e,t)=>-1===e.compare(t),"Complex, Complex":function(e,t){throw TypeError("No ordering relation is defined for complex numbers")}},c,l({SS:s,DS:o,Ss:u}))}),f8=ta(f4,["typed","config"],e=>{var{typed:t,config:r}=e;return t(f4,{"number, number":function(e,t){return e<t&&!eB(e,t,r.epsilon)}})}),f6="smallerEq",f7=ta(f6,["typed","config","matrix","DenseMatrix","concat"],e=>{var{typed:t,config:r,matrix:n,DenseMatrix:i,concat:a}=e,o=i5({typed:t}),s=ov({typed:t,DenseMatrix:i}),u=i6({typed:t,DenseMatrix:i}),l=iI({typed:t,matrix:n,concat:a}),c=oL({typed:t});/**
   * Test whether value x is smaller or equal to y.
   *
   * The function returns true when x is smaller than y or the relative
   * difference between x and y is smaller than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * Strings are compared by their numerical value.
   *
   * Syntax:
   *
   *    math.smallerEq(x, y)
   *
   * Examples:
   *
   *    math.smaller(1 + 2, 3)        // returns false
   *    math.smallerEq(1 + 2, 3)      // returns true
   *
   * See also:
   *
   *    equal, unequal, smaller, larger, largerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
   */return t(f6,f9({typed:t,config:r}),{"boolean, boolean":(e,t)=>e<=t,"BigNumber, BigNumber":function(e,t){return e.lte(t)||oC(e,t,r.epsilon)},"Fraction, Fraction":(e,t)=>1!==e.compare(t),"Complex, Complex":function(){throw TypeError("No ordering relation is defined for complex numbers")}},c,l({SS:s,DS:o,Ss:u}))}),f9=ta(f6,["typed","config"],e=>{var{typed:t,config:r}=e;return t(f6,{"number, number":function(e,t){return e<=t||eB(e,t,r.epsilon)}})});function pe(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}var pt=ta("solveODE",["typed","add","subtract","multiply","divide","max","map","abs","isPositive","isNegative","larger","smaller","matrix","bignumber","unaryMinus"],t=>{var{typed:r,add:n,subtract:i,multiply:a,divide:o,max:s,map:u,abs:f,isPositive:p,isNegative:d,larger:h,smaller:g,matrix:y,bignumber:v,unaryMinus:x}=t;/**
     * Numerical Integration of Ordinary Differential Equations
     *
     * Two variable step methods are provided:
     * - "RK23": Bogacki–Shampine method
     * - "RK45": Dormand-Prince method RK5(4)7M (default)
     *
     * The arguments are expected as follows.
     *
     * - `func` should be the forcing function `f(t, y)`
     * - `tspan` should be a vector of two numbers or units `[tStart, tEnd]`
     * - `y0` the initial state values, should be a scalar or a flat array
     * - `options` should be an object with the following information:
     *   - `method` ('RK45'): ['RK23', 'RK45']
     *   - `tol` (1e-3): Numeric tolerance of the method, the solver keeps the error estimates less than this value
     *   - `firstStep`: Initial step size
     *   - `minStep`: minimum step size of the method
     *   - `maxStep`: maximum step size of the method
     *   - `minDelta` (0.2): minimum ratio of change for the step
     *   - `maxDelta` (5): maximum ratio of change for the step
     *   - `maxIter` (1e4): maximum number of iterations
     *
     * The returned value is an object with `{t, y}` please note that even though `t` means time, it can represent any other independant variable like `x`:
     * - `t` an array of size `[n]`
     * - `y` the states array can be in two ways
     *   - **if `y0` is a scalar:** returns an array-like of size `[n]`
     *   - **if `y0` is a flat array-like of size [m]:** returns an array like of size `[n, m]`
     *
     * Syntax:
     *
     *     math.solveODE(func, tspan, y0)
     *     math.solveODE(func, tspan, y0, options)
     *
     * Examples:
     *
     *     function func(t, y) {return y}
     *     const tspan = [0, 4]
     *     const y0 = 1
     *     math.solveODE(func, tspan, y0)
     *     math.solveODE(func, tspan, [1, 2])
     *     math.solveODE(func, tspan, y0, { method:"RK23", maxStep:0.1 })
     *
     * See also:
     *
     *     derivative, simplifyCore
     *
     * @param {function} func The forcing function f(t,y)
     * @param {Array | Matrix} tspan The time span
     * @param {number | BigNumber | Unit | Array | Matrix} y0 The initial value
     * @param {Object} [options] Optional configuration options
     * @return {Object} Return an object with t and y values as arrays
     */function b(e){// generates an adaptive runge kutta method from it's butcher tableau
return function(t,r,l,y){if(!(2===r.length&&(r.every(E)||r.every(m))))throw Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');var b,N=r[0],w=r[1],D=h(w,N),A=y.firstStep;// initial time
if(void 0!==A&&!p(A))throw Error('"firstStep" must be positive');var S=y.maxStep;if(void 0!==S&&!p(S))throw Error('"maxStep" must be positive');var C=y.minStep;if(C&&d(C))throw Error('"minStep" must be positive or zero');var M=[N,w,A,C,S].filter(e=>void 0!==e);if(!(M.every(E)||M.every(m)))throw Error('Inconsistent type of "t" dependant variables');// iterate unitil it reaches either the final time or maximum iterations
for(var F=y.tol?y.tol:1e-4,B=y.minDelta?y.minDelta:.2,T=y.maxDelta?y.maxDelta:5,O=y.maxIter?y.maxIter:1e4,_=[N,w,...l,S,C].some(c),[z,q,k,I]=_?[v(e.a),v(e.c),v(e.b),v(e.bp)]:[e.a,e.c,e.b,e.bp],R=A?D?A:x(A):o(i(w,N),1),P=[N],j=[l],U=i(k,I),L=0,$=0,H=D?g:h,Z=(b=D?h:g,function(e,t,r){return b(n(e,r),t)?i(t,e):r});H(P[L],w);){var G=[];// trim the time step so that it doesn't overshoot
R=Z(P[L],w,R),// calculate the first value of k
G.push(t(P[L],j[L]));// calculate the rest of the values of k
for(var V=1;V<q.length;++V)G.push(t(n(P[L],a(q[V],R)),n(j[L],a(R,z[V],G))));// estimate the error by comparing solutions of different orders
var W=s(f(u(a(U,G),e=>m(e)?e.value:e)));W<F&&F/W>1/4&&(// push solution if within tol
P.push(n(P[L],R)),j.push(n(j[L],a(R,k,G))),L++);// estimate the delta value that will affect the step size
var Y=.84*(F/W)**.2;if(g(Y,B)?Y=B:h(Y,T)&&(Y=T),R=a(R,Y=_?v(Y):Y),S&&h(f(R),S)?R=D?S:x(S):C&&g(f(R),C)&&(R=D?C:x(C)),++$>O)throw Error("Maximum number of iterations reached, try changing options")}return{t:P,y:j}}}function N(e,t,r,n){// Solve an adaptive step size rk method
return b({a:[[],[.5],[0,3/4],[2/9,1/3,4/9]],c:[null,.5,3/4,1],b:[2/9,1/3,4/9,0],bp:[7/24,1/4,1/3,1/8]})(e,t,r,n)}function w(e,t,r,n){// Solve an adaptive step size rk method
return b({a:[[],[.2],[3/40,9/40],[44/45,-56/15,32/9],[19372/6561,-25360/2187,64448/6561,-212/729],[9017/3168,-355/33,46732/5247,49/176,-5103/18656],[35/384,0,500/1113,125/192,-2187/6784,11/84]],c:[null,.2,.3,.8,8/9,1,1],b:[35/384,0,500/1113,125/192,-2187/6784,11/84,0],bp:[5179/57600,0,7571/16695,393/640,-92097/339200,187/2100,1/40]})(e,t,r,n)}function D(t,r,n,i){var a=i.method?i.method:"RK45",o={RK23:N,RK45:w};if(a.toUpperCase() in o){var s=function(t){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?pe(Object(n),!0).forEach(function(r){/*@__PURE__*/e(et)(t,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):pe(Object(n)).forEach(function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))})}return t}({},i);// clone the options object
return delete s.method,o[a.toUpperCase()](t,r,n,s)}// throw an error indicating there is no such method
var u=Object.keys(o).map(e=>'"'.concat(e,'"')),l="".concat(u.slice(0,-1).join(", ")," and ").concat(u.slice(-1));throw Error('Unavailable method "'.concat(a,'". Available methods are ').concat(l))}function E(e){// checks if it's a number or bignumber
return c(e)||l(e)}function A(e,t,r,n){// receives matrices and returns matrices
var i=D(e,t.toArray(),r.toArray(),n);return{t:y(i.t),y:y(i.y)}}return r("solveODE",{"function, Array, Array, Object":D,"function, Matrix, Matrix, Object":A,"function, Array, Array":(e,t,r)=>D(e,t,r,{}),"function, Matrix, Matrix":(e,t,r)=>A(e,t,r,{}),"function, Array, number | BigNumber | Unit":(e,t,r)=>{var n=D(e,t,[r],{});return{t:n.t,y:n.y.map(e=>e[0])}},"function, Matrix, number | BigNumber | Unit":(e,t,r)=>{var n=D(e,t.toArray(),[r],{});return{t:y(n.t),y:y(n.y.map(e=>e[0]))}},"function, Array, number | BigNumber | Unit, Object":(e,t,r,n)=>{var i=D(e,t,[r],n);return{t:i.t,y:i.y.map(e=>e[0])}},"function, Matrix, number | BigNumber | Unit, Object":(e,t,r,n)=>{var i=D(e,t.toArray(),[r],n);return{t:y(i.t),y:y(i.y.map(e=>e[0]))}}})}),pr="sort",pn=ta(pr,["typed","matrix","compare","compareNatural"],e=>{var{typed:t,matrix:r,compare:n,compareNatural:i}=e,a=(e,t)=>-n(e,t);/**
   * Sort the items in a matrix.
   *
   * Syntax:
   *
   *    math.sort(x)
   *    math.sort(x, compare)
   *
   * Examples:
   *
   *    math.sort([5, 10, 1]) // returns [1, 5, 10]
   *    math.sort(['C', 'B', 'A', 'D'], math.compareNatural)
   *    // returns ['A', 'B', 'C', 'D']
   *
   *    function sortByLength (a, b) {
   *      return a.length - b.length
   *    }
   *    math.sort(['Langdon', 'Tom', 'Sara'], sortByLength)
   *    // returns ['Tom', 'Sara', 'Langdon']
   *
   * See also:
   *
   *    filter, forEach, map, compare, compareNatural
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to sort
   * @param {Function | 'asc' | 'desc' | 'natural'} [compare='asc']
   *        An optional _comparator function or name. The function is called as
   *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,
   *        and 0 when a == b.
   * @return {Matrix | Array} Returns the sorted matrix.
   */return t(pr,{Array:function(e){return s(e),e.sort(n)},Matrix:function(e){return u(e),r(e.toArray().sort(n),e.storage())},"Array, function":function(e,t){return s(e),e.sort(t)},"Matrix, function":function(e,t){return u(e),r(e.toArray().sort(t),e.storage())},"Array, string":function(e,t){return s(e),e.sort(o(t))},"Matrix, string":function(e,t){return u(e),r(e.toArray().sort(o(t)),e.storage())}});/**
   * Get the comparator for given order ('asc', 'desc', 'natural')
   * @param {'asc' | 'desc' | 'natural'} order
   * @return {Function} Returns a _comparator function
   */function o(e){if("asc"===e)return n;if("desc"===e)return a;if("natural"===e)return i;throw Error('String "asc", "desc", or "natural" expected')}/**
   * Validate whether an array is one dimensional
   * Throws an error when this is not the case
   * @param {Array} array
   * @private
   */function s(e){if(1!==eG(e).length)throw Error("One dimensional array expected")}/**
   * Validate whether a matrix is one dimensional
   * Throws an error when this is not the case
   * @param {Matrix} matrix
   * @private
   */function u(e){if(1!==e.size().length)throw Error("One dimensional matrix expected")}}),pi=ta("Spa",["addScalar","equalScalar","FibonacciHeap"],e=>{var{addScalar:t,equalScalar:r,FibonacciHeap:n}=e;/**
   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array
   * of the vector elements and an ordered list of non-zero elements.
   */function i(){if(!(this instanceof i))throw SyntaxError("Constructor must be called with the new operator");// allocate vector, TODO use typed arrays
this._values=[],this._heap=new n}return(/**
   * Attach type information
   */i.prototype.type="Spa",i.prototype.isSpa=!0,/**
   * Set the value for index i.
   *
   * @param {number} i                       The index
   * @param {number | BigNumber | Complex}   The value at index i
   */i.prototype.set=function(e,t){// check we have a value @ i
if(this._values[e])this._values[e].value=t;else{// insert in heap
var r=this._heap.insert(e,t);// set the value @ i
this._values[e]=r}},i.prototype.get=function(e){var t=this._values[e];return t?t.value:0},i.prototype.accumulate=function(e,r){// node @ i
var n=this._values[e];n?n.value=t(n.value,r):(// insert in heap
n=this._heap.insert(e,r),// initialize value
this._values[e]=n)},i.prototype.forEach=function(e,t,n){// references
var i=this._heap,a=this._values,o=[],s=i.extractMinimum();// extract nodes from heap (ordered)
for(s&&o.push(s);s&&s.key<=t;)s.key>=e&&!r(s.value,0)&&n(s.key,s.value,this),// extract next node, save it
(s=i.extractMinimum())&&o.push(s);// reinsert all nodes in heap
for(var u=0;u<o.length;u++){// current node
var l=o[u];// update values
a[// insert node in heap
(s=i.insert(l.key,l.value)).key]=s}},i.prototype.swap=function(e,t){// node @ i and j
var r=this._values[e],n=this._values[t];// check we need to insert indeces
if(!r&&n)// insert in heap
r=this._heap.insert(e,n.value),// remove from heap
this._heap.remove(n),// set values
this._values[e]=r,this._values[t]=void 0;else if(r&&!n)// insert in heap
n=this._heap.insert(t,r.value),// remove from heap
this._heap.remove(r),// set values
this._values[t]=n,this._values[e]=void 0;else if(r&&n){// swap values
var i=r.value;r.value=n.value,n.value=i}},i)},{isClass:!0}),pa="sparse",po=ta(pa,["typed","SparseMatrix"],e=>{var{typed:t,SparseMatrix:r}=e;/**
   * Create a Sparse Matrix. The function creates a new `math.Matrix` object from
   * an `Array`. A Matrix has utility functions to manipulate the data in the
   * matrix, like getting the size and getting or setting values in the matrix.
   * Note that a Sparse Matrix is always 2-dimensional, so for example if
   * you create one from a plain array of _n_ numbers, you get an _n_ by 1
   * Sparse "column vector".
   *
   * Syntax:
   *
   *    math.sparse()               // creates an empty sparse matrix.
   *    math.sparse(data)           // creates a sparse matrix with initial data.
   *    math.sparse(data, 'number') // creates a sparse matrix with initial data, number datatype.
   *
   * Examples:
   *
   *    let m = math.sparse([[1, 2], [3, 4]])
   *    m.size()                        // Array [2, 2]
   *    m.resize([3, 2], 5)
   *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]
   *    m.get([1, 0])                    // number 3
   *    let v = math.sparse([0, 0, 1])
   *    v.size()                        // Array [3, 1]
   *    v.get([2, 0])                   // number 1
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, number, string, unit, matrix
   *
   * @param {Array | Matrix} [data]    A two dimensional array
   *
   * @return {Matrix} The created matrix
   */return t(pa,{"":function(){return new r([])},string:function(e){return new r([],e)},"Array | Matrix":function(e){return new r(e)},"Array | Matrix, string":function(e,t){return new r(e,t)}})}),ps=ta("SparseMatrix",["typed","equalScalar","Matrix"],e=>{var{typed:t,equalScalar:r,Matrix:n}=e;/**
   * Sparse Matrix implementation. This type implements
   * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))
   * format for two-dimensional sparse matrices.
   * @class SparseMatrix
   */function i(e,t){if(!(this instanceof i))throw SyntaxError("Constructor must be called with the new operator");if(t&&!d(t))throw Error("Invalid datatype: "+t);if(g(e))"SparseMatrix"===e.type?(// clone arrays
this._values=e._values?J(e._values):void 0,this._index=J(e._index),this._ptr=J(e._ptr),this._size=J(e._size),this._datatype=t||e._datatype):a(this,e.valueOf(),t||e._datatype);else if(e&&h(e.index)&&h(e.ptr)&&h(e.size))// initialize fields
this._values=e.values,this._index=e.index,this._ptr=e.ptr,this._size=e.size,this._datatype=t||e.datatype;else if(h(e))a(this,e,t);else if(e)throw TypeError("Unsupported type of data ("+Y(e)+")");else // nothing provided
this._values=[],this._index=[],this._ptr=[0],this._size=[0,0],this._datatype=t}function a(e,n,i){// initialize fields
e._values=[],e._index=[],e._ptr=[],e._datatype=i;// discover rows & columns, do not use math.size() to avoid looping array twice
var a=n.length,o=0,s=r,u=0;// check we have rows (empty array)
if(d(i)&&(// find signature that matches (datatype, datatype)
s=t.find(r,[i,i])||r,// convert 0 to the same datatype
u=t.convert(0,i)),a>0){// column index
var l=0;do{// store pointer to values index
e._ptr.push(e._index.length);// loop rows
for(var c=0;c<a;c++){// current row
var f=n[c];// check row is an array
if(h(f))// check row has column
{if(0===l&&o<f.length&&(o=f.length),l<f.length){// value
var p=f[l];// check value != 0
s(p,u)||(// store value
e._values.push(p),// index
e._index.push(c))}}else 0===l&&o<1&&(o=1),s(f,u)||(// store value
e._values.push(f),// index
e._index.push(c))}// increment index
l++}while(l<o)}// store number of values in ptr
e._ptr.push(e._index.length),// size
e._size=[a,o]}function o(e,t,r,n){// check row is on the bottom side
if(r-t==0)return r;// loop rows [top, bottom[
for(var i=t;i<r;i++)// check we found value index
if(n[i]===e)return i;// we did not find row
return t}function s(e,t,r,n,i,a,o){// insert value
i.splice(e,0,n),// update row for k
a.splice(e,0,t);// update column pointers
for(var s=r+1;s<o.length;s++)o[s]++}function u(e,n,i,a){// value to insert at the time of growing matrix
var o,s,u,l=a||0,c=r,f=0;d(e._datatype)&&(// find signature that matches (datatype, datatype)
c=t.find(r,[e._datatype,e._datatype])||r,// convert 0 to the same datatype
f=t.convert(0,e._datatype),// convert value to the same datatype
l=t.convert(l,e._datatype));// should we insert the value?
var p=!c(l,f),m=e._size[0],h=e._size[1];// check we need to increase columns
if(i>h){// loop new columns
for(s=h;s<i;s++)// check we need to insert matrix._values
if(// update matrix._ptr for current column
e._ptr[s]=e._values.length,p)for(o=0;o<m;o++)// add new matrix._values
e._values.push(l),// update matrix._index
e._index.push(o);// store number of matrix._values in matrix._ptr
e._ptr[i]=e._values.length}else i<h&&(// truncate matrix._ptr
e._ptr.splice(i+1,h-i),// truncate matrix._values and matrix._index
e._values.splice(e._ptr[i],e._values.length),e._index.splice(e._ptr[i],e._index.length));// check we need to increase rows
if(// update columns
h=i,n>m){if(p){// inserts
var g=0;// loop columns
for(s=0;s<h;s++){// update matrix._ptr for current column
e._ptr[s]=e._ptr[s]+g,// where to insert matrix._values
u=e._ptr[s+1]+g;// pointer
var y=0;// loop new rows, initialize pointer
for(o=m;o<n;o++,y++)// add value
e._values.splice(u+y,0,l),// update matrix._index
e._index.splice(u+y,0,o),// increment inserts
g++}// store number of matrix._values in matrix._ptr
e._ptr[h]=e._values.length}}else if(n<m){// deletes
var v=0;// loop columns
for(s=0;s<h;s++){// update matrix._ptr for current column
e._ptr[s]=e._ptr[s]-v;// where matrix._values start for next column
var x=e._ptr[s],b=e._ptr[s+1]-v;// loop matrix._index
for(u=x;u<b;u++)// check we need to delete value and matrix._index
// row
(o=e._index[u])>n-1&&(// remove value
e._values.splice(u,1),// remove item from matrix._index
e._index.splice(u,1),// increase deletes
v++)}// update matrix._ptr for current column
e._ptr[s]=e._values.length}// return matrix
return(// update matrix._size
e._size[0]=n,e._size[1]=i,e)}function f(e,t,r,n,i){// rows and columns
var a,o,s=n[0],u=n[1],l=[];// initialize array
for(a=0;a<s;a++)for(o=0,l[a]=[];o<u;o++)l[a][o]=0;// loop columns
for(o=0;o<u;o++)// loop k within [k0, k1[
for(var c=r[o],f=r[o+1],p=c;p<f;p++)// set value (use one for pattern matrix)
l[// row index
a=t[p]][o]=e?i?J(e[p]):e[p]:1;return l}return i.prototype=new n,/**
   * Create a new SparseMatrix
   */i.prototype.createSparseMatrix=function(e,t){return new i(e,t)},/**
   * Attach type information
   */Object.defineProperty(i,"name",{value:"SparseMatrix"}),i.prototype.constructor=i,i.prototype.type="SparseMatrix",i.prototype.isSparseMatrix=!0,/**
   * Get the matrix type
   *
   * Usage:
   *    const matrixType = matrix.getDataType()  // retrieves the matrix type
   *
   * @memberOf SparseMatrix
   * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
   */i.prototype.getDataType=function(){return tt(this._values,Y)},/**
   * Get the storage format used by the matrix.
   *
   * Usage:
   *     const format = matrix.storage()   // retrieve storage format
   *
   * @memberof SparseMatrix
   * @return {string}           The storage format.
   */i.prototype.storage=function(){return"sparse"},/**
   * Get the datatype of the data stored in the matrix.
   *
   * Usage:
   *     const format = matrix.datatype()    // retrieve matrix datatype
   *
   * @memberof SparseMatrix
   * @return {string}           The datatype.
   */i.prototype.datatype=function(){return this._datatype},/**
   * Create a new SparseMatrix
   * @memberof SparseMatrix
   * @param {Array} data
   * @param {string} [datatype]
   */i.prototype.create=function(e,t){return new i(e,t)},/**
   * Get the matrix density.
   *
   * Usage:
   *     const density = matrix.density()                   // retrieve matrix density
   *
   * @memberof SparseMatrix
   * @return {number}           The matrix density.
   */i.prototype.density=function(){// rows & columns
var e=this._size[0],t=this._size[1];// calculate density
return 0!==e&&0!==t?this._index.length/(e*t):0},/**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     const subset = matrix.subset(index)               // retrieve subset
   *     const value = matrix.subset(index, replacement)   // replace subset
   *
   * @memberof SparseMatrix
   * @param {Index} index
   * @param {Array | Matrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */i.prototype.subset=function(e,t,r){// check it is a pattern matrix
if(!this._values)throw Error("Cannot invoke subset on a Pattern only matrix");// check arguments
switch(arguments.length){case 1:return function(e,t){// check idx
if(!N(t))throw TypeError("Invalid index");if(t.isScalar())return e.get(t.min());// validate dimensions
var r,n,a,o,s=t.size();if(s.length!==e._size.length)throw new eH(s.length,e._size.length);// validate if any of the ranges in the index is out of range
var u=t.min(),l=t.max();for(r=0,n=e._size.length;r<n;r++)eY(u[r],e._size[r]),eY(l[r],e._size[r]);// matrix arrays
var c=e._values,f=e._index,p=e._ptr,m=t.dimension(0),d=t.dimension(1),h=[],g=[];// loop rows in resulting matrix
m.forEach(function(e,t){// update permutation vector
g[e]=t[0],// mark i in workspace
h[e]=!0});// result matrix arrays
var y=c?[]:void 0,v=[],x=[];// return matrix
return(// loop columns in result matrix
d.forEach(function(e){// loop values in column j
for(// update ptr
x.push(v.length),a=p[e],o=p[e+1];a<o;a++)// check row is in result matrix
!0===h[// row
r=f[a]]&&(// push index
v.push(g[r]),y&&y.push(c[a]))}),// update ptr
x.push(v.length),new i({values:y,index:v,ptr:x,size:s,datatype:e._datatype}))}(this,e);// intentional fall through
case 2:case 3:return function(e,t,r,n){// check index
if(!t||!0!==t.isIndex)throw TypeError("Invalid index");// get index size and check whether the index contains a single value
var i,a=t.size(),o=t.isScalar();// check index is a scalar
if(g(r)?(// submatrix size
i=r.size(),// use array representation
r=r.toArray()):i=eG(r),o){// verify submatrix is a scalar
if(0!==i.length)throw TypeError("Scalar expected");// set value
e.set(t.min(),r,n)}else{// validate dimensions, index size must be one or two dimensions
if(1!==a.length&&2!==a.length)throw new eH(a.length,e._size.length,"<");// check submatrix and index have the same dimensions
if(i.length<a.length){for(// calculate number of missing outer dimensions
var s=0,u=0;1===a[s]&&1===i[s];)s++;for(;1===a[s];)u++,s++;// unsqueeze both outer and inner dimensions
r=e2(r,a.length,u,i)}// check whether the size of the submatrix matches the index size
if(!Q(a,i))throw new eH(a,i,">");// insert the sub matrix
if(1===a.length)t.dimension(0).forEach(function(t,i){eY(t),e.set([t,0],r[i[0]],n)});else{// if the replacement index has 2 dimensions, go through each one and set the value in the correct index
var l=t.dimension(0),c=t.dimension(1);l.forEach(function(t,i){eY(t),c.forEach(function(a,o){eY(a),e.set([t,a],r[i[0]][o[0]],n)})})}}return e}(this,e,t,r);default:throw SyntaxError("Wrong number of arguments")}},/**
   * Get a single element from the matrix.
   * @memberof SparseMatrix
   * @param {number[]} index   Zero-based index
   * @return {*} value
   */i.prototype.get=function(e){if(!h(e))throw TypeError("Array expected");if(e.length!==this._size.length)throw new eH(e.length,this._size.length);// check it is a pattern matrix
if(!this._values)throw Error("Cannot invoke get on a Pattern only matrix");// row and column
var t=e[0],r=e[1];eY(t,this._size[0]),eY(r,this._size[1]);// find value index
var n=o(t,this._ptr[r],this._ptr[r+1],this._index);return(// check k is prior to next column k and it is in the correct row
n<this._ptr[r+1]&&this._index[n]===t?this._values[n]:0)},/**
   * Replace a single element in the matrix.
   * @memberof SparseMatrix
   * @param {number[]} index   Zero-based index
   * @param {*} v
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be set to zero.
   * @return {SparseMatrix} self
   */i.prototype.set=function(e,n,i){if(!h(e))throw TypeError("Array expected");if(e.length!==this._size.length)throw new eH(e.length,this._size.length);// check it is a pattern matrix
if(!this._values)throw Error("Cannot invoke set on a Pattern only matrix");// row and column
var a=e[0],l=e[1],c=this._size[0],f=this._size[1],p=r,m=0;d(this._datatype)&&(// find signature that matches (datatype, datatype)
p=t.find(r,[this._datatype,this._datatype])||r,// convert 0 to the same datatype
m=t.convert(0,this._datatype)),(a>c-1||l>f-1)&&(// resize matrix
u(this,Math.max(a+1,c),Math.max(l+1,f),i),// update rows & columns
c=this._size[0],f=this._size[1]),eY(a,c),eY(l,f);// find value index
var g=o(a,this._ptr[l],this._ptr[l+1],this._index);return g<this._ptr[l+1]&&this._index[g]===a?p(n,m)?function(e,t,r,n,i){// remove value @ k
r.splice(e,1),n.splice(e,1);// update pointers
for(var a=t+1;a<i.length;a++)i[a]--}(g,l,this._values,this._index,this._ptr):this._values[g]=n:p(n,m)||s(g,a,l,n,this._values,this._index,this._ptr),this},/**
   * Resize the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @memberof SparseMatrix
   * @param {number[] | Matrix} size  The new size the matrix should have.
   *                                  Since sparse matrices are always two-dimensional,
   *                                  size must be two numbers in either an array or a matrix
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix}                 The resized matrix
   */i.prototype.resize=function(e,t,r){// validate arguments
if(!y(e))throw TypeError("Array or Matrix expected");// SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector
var n=e.valueOf().map(e=>Array.isArray(e)&&1===e.length?e[0]:e);if(2!==n.length)throw Error("Only two dimensions matrix are supported");// resize matrix
return(// check sizes
n.forEach(function(e){if(!l(e)||!eh(e)||e<0)throw TypeError("Invalid size, must contain positive integers (size: "+eP(n)+")")}),u(r?this.clone():this,n[0],n[1],t))},/**
   * Reshape the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (reshape in place).
   *
   * NOTE: This might be better suited to copy by default, instead of modifying
   *       in place. For now, it operates in place to remain consistent with
   *       resize().
   *
   * @memberof SparseMatrix
   * @param {number[]} sizes          The new size the matrix should have.
   *                                  Since sparse matrices are always two-dimensional,
   *                                  size must be two numbers in either an array or a matrix
   * @param {boolean} [copy]          Return a reshaped copy of the matrix
   *
   * @return {Matrix}                 The reshaped matrix
   */i.prototype.reshape=function(e,t){// validate arguments
if(!h(e))throw TypeError("Array expected");if(2!==e.length)throw Error("Sparse matrices can only be reshaped in two dimensions");// check sizes
e.forEach(function(t){if(!l(t)||!eh(t)||t<=-2||0===t)throw TypeError("Invalid size, must contain positive integers or -1 (size: "+eP(e)+")")});var r=this._size[0]*this._size[1],n=(e=eK(e,r))[0]*e[1];// m * n must not change
if(r!==n)throw Error("Reshaping sparse matrix will result in the wrong number of elements");// matrix to reshape
var i=t?this.clone():this;// return unchanged if the same shape
if(this._size[0]===e[0]&&this._size[1]===e[1])return i;for(var a=[],u=0;u<i._ptr.length;u++)for(var c=0;c<i._ptr[u+1]-i._ptr[u];c++)a.push(u);// Transform the (row, column) indices
for(var f=i._values.slice(),p=i._index.slice(),m=0;m<i._index.length;m++){var d=p[m],g=a[m],y=d*i._size[1]+g;a[m]=y%e[1],p[m]=Math.floor(y/e[1])}// Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored
// in column-major order, so we have to reorder the value array now. One option is to use a multisort,
// sorting several arrays based on some other array.
// OR, we could easily just:
// 1. Remove all values from the matrix
i._values.length=0,i._index.length=0,i._ptr.length=e[1]+1,i._size=e.slice();for(var v=0;v<i._ptr.length;v++)i._ptr[v]=0;// 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)
// This step is probably the most time-consuming
for(var x=0;x<f.length;x++){var b=p[x],N=a[x],w=f[x];s(o(b,i._ptr[N],i._ptr[N+1],i._index),b,N,w,i._values,i._index,i._ptr)}// The value indices are inserted out of order, but apparently that's... still OK?
return i},/**
   * Create a clone of the matrix
   * @memberof SparseMatrix
   * @return {SparseMatrix} clone
   */i.prototype.clone=function(){return new i({values:this._values?J(this._values):void 0,index:J(this._index),ptr:J(this._ptr),size:J(this._size),datatype:this._datatype})},/**
   * Retrieve the size of the matrix.
   * @memberof SparseMatrix
   * @returns {number[]} size
   */i.prototype.size=function(){return this._size.slice(0);// copy the Array
},/**
   * Create a new matrix with the results of the callback function executed on
   * each entry of the matrix.
   * @memberof SparseMatrix
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
   *
   * @return {SparseMatrix} matrix
   */i.prototype.map=function(e,n){// check it is a pattern matrix
if(!this._values)throw Error("Cannot invoke map on a Pattern only matrix");// matrix instance
var a=this,o=this._size[0],s=this._size[1],u=sx(e);// invoke _map
return(/**
   * Create a new matrix with the results of the callback function executed on the interval
   * [minRow..maxRow, minColumn..maxColumn].
   */function(e,n,a,o,s,u,l){// result arrays
var c=[],f=[],p=[],m=r,h=0;d(e._datatype)&&(// find signature that matches (datatype, datatype)
m=t.find(r,[e._datatype,e._datatype])||r,// convert 0 to the same datatype
h=t.convert(0,e._datatype));// loop columns
for(var g=function(e,t,r){// invoke callback
e=u(e,t,r),m(e,h)||(// store value
c.push(e),// index
f.push(t))},y=o;y<=s;y++){// store pointer to values index
p.push(c.length);// k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
var v=e._ptr[y],x=e._ptr[y+1];if(l)for(var b=v;b<x;b++){// row index
var N=e._index[b];// check i is in range
N>=n&&N<=a&&g(e._values[b],N-n,y-o)}else{for(var w={},D=v;D<x;D++)w[e._index[D]]=e._values[D];// loop over all rows (indexes can be unordered so we can't use that),
// and either read the value or zero
for(var E=n;E<=a;E++)g(E in w?w[E]:0,E-n,y-o)}}// return sparse matrix
return(// store number of values in ptr
p.push(c.length),new i({values:c,index:f,ptr:p,size:[a-n+1,s-o+1]}))}(this,0,o-1,0,s-1,function(t,r,n){return(// invoke callback
1===u?e(t):2===u?e(t,[r,n]):e(t,[r,n],a))},n))},/**
   * Execute a callback function on each entry of the matrix.
   * @memberof SparseMatrix
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
   *                              If false, the indices are guaranteed to be in order,
   *                              if true, the indices can be unordered.
   */i.prototype.forEach=function(e,t){// check it is a pattern matrix
if(!this._values)throw Error("Cannot invoke forEach on a Pattern only matrix");// loop columns
for(var r=this._size[0],n=this._size[1],i=0;i<n;i++){// k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
var a=this._ptr[i],o=this._ptr[i+1];if(t)for(var s=a;s<o;s++){// row index
var u=this._index[s];// value @ k
e(this._values[s],[u,i],this)}else{for(var l={},c=a;c<o;c++)l[this._index[c]]=this._values[c];// loop over all rows (indexes can be unordered so we can't use that),
// and either read the value or zero
for(var f=0;f<r;f++)e(f in l?l[f]:0,[f,i],this)}}},/**
   * Iterate over the matrix elements, skipping zeros
   * @return {Iterable<{ value, index: number[] }>}
   */i.prototype[Symbol.iterator]=function*(){if(!this._values)throw Error("Cannot iterate a Pattern only matrix");for(var e=this._size[1],t=0;t<e;t++)for(var r=this._ptr[t],n=this._ptr[t+1],i=r;i<n;i++){// row index
var a=this._index[i];yield{value:this._values[i],index:[a,t]}}},/**
   * Create an Array with a copy of the data of the SparseMatrix
   * @memberof SparseMatrix
   * @returns {Array} array
   */i.prototype.toArray=function(){return f(this._values,this._index,this._ptr,this._size,!0)},/**
   * Get the primitive value of the SparseMatrix: a two dimensions array
   * @memberof SparseMatrix
   * @returns {Array} array
   */i.prototype.valueOf=function(){return f(this._values,this._index,this._ptr,this._size,!1)},/**
   * Get a string representation of the matrix, with optional formatting options.
   * @memberof SparseMatrix
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */i.prototype.format=function(e){// loop columns
for(var t=this._size[0],r=this._size[1],n=this.density(),i="Sparse Matrix ["+eP(t,e)+" x "+eP(r,e)+"] density: "+eP(n,e)+"\n",a=0;a<r;a++)// loop k within [k0, k1[
for(var o=this._ptr[a],s=this._ptr[a+1],u=o;u<s;u++)// append value
i+="\n    ("+eP(this._index[u],e)+", "+eP(a,e)+") ==> "+(this._values?eP(this._values[u],e):"X");return i},/**
   * Get a string representation of the matrix
   * @memberof SparseMatrix
   * @returns {string} str
   */i.prototype.toString=function(){return eP(this.toArray())},/**
   * Get a JSON representation of the matrix
   * @memberof SparseMatrix
   * @returns {Object}
   */i.prototype.toJSON=function(){return{mathjs:"SparseMatrix",values:this._values,index:this._index,ptr:this._ptr,size:this._size,datatype:this._datatype}},/**
   * Get the kth Matrix diagonal.
   *
   * @memberof SparseMatrix
   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
   *
   * @returns {Matrix}                     The matrix vector with the diagonal values.
   */i.prototype.diagonal=function(e){// validate k if any
if(e)// is must be an integer
{if(c(e)&&(e=e.toNumber()),!l(e)||!eh(e))throw TypeError("The parameter k must be an integer number")}else e=0;var t=e>0?e:0,r=e<0?-e:0,n=this._size[0],a=this._size[1],o=Math.min(n-r,a-t),s=[],u=[],f=[];// initial ptr value
f[0]=0;// loop columns
for(var p=t;p<a&&s.length<o;p++)// loop x within [k0, k1[
for(var m=this._ptr[p],d=this._ptr[p+1],h=m;h<d;h++){// row index
var g=this._index[h];// check row
if(g===p-t+r){// value on this column
s.push(this._values[h]),// store row
u[s.length-1]=g-r;break}}// return matrix
return(// close ptr
f.push(s.length),new i({values:s,index:u,ptr:f,size:[o,1]}))},/**
   * Generate a matrix from a JSON object
   * @memberof SparseMatrix
   * @param {Object} json  An object structured like
   *                       `{"mathjs": "SparseMatrix", "values": [], "index": [], "ptr": [], "size": []}`,
   *                       where mathjs is optional
   * @returns {SparseMatrix}
   */i.fromJSON=function(e){return new i(e)},/**
   * Create a diagonal matrix.
   *
   * @memberof SparseMatrix
   * @param {Array} size                       The matrix size.
   * @param {number | Array | Matrix } value   The values for the diagonal.
   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.
   * @param {number} [defaultValue]            The default value for non-diagonal
   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.
   *
   * @returns {SparseMatrix}
   */i.diagonal=function(e,n,a,o,s){if(!h(e))throw TypeError("Array expected, size parameter");if(2!==e.length)throw Error("Only two dimensions matrix are supported");// validate k if any
if(// map size & validate
e=e.map(function(e){// validate arguments
if(c(e)&&(e=e.toNumber()),!l(e)||!eh(e)||e<1)throw Error("Size values must be positive integers");return e}),a)// is must be an integer
{if(c(a)&&(a=a.toNumber()),!l(a)||!eh(a))throw TypeError("The parameter k must be an integer number")}else a=0;// equal signature to use
var u,f=r,p=0;d(s)&&(// find signature that matches (datatype, datatype)
f=t.find(r,[s,s])||r,// convert 0 to the same datatype
p=t.convert(0,s));var m=a>0?a:0,y=a<0?-a:0,v=e[0],x=e[1],b=Math.min(v-y,x-m);// check value
if(h(n)){// validate array
if(n.length!==b)throw Error("Invalid value array length");// define function
u=function(e){// return value @ i
return n[e]}}else if(g(n)){// matrix size
var N=n.size();// validate matrix
if(1!==N.length||N[0]!==b)throw Error("Invalid matrix length");// define function
u=function(e){// return value @ i
return n.get([e])}}else u=function(){// return value
return n};// loop items
for(var w=[],D=[],E=[],A=0;A<x;A++){// number of rows with value
E.push(w.length);// diagonal index
var S=A-m;// check we need to set diagonal value
if(S>=0&&S<b){// get value @ i
var C=u(S);// check for zero
f(C,p)||(// column
D.push(S+y),// add value
w.push(C))}}// create SparseMatrix
return(// last value should be number of values
E.push(w.length),new i({values:w,index:D,ptr:E,size:[v,x]}))},/**
   * Swap rows i and j in Matrix.
   *
   * @memberof SparseMatrix
   * @param {number} i       Matrix row index 1
   * @param {number} j       Matrix row index 2
   *
   * @return {Matrix}        The matrix reference
   */i.prototype.swapRows=function(e,t){// check index
if(!l(e)||!eh(e)||!l(t)||!eh(t))throw Error("Row index must be positive integers");// check dimensions
if(2!==this._size.length)throw Error("Only two dimensional matrix is supported");// return current instance
return eY(e,this._size[0]),eY(t,this._size[0]),// swap rows
i._swapRows(e,t,this._size[1],this._values,this._index,this._ptr),this},/**
   * Loop rows with data in column j.
   *
   * @param {number} j            Column
   * @param {Array} values        Matrix values
   * @param {Array} index         Matrix row indeces
   * @param {Array} ptr           Matrix column pointers
   * @param {Function} callback   Callback function invoked for every row in column j
   */i._forEachRow=function(e,t,r,n,i){// loop
for(var a=n[e],o=n[e+1],s=a;s<o;s++)i(r[s],t[s])},/**
   * Swap rows x and y in Sparse Matrix data structures.
   *
   * @param {number} x         Matrix row index 1
   * @param {number} y         Matrix row index 2
   * @param {number} columns   Number of columns in matrix
   * @param {Array} values     Matrix values
   * @param {Array} index      Matrix row indeces
   * @param {Array} ptr        Matrix column pointers
   */i._swapRows=function(e,t,r,n,i,a){// loop columns
for(var s=0;s<r;s++){// k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
var u=a[s],l=a[s+1],c=o(e,u,l,i),f=o(t,u,l,i);// check both rows exist in matrix
if(c<l&&f<l&&i[c]===e&&i[f]===t){// swap values (check for pattern matrix)
if(n){var p=n[c];n[c]=n[f],n[f]=p}continue}// check x row exist & no y row
if(c<l&&i[c]===e&&(f>=l||i[f]!==t)){// value @ x (check for pattern matrix)
var m=n?n[c]:void 0;// insert value @ y
i.splice(f,0,t),n&&n.splice(f,0,m),// remove value @ x (adjust array index if needed)
i.splice(f<=c?c+1:c,1),n&&n.splice(f<=c?c+1:c,1);continue}// check y row exist & no x row
if(f<l&&i[f]===t&&(c>=l||i[c]!==e)){// value @ y (check for pattern matrix)
var d=n?n[f]:void 0;// insert value @ x
i.splice(c,0,e),n&&n.splice(c,0,d),// remove value @ y (adjust array index if needed)
i.splice(c<=f?f+1:f,1),n&&n.splice(c<=f?f+1:f,1)}}},i},{isClass:!0}),pu="splitUnit",pl=ta(pu,["typed"],e=>{var{typed:t}=e;/**
   * Split a unit in an array of units whose sum is equal to the original unit.
   *
   * Syntax:
   *
   *     math.splitUnit(unit: Unit, parts: Array.<Unit>)
   *
   * Example:
   *
   *     math.splitUnit(new Unit(1, 'm'), ['feet', 'inch'])
   *     // [ 3 feet, 3.3700787401575 inch ]
   *
   * See also:
   *
   *     unit
   *
   * @param {Array} [parts] An array of strings or valueless units.
   * @return {Array} An array of units.
   */return t(pu,{"Unit, Array":function(e,t){return e.splitUnit(t)}})}),pc=ta("sqrt",["config","typed","Complex"],e=>{var{config:t,typed:r,Complex:n}=e;/**
   * Calculate the square root of a value.
   *
   * For matrices, if you want the matrix square root of a square matrix,
   * use the `sqrtm` function. If you wish to apply `sqrt` elementwise to
   * a matrix M, use `math.map(M, math.sqrt)`.
   *
   * Syntax:
   *
   *    math.sqrt(x)
   *
   * Examples:
   *
   *    math.sqrt(25)                // returns 5
   *    math.square(5)               // returns 25
   *    math.sqrt(-4)                // returns Complex 2i
   *
   * See also:
   *
   *    square, multiply, cube, cbrt, sqrtm
   *
   * @param {number | BigNumber | Complex | Unit} x
   *            Value for which to calculate the square root.
   * @return {number | BigNumber | Complex | Unit}
   *            Returns the square root of `x`
   */return r("sqrt",{number:i,Complex:function(e){return e.sqrt()},BigNumber:function(e){return!e.isNegative()||t.predictable?e.sqrt():i(e.toNumber())},Unit:function(e){// Someday will work for complex units when they are implemented
return e.pow(.5)}});/**
   * Calculate sqrt for a number
   * @param {number} x
   * @returns {number | Complex} Returns the square root of x
   * @private
   */function i(e){return isNaN(e)?NaN:e>=0||t.predictable?Math.sqrt(e):new n(e,0).sqrt()}}),pf="sqrtm",pp=ta(pf,["typed","abs","add","multiply","map","sqrt","subtract","inv","size","max","identity"],e=>{var{typed:t,abs:r,add:n,multiply:i,map:a,sqrt:o,subtract:s,inv:u,size:l,max:c,identity:f}=e;/**
   * Calculate the principal square root of a square matrix.
   * The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.
   *
   * https://en.wikipedia.org/wiki/Square_root_of_a_matrix
   *
   * Syntax:
   *
   *     math.sqrtm(A)
   *
   * Examples:
   *
   *     math.sqrtm([[33, 24], [48, 57]]) // returns [[5, 2], [4, 7]]
   *
   * See also:
   *
   *     sqrt, pow
   *
   * @param  {Array | Matrix} A   The square matrix `A`
   * @return {Array | Matrix}     The principal square root of matrix `A`
   */return t(pf,{"Array | Matrix":function(e){var t=g(e)?e.size():eG(e);switch(t.length){case 1:// Single element Array | Matrix
if(1===t[0])return a(e,o);throw RangeError("Matrix must be square (size: "+eP(t)+")");case 2:if(t[0]===t[1])return(/**
   * Calculate the principal square root matrix using the Denman–Beavers iterative method
   *
   * https://en.wikipedia.org/wiki/Square_root_of_a_matrix#By_Denman–Beavers_iteration
   *
   * @param  {Array | Matrix} A   The square matrix `A`
   * @return {Array | Matrix}     The principal square root of matrix `A`
   * @private
   */function(e){var t,a=0,o=e,p=f(l(e));do{var m=o;if(o=i(.5,n(m,u(p))),p=i(.5,n(p,u(m))),(t=c(r(s(o,m))))>1e-6&&++a>1e3)throw Error("computing square root of matrix: iterative method could not converge")}while(t>1e-6)return o}(e));throw RangeError("Matrix must be square (size: "+eP(t)+")");default:// Multi dimensional array
throw RangeError("Matrix must be at most two dimensional (size: "+eP(t)+")")}}})}),pm="square",pd=ta(pm,["typed"],e=>{var{typed:t}=e;/**
   * Compute the square of a value, `x * x`.
   * To avoid confusion with multiplying a square matrix by itself,
   * this function does not apply to matrices. If you wish to square
   * every element of a matrix, see the examples.
   *
   * Syntax:
   *
   *    math.square(x)
   *
   * Examples:
   *
   *    math.square(2)           // returns number 4
   *    math.square(3)           // returns number 9
   *    math.pow(3, 2)           // returns number 9
   *    math.multiply(3, 3)      // returns number 9
   *
   *    math.map([1, 2, 3, 4], math.square)  // returns Array [1, 4, 9, 16]
   *
   * See also:
   *
   *    multiply, cube, sqrt, pow
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x
   *            Number for which to calculate the square
   * @return {number | BigNumber | Fraction | Complex | Unit}
   *            Squared value
   */return t(pm,{number:n6,Complex:function(e){return e.mul(e)},BigNumber:function(e){return e.times(e)},Fraction:function(e){return e.mul(e)},Unit:function(e){return e.pow(2)}})}),ph="squeeze",pg=ta(ph,["typed","matrix"],e=>{var{typed:t,matrix:r}=e;/**
   * Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
   *
   * Syntax:
   *
   *     math.squeeze(x)
   *
   * Examples:
   *
   *     math.squeeze([3])           // returns 3
   *     math.squeeze([[3]])         // returns 3
   *
   *     const A = math.zeros(3, 1)    // returns [[0], [0], [0]] (size 3x1)
   *     math.squeeze(A)             // returns [0, 0, 0] (size 3)
   *
   *     const B = math.zeros(1, 3)    // returns [[0, 0, 0]] (size 1x3)
   *     math.squeeze(B)             // returns [0, 0, 0] (size 3)
   *
   *     // only inner and outer dimensions are removed
   *     const C = math.zeros(2, 1, 3) // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
   *     math.squeeze(C)             // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
   *
   * See also:
   *
   *     subset
   *
   * @param {Matrix | Array} x      Matrix to be squeezed
   * @return {Matrix | Array} Squeezed matrix
   */return t(ph,{Array:function(e){return e1(J(e))},Matrix:function(e){var t=e1(e.toArray());// FIXME: return the same type of matrix as the input
return Array.isArray(t)?r(t):t},any:function(e){// scalar
return J(e)}})}),py="stirlingS2",pv=ta(py,["typed","addScalar","subtractScalar","multiplyScalar","divideScalar","pow","factorial","combinations","isNegative","isInteger","number","?bignumber","larger"],e=>{var{typed:t,addScalar:r,subtractScalar:n,multiplyScalar:i,divideScalar:a,pow:o,factorial:s,combinations:u,isNegative:c,isInteger:f,number:p,bignumber:m,larger:d}=e,h=[],g=[];/**
   * The Stirling numbers of the second kind, counts the number of ways to partition
   * a set of n labelled objects into k nonempty unlabelled subsets.
   * stirlingS2 only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   *  If n = k or k = 1 <= n, then s(n,k) = 1
   *  If k = 0 < n, then s(n,k) = 0
   *
   * Note that if either n or k is supplied as a BigNumber, the result will be
   * as well.
   *
   * Syntax:
   *
   *   math.stirlingS2(n, k)
   *
   * Examples:
   *
   *    math.stirlingS2(5, 3) //returns 25
   *
   * See also:
   *
   *    bellNumbers
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @param {Number | BigNumber} k    Number of objects in the subset
   * @return {Number | BigNumber}     S(n,k)
   */return t(py,{"number | BigNumber, number | BigNumber":function(e,t){if(!f(e)||c(e)||!f(t)||c(t))throw TypeError("Non-negative integer value expected in function stirlingS2");if(d(t,e))throw TypeError("k must be less than or equal to n in function stirlingS2");var n=!(l(e)&&l(t)),a=n?g:h,o=n?m:p,s=p(e),u=p(t);/* See if we already have the value: */if(a[s]&&a[s].length>u)return a[s][u];/* Fill the cache */for(var y=0;y<=s;++y)if(a[y]||(a[y]=[o(0===y?1:0)]),0!==y)for(var v=a[y],x=a[y-1],b=v.length;b<=y&&b<=u;++b)b===y?v[b]=1:v[b]=r(i(o(b),x[b]),x[b-1]);return a[s][u]}})}),px="string",pb=ta(px,["typed"],e=>{var{typed:t}=e;/**
   * Create a string or convert any object into a string.
   * Elements of Arrays and Matrices are processed element wise.
   *
   * Syntax:
   *
   *    math.string(value)
   *
   * Examples:
   *
   *    math.string(4.2)               // returns string '4.2'
   *    math.string(math.complex(3, 2) // returns string '3 + 2i'
   *
   *    const u = math.unit(5, 'km')
   *    math.string(u.to('m'))         // returns string '5000 m'
   *
   *    math.string([true, false])     // returns ['true', 'false']
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, number, unit
   *
   * @param {* | Array | Matrix | null} [value]  A value to convert to a string
   * @return {string | Array | Matrix} The created string
   */return t(px,{"":function(){return""},number:eD,null:function(e){return"null"},boolean:function(e){return e+""},string:function(e){return e},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e)),any:function(e){return String(e)}})}),pN="subtract",pw=ta(pN,["typed","matrix","equalScalar","subtractScalar","unaryMinus","DenseMatrix","concat"],e=>{var{typed:t,matrix:r,equalScalar:n,subtractScalar:i,unaryMinus:a,DenseMatrix:o,concat:s}=e,u=iT({typed:t}),l=i5({typed:t}),c=oU({typed:t,equalScalar:n}),f=i_({typed:t,DenseMatrix:o}),p=i6({typed:t,DenseMatrix:o}),m=iI({typed:t,matrix:r,concat:s});/**
   * Subtract two values, `x - y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.subtract(x, y)
   *
   * Examples:
   *
   *    math.subtract(5.3, 2)        // returns number 3.3
   *
   *    const a = math.complex(2, 3)
   *    const b = math.complex(4, 1)
   *    math.subtract(a, b)          // returns Complex -2 + 2i
   *
   *    math.subtract([5, 7, 4], 4)  // returns Array [1, 3, 0]
   *
   *    const c = math.unit('2.1 km')
   *    const d = math.unit('500m')
   *    math.subtract(c, d)          // returns Unit 1.6 km
   *
   * See also:
   *
   *    add
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Initial value
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Value to subtract from `x`
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Subtraction of `x` and `y`
   */return t(pN,{"any, any":i},m({elop:i,SS:c,DS:u,SD:l,Ss:p,sS:f}))}),pD="subtractScalar",pE=ta(pD,["typed"],e=>{var{typed:t}=e;/**
   * Subtract two scalar values, `x - y`.
   * This function is meant for internal use: it is used by the public function
   * `subtract`
   *
   * This function does not support collections (Array or Matrix).
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value
   * @param  {number | BigNumber | Fraction | Complex} y          Second value to be subtracted from `x`
   * @return {number | BigNumber | Fraction | Complex | Unit}     Difference of `x` and `y`
   * @private
   */return t(pD,{"number, number":nJ,"Complex, Complex":function(e,t){return e.sub(t)},"BigNumber, BigNumber":function(e,t){return e.minus(t)},"Fraction, Fraction":function(e,t){return e.sub(t)},"Unit, Unit":t.referToSelf(e=>(r,n)=>{if(null===r.value||void 0===r.value)throw Error("Parameter x contains a unit with undefined value");if(null===n.value||void 0===n.value)throw Error("Parameter y contains a unit with undefined value");if(!r.equalBase(n))throw Error("Units do not match");var i=r.clone();return i.value=t.find(e,[i.valueType(),n.valueType()])(i.value,n.value),i.fixPrefix=!1,i})})}),pA="sylvester",pS=ta(pA,["typed","schur","matrixFromColumns","matrix","multiply","range","concat","transpose","index","subset","add","subtract","identity","lusolve","abs"],e=>{var{typed:t,schur:r,matrixFromColumns:n,matrix:i,multiply:a,range:o,concat:s,transpose:u,index:l,subset:c,add:f,subtract:p,identity:m,lusolve:d,abs:h}=e;/**
   *
   * Solves the real-valued Sylvester equation AX+XB=C for X, where A, B and C are
   * matrices of appropriate dimensions, being A and B squared. Notice that other
   * equivalent definitions for the Sylvester equation exist and this function
   * assumes the one presented in the original publication of the the Bartels-
   * Stewart algorithm, which is implemented by this function.
   * https://en.wikipedia.org/wiki/Sylvester_equation
   *
   * Syntax:
   *
   *     math.sylvester(A, B, C)
   *
   * Examples:
   *
   *     const A = [[-1, -2], [1, 1]]
   *     const B = [[2, -1], [1, -2]]
   *     const C = [[-3, 2], [3, 0]]
   *     math.sylvester(A, B, C)      // returns DenseMatrix [[-0.25, 0.25], [1.5, -1.25]]
   *
   * See also:
   *
   *     schur, lyap
   *
   * @param {Matrix | Array} A  Matrix A
   * @param {Matrix | Array} B  Matrix B
   * @param {Matrix | Array} C  Matrix C
   * @return {Matrix | Array}   Matrix X, solving the Sylvester equation
   */return t(pA,{"Matrix, Matrix, Matrix":g,"Array, Matrix, Matrix":function(e,t,r){return g(i(e),t,r)},"Array, Array, Matrix":function(e,t,r){return g(i(e),i(t),r)},"Array, Matrix, Array":function(e,t,r){return g(i(e),t,i(r))},"Matrix, Array, Matrix":function(e,t,r){return g(e,i(t),r)},"Matrix, Array, Array":function(e,t,r){return g(e,i(t),i(r))},"Matrix, Matrix, Array":function(e,t,r){return g(e,t,i(r))},"Array, Array, Array":function(e,t,r){return g(i(e),i(t),i(r)).toArray()}});function g(e,t,g){for(var y=t.size()[0],v=e.size()[0],x=r(e),b=x.T,N=x.U,w=r(a(-1,t)),D=w.T,E=w.U,A=a(a(u(N),g),E),S=o(0,v),C=[],M=(e,t)=>s(e,t,1),F=(e,t)=>s(e,t,0),B=0;B<y;B++)if(B<y-1&&h(c(D,l(B+1,B)))>1e-5){for(var T=F(c(A,l(S,B)),c(A,l(S,B+1))),O=0;O<B;O++)T=f(T,F(a(C[O],c(D,l(O,B))),a(C[O],c(D,l(O,B+1)))));var _=a(m(v),a(-1,c(D,l(B,B)))),z=a(m(v),a(-1,c(D,l(B+1,B)))),q=a(m(v),a(-1,c(D,l(B,B+1)))),k=a(m(v),a(-1,c(D,l(B+1,B+1)))),I=d(F(M(f(b,_),z),M(q,f(b,k))),T);C[B]=I.subset(l(o(0,v),0)),C[B+1]=I.subset(l(o(v,2*v),0)),B++}else{for(var R=c(A,l(S,B)),P=0;P<B;P++)R=f(R,a(C[P],c(D,l(P,B))));var j=p(b,a(c(D,l(B,B)),m(v)));C[B]=d(j,R)}return a(N,a(i(n(...C)),u(E)))}}),pC=ta("tan",["typed"],e=>{var{typed:t}=e,r=o8({typed:t});/**
   * Calculate the tangent of a value. `tan(x)` is equal to `sin(x) / cos(x)`.
   *
   * To avoid confusion with the matrix tangent, this function does not apply
   * to matrices.
   *
   * Syntax:
   *
   *    math.tan(x)
   *
   * Examples:
   *
   *    math.tan(0.5)                    // returns number 0.5463024898437905
   *    math.sin(0.5) / math.cos(0.5)    // returns number 0.5463024898437905
   *    math.tan(math.pi / 4)            // returns number 1
   *    math.tan(math.unit(45, 'deg'))   // returns number 1
   *
   * See also:
   *
   *    atan, sin, cos
   *
   * @param {number | BigNumber | Complex | Unit} x  Function input
   * @return {number | BigNumber | Complex} Tangent of x
   */return t("tan",{number:Math.tan,"Complex | BigNumber":e=>e.tan()},r)}),pM=ta("tanh",["typed"],e=>{var{typed:t}=e;/**
   * Calculate the hyperbolic tangent of a value,
   * defined as `tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1)`.
   *
   * To avoid confusion with matrix hyperbolic tangent, this function does
   * not apply to matrices.
   *
   * Syntax:
   *
   *    math.tanh(x)
   *
   * Examples:
   *
   *    // tanh(x) = sinh(x) / cosh(x) = 1 / coth(x)
   *    math.tanh(0.5)                   // returns 0.46211715726000974
   *    math.sinh(0.5) / math.cosh(0.5)  // returns 0.46211715726000974
   *    1 / math.coth(0.5)               // returns 0.46211715726000974
   *
   * See also:
   *
   *    sinh, cosh, coth
   *
   * @param {number | BigNumber | Complex} x  Function input
   * @return {number | BigNumber | Complex} Hyperbolic tangent of x
   */return t("tanh",{number:ek,"Complex | BigNumber":e=>e.tanh()})}),pF=ta("to",["typed","matrix","concat"],e=>{var{typed:t,matrix:r,concat:n}=e,i=iI({typed:t,matrix:r,concat:n});/**
   * Change the unit of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.to(x, unit)
   *
   * Examples:
   *
   *    math.to(math.unit('2 inch'), 'cm')             // returns Unit 5.08 cm
   *    math.to(math.unit('2 inch'), math.unit('cm'))  // returns Unit 5.08 cm
   *    math.to(math.unit(16, 'bytes'), 'bits')        // returns Unit 128 bits
   *
   * See also:
   *
   *    unit
   *
   * @param {Unit | Array | Matrix} x     The unit to be converted.
   * @param {Unit | Array | Matrix} unit  New unit. Can be a string like "cm"
   *                                      or a unit without value.
   * @return {Unit | Array | Matrix} value with changed, fixed unit.
   */return t("to",{"Unit, Unit | string":(e,t)=>e.to(t)},i({Ds:!0}))}),pB=ta("trace",["typed","matrix","add"],e=>{var{typed:t,matrix:r,add:n}=e;/**
   * Calculate the trace of a matrix: the sum of the elements on the main
   * diagonal of a square matrix.
   *
   * Syntax:
   *
   *    math.trace(x)
   *
   * Examples:
   *
   *    math.trace([[1, 2], [3, 4]]) // returns 5
   *
   *    const A = [
   *      [1, 2, 3],
   *      [-1, 2, 3],
   *      [2, 0, 3]
   *    ]
   *    math.trace(A) // returns 6
   *
   * See also:
   *
   *    diag
   *
   * @param {Array | Matrix} x  A matrix
   *
   * @return {number} The trace of `x`
   */return t("trace",{Array:function(e){// use dense matrix implementation
return i(r(e))},SparseMatrix:function(e){// matrix arrays
var t=e._values,r=e._index,i=e._ptr,a=e._size,o=a[0],s=a[1];// matrix must be square
if(o===s){// calulate sum
var u=0;// check we have data (avoid looping columns)
if(t.length>0)for(var l=0;l<s;l++)// loop k within [k0, k1[
for(var c=i[l],f=i[l+1],p=c;p<f;p++){// row index
var m=r[p];// check row
if(m===l){// accumulate value
u=n(u,t[p]);break}if(m>l)break}// return trace
return u}throw RangeError("Matrix must be square (size: "+eP(a)+")")},DenseMatrix:i,any:J});function i(e){// matrix size & data
var t=e._size,r=e._data;// process dimensions
switch(t.length){case 1:// vector
if(1===t[0])return J(r[0]);throw RangeError("Matrix must be square (size: "+eP(t)+")");case 2:// two dimensional
var i=t[0];if(i===t[1]){// loop diagonal
for(var a=0,o=0;o<i;o++)a=n(a,r[o][o]);// return trace
return a}throw RangeError("Matrix must be square (size: "+eP(t)+")");default:// multi dimensional
throw RangeError("Matrix must be two dimensional (size: "+eP(t)+")")}}}),pT="transpose",pO=ta(pT,["typed","matrix"],e=>{var{typed:t,matrix:r}=e;/**
   * Transpose a matrix. All values of the matrix are reflected over its
   * main diagonal. Only applicable to two dimensional matrices containing
   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional
   * vectors and scalars return the input unchanged.
   *
   * Syntax:
   *
   *     math.transpose(x)
   *
   * Examples:
   *
   *     const A = [[1, 2, 3], [4, 5, 6]]
   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]
   *
   * See also:
   *
   *     diag, inv, subset, squeeze
   *
   * @param {Array | Matrix} x  Matrix to be transposed
   * @return {Array | Matrix}   The transposed matrix
   */return t(pT,{Array:e=>n(r(e)).valueOf(),Matrix:n,any:J// scalars
});function n(e){// matrix size
var t,r=e.size();// process dimensions
switch(r.length){case 1:// vector
t=e.clone();break;case 2:// rows and columns
var n=r[0],i=r[1];// check columns
if(0===i)throw RangeError("Cannot transpose a 2D matrix with no columns (size: "+eP(r)+")");// process storage format
switch(e.storage()){case"dense":t=function(e,t,r){// loop columns
for(var n,i=e._data,a=[],o=0;o<r;o++){// initialize row
n=a[o]=[];// loop rows
for(var s=0;s<t;s++)n[s]=J(i[s][o])}// return matrix
return e.createDenseMatrix({data:a,size:[r,t],datatype:e._datatype})}(e,n,i);break;case"sparse":t=function(e,t,r){for(var n,i,a,o=e._values,s=e._index,u=e._ptr,l=o?[]:void 0,c=[],f=[],p=[],m=0;m<t;m++)p[m]=0;// loop values in matrix
for(n=0,i=s.length;n<i;n++)p[s[n]]++;// initialize cptr with the cummulative sum of row counts
for(var d=0,h=0;h<t;h++)// update cptr
f.push(d),// update sum
d+=p[h],// update w
p[h]=f[h];// loop columns
for(// update cptr
f.push(d),a=0;a<r;a++)for(var g=u[a],y=u[a+1],v=g;v<y;v++){// C values & index
var x=p[s[v]]++;// C[j, i] = A[i, j]
c[x]=a,o&&(l[x]=J(o[v]))}// return matrix
return e.createSparseMatrix({values:l,index:c,ptr:f,size:[r,t],datatype:e._datatype})}(e,n,i)}break;default:// multi dimensional
throw RangeError("Matrix must be a vector or two dimensional (size: "+eP(r)+")")}return t}}),p_=function(){return(// initially, return the original instance of typed-function
// consecutively, return a new instance from typed.create.
p_=/*@__PURE__*/e(rm).create,/*@__PURE__*/e(rm))},pz=ta("typed",["?BigNumber","?Complex","?DenseMatrix","?Fraction"],function(e){var{BigNumber:t,Complex:r,DenseMatrix:n,Fraction:i}=e,a=p_();return(// define all types. The order of the types determines in which order function
// arguments are type-checked (so for performance it's important to put the
// most used types first).
a.clear(),a.addTypes([{name:"number",test:l},{name:"Complex",test:f},{name:"BigNumber",test:c},{name:"Fraction",test:p},{name:"Unit",test:m},// The following type matches a valid variable name, i.e., an alphanumeric
// string starting with an alphabetic character. It is used (at least)
// in the definition of the derivative() function, as the argument telling
// what to differentiate over must (currently) be a variable.
{name:"identifier",test:e=>d&&/^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(e)},{name:"string",test:d},{name:"Chain",test:W},{name:"Array",test:h},{name:"Matrix",test:g},{name:"DenseMatrix",test:v},{name:"SparseMatrix",test:x},{name:"Range",test:b},{name:"Index",test:N},{name:"boolean",test:w},{name:"ResultSet",test:D},{name:"Help",test:E},{name:"function",test:A},{name:"Date",test:S},{name:"RegExp",test:C},{name:"null",test:F},{name:"undefined",test:B},{name:"AccessorNode",test:T},{name:"ArrayNode",test:O},{name:"AssignmentNode",test:_},{name:"BlockNode",test:z},{name:"ConditionalNode",test:q},{name:"ConstantNode",test:k},{name:"FunctionNode",test:P},{name:"FunctionAssignmentNode",test:R},{name:"IndexNode",test:j},{name:"Node",test:U},{name:"ObjectNode",test:L},{name:"OperatorNode",test:$},{name:"ParenthesisNode",test:H},{name:"RangeNode",test:Z},{name:"RelationalNode",test:G},{name:"SymbolNode",test:V},{name:"Map",test:rl},{name:"Object",test:M}// order 'Object' last, it matches on other classes too
]),a.addConversions([{from:"number",to:"BigNumber",convert:function(e){// note: conversion from number to BigNumber can fail if x has >15 digits
if(t||pq(e),e.toExponential().replace(/e.*$/,"")// remove exponential notation
.replace(/^0\.?0*|\./,"")// remove decimal point and leading zeros
.length>15)throw TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: "+e+"). Use function bignumber(x) to convert to BigNumber.");return new t(e)}},{from:"number",to:"Complex",convert:function(e){return r||pk(e),new r(e,0)}},{from:"BigNumber",to:"Complex",convert:function(e){return r||pk(e),new r(e.toNumber(),0)}},{from:"Fraction",to:"BigNumber",convert:function(e){throw TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.")}},{from:"Fraction",to:"Complex",convert:function(e){return r||pk(e),new r(e.valueOf(),0)}},{from:"number",to:"Fraction",convert:function(e){i||pI(e);var t=new i(e);if(t.valueOf()!==e)throw TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: "+e+"). Use function fraction(x) to convert to Fraction.");return t}},{// FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
//  from: 'Fraction',
//  to: 'number',
//  convert: function (x) {
//    return x.valueOf()
//  }
// }, {
from:"string",to:"number",convert:function(e){var t=Number(e);if(isNaN(t))throw Error('Cannot convert "'+e+'" to a number');return t}},{from:"string",to:"BigNumber",convert:function(e){t||pq(e);try{return new t(e)}catch(t){throw Error('Cannot convert "'+e+'" to BigNumber')}}},{from:"string",to:"Fraction",convert:function(e){i||pI(e);try{return new i(e)}catch(t){throw Error('Cannot convert "'+e+'" to Fraction')}}},{from:"string",to:"Complex",convert:function(e){r||pk(e);try{return new r(e)}catch(t){throw Error('Cannot convert "'+e+'" to Complex')}}},{from:"boolean",to:"number",convert:function(e){return+e}},{from:"boolean",to:"BigNumber",convert:function(e){return t||pq(e),new t(+e)}},{from:"boolean",to:"Fraction",convert:function(e){return i||pI(e),new i(+e)}},{from:"boolean",to:"string",convert:function(e){return String(e)}},{from:"Array",to:"Matrix",convert:function(e){return n||function(){throw Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided")}(),new n(e)}},{from:"Matrix",to:"Array",convert:function(e){return e.valueOf()}}]),// Provide a suggestion on how to call a function elementwise
// This was added primarily as guidance for the v10 -> v11 transition,
// and could potentially be removed in the future if it no longer seems
// to be helpful.
a.onMismatch=(e,t,r)=>{var n=a.createError(e,t,r);if(["wrongType","mismatch"].includes(n.data.category)&&1===t.length&&y(t[0])&&// check if the function can be unary:
r.some(e=>!e.params.includes(","))){var i=TypeError("Function '".concat(e,"' doesn't apply to matrices. To call it ")+"elementwise on a matrix 'M', try 'map(M, ".concat(e,")'."));throw i.data=n.data,i}throw n},// Provide a suggestion on how to call a function elementwise
// This was added primarily as guidance for the v10 -> v11 transition,
// and could potentially be removed in the future if it no longer seems
// to be helpful.
a.onMismatch=(e,t,r)=>{var n=a.createError(e,t,r);if(["wrongType","mismatch"].includes(n.data.category)&&1===t.length&&y(t[0])&&// check if the function can be unary:
r.some(e=>!e.params.includes(","))){var i=TypeError("Function '".concat(e,"' doesn't apply to matrices. To call it ")+"elementwise on a matrix 'M', try 'map(M, ".concat(e,")'."));throw i.data=n.data,i}throw n},a)});function pq(e){throw Error("Cannot convert value ".concat(e," into a BigNumber: no class 'BigNumber' provided"))}function pk(e){throw Error("Cannot convert value ".concat(e," into a Complex number: no class 'Complex' provided"))}function pI(e){throw Error("Cannot convert value ".concat(e," into a Fraction, no class 'Fraction' provided."))}var pR="typeOf",pP=ta(pR,["typed"],e=>{var{typed:t}=e;/**
   * Determine the type of an entity.
   *
   * Syntax:
   *
   *    math.typeOf(x)
   *
   * Examples:
   *
   *    // This list is intended to include all relevant types, for testing
   *    // purposes:
   *    math.typeOf(3.5)                      // returns 'number'
   *    math.typeOf(math.complex('2-4i'))     // returns 'Complex'
   *    math.typeOf(math.unit('45 deg'))      // returns 'Unit'
   *    math.typeOf('hello world')            // returns 'string'
   *    math.typeOf(null)                     // returns 'null'
   *    math.typeOf(true)                     // returns 'boolean'
   *    math.typeOf([1, 2, 3])                // returns 'Array'
   *    math.typeOf(new Date())               // returns 'Date'
   *    math.typeOf(function () {})           // returns 'function'
   *    math.typeOf({a: 2, b: 3})             // returns 'Object'
   *    math.typeOf(/a regexp/)               // returns 'RegExp'
   *    math.typeOf(undefined)                // returns 'undefined'
   *    math.typeOf(math.bignumber('23e99'))  // returns 'BigNumber'
   *    math.typeOf(math.chain(2))            // returns 'Chain'
   *    math.typeOf(math.fraction(1, 3))      // returns 'Fraction'
   *    math.typeOf(math.help('sqrt'))        // returns 'Help'
   *    math.typeOf(math.index(1, 3))         // returns 'Index'
   *    math.typeOf(math.matrix([[1],[3]]))   // returns 'DenseMatrix'
   *    math.typeOf(math.matrix([],'sparse')) // returns 'SparseMatrix'
   *    math.typeOf(new math.Range(0, 10))    // returns 'Range'
   *    math.typeOf(math.evaluate('a=2\na'))  // returns 'ResultSet'
   *    math.typeOf(math.parse('A[2]'))       // returns 'AccessorNode'
   *    math.typeOf(math.parse('[1,2,3]'))    // returns 'ArrayNode'
   *    math.typeOf(math.parse('x=2'))        // returns 'AssignmentNode'
   *    math.typeOf(math.parse('a=2; b=3'))   // returns 'BlockNode'
   *    math.typeOf(math.parse('x<0?-1:1'))   // returns 'ConditionalNode'
   *    math.typeOf(math.parse('2.3'))        // returns 'ConstantNode'
   *    math.typeOf(math.parse('f(x)=x^2'))   // returns 'FunctionAssignmentNode'
   *    math.typeOf(math.parse('sqrt(4)'))    // returns 'FunctionNode'
   *    math.typeOf(math.parse('A[2]').index) // returns 'IndexNode'
   *    math.typeOf(math.parse('{a:2}'))      // returns 'ObjectNode'
   *    math.typeOf(math.parse('(2+3)'))      // returns 'ParenthesisNode'
   *    math.typeOf(math.parse('1:10'))       // returns 'RangeNode'
   *    math.typeOf(math.parse('a<b<c'))      // returns 'RelationalNode'
   *    math.typeOf(math.parse('x'))          // returns 'SymbolNode'
   *
   * @param {*} x     The variable for which to test the type.
   * @return {string} Returns the name of the type. Primitive types are lower case,
   *                  non-primitive types are upper-camel-case.
   *                  For example 'number', 'string', 'Array', 'Date'.
   */return t(pR,{any:Y})}),pj="unaryMinus",pU=ta(pj,["typed"],e=>{var{typed:t}=e;/**
   * Inverse the sign of a value, apply a unary minus operation.
   *
   * For matrices, the function is evaluated element wise. Boolean values and
   * strings will be converted to a number. For complex numbers, both real and
   * complex value are inverted.
   *
   * Syntax:
   *
   *    math.unaryMinus(x)
   *
   * Examples:
   *
   *    math.unaryMinus(3.5)      // returns -3.5
   *    math.unaryMinus(-4.2)     // returns 4.2
   *
   * See also:
   *
   *    add, subtract, unaryPlus
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Number to be inverted.
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Returns the value with inverted sign.
   */return t(pj,{number:nQ,"Complex | BigNumber | Fraction":e=>e.neg(),Unit:t.referToSelf(e=>r=>{var n=r.clone();return n.value=t.find(e,n.valueType())(r.value),n}),// deep map collection, skip zeros since unaryMinus(0) = 0
"Array | Matrix":t.referToSelf(e=>t=>tq(t,e,!0))})}),pL="unaryPlus",p$=ta(pL,["typed","config","BigNumber"],e=>{var{typed:t,config:r,BigNumber:n}=e;/**
   * Unary plus operation.
   * Boolean values and strings will be converted to a number, numeric values will be returned as is.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.unaryPlus(x)
   *
   * Examples:
   *
   *    math.unaryPlus(3.5)      // returns 3.5
   *    math.unaryPlus(1)     // returns 1
   *
   * See also:
   *
   *    unaryMinus, add, subtract
   *
   * @param  {number | BigNumber | Fraction | string | Complex | Unit | Array | Matrix} x
   *            Input value
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
   *            Returns the input value when numeric, converts to a number when input is non-numeric.
   */return t(pL,{number:nK,Complex:function(e){return e;// complex numbers are immutable
},BigNumber:function(e){return e;// bignumbers are immutable
},Fraction:function(e){return e;// fractions are immutable
},Unit:function(e){return e.clone()},// deep map collection, skip zeros since unaryPlus(0) = 0
"Array | Matrix":t.referToSelf(e=>t=>tq(t,e,!0)),"boolean | string":function(e){// convert to a number or bignumber
return"BigNumber"===r.number?new n(+e):+e}})}),pH="unequal",pZ=ta(pH,["typed","config","equalScalar","matrix","DenseMatrix","concat"],e=>{var{typed:t,config:r,equalScalar:n,matrix:i,DenseMatrix:a,concat:o}=e,s=i5({typed:t}),u=ov({typed:t,DenseMatrix:a}),l=i6({typed:t,DenseMatrix:a}),c=iI({typed:t,matrix:i,concat:o});/**
   * Test whether two values are unequal.
   *
   * The function tests whether the relative difference between x and y is
   * larger than the configured epsilon. The function cannot be used to compare
   * values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * In case of complex numbers, x.re must unequal y.re, or x.im must unequal y.im.
   * Strings are compared by their numerical value.
   *
   * Values `null` and `undefined` are compared strictly, thus `null` is unequal
   * with everything except `null`, and `undefined` is unequal with everything
   * except `undefined`.
   *
   * Syntax:
   *
   *    math.unequal(x, y)
   *
   * Examples:
   *
   *    math.unequal(2 + 2, 3)       // returns true
   *    math.unequal(2 + 2, 4)       // returns false
   *
   *    const a = math.unit('50 cm')
   *    const b = math.unit('5 m')
   *    math.unequal(a, b)           // returns false
   *
   *    const c = [2, 5, 1]
   *    const d = [2, 7, 1]
   *
   *    math.unequal(c, d)           // returns [false, true, false]
   *    math.deepEqual(c, d)         // returns false
   *
   *    math.unequal(0, null)        // returns true
   * See also:
   *
   *    equal, deepEqual, smaller, smallerEq, larger, largerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit | string | Array | Matrix | undefined} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit | string | Array | Matrix | undefined} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the compared values are unequal, else returns false
   */return t(pH,pG({typed:t,equalScalar:n}),c({elop:function(e,t){return!n(e,t)},SS:u,DS:s,Ss:l}))}),pG=ta(pH,["typed","equalScalar"],e=>{var{typed:t,equalScalar:r}=e;return t(pH,{"any, any":function(e,t){return(// strict equality for null and undefined?
null===e?null!==t:null===t?null!==e:void 0===e?void 0!==t:void 0===t?void 0!==e:!r(e,t))}})});function pV(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function pW(t){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?pV(Object(n),!0).forEach(function(r){/*@__PURE__*/e(et)(t,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):pV(Object(n)).forEach(function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))})}return t}var pY=ta("Unit",["?on","config","addScalar","subtractScalar","multiplyScalar","divideScalar","pow","abs","fix","round","equal","isNumeric","format","number","Complex","BigNumber","Fraction"],t=>{var r,n,i,{on:a,config:s,addScalar:u,subtractScalar:l,multiplyScalar:c,divideScalar:p,pow:d,abs:h,fix:g,round:y,equal:v,isNumeric:x,format:b,number:N,Complex:w,BigNumber:D,Fraction:E}=t;/**
   * A unit can be constructed in the following ways:
   *
   *     const a = new Unit(value, valuelessUnit)
   *     const b = new Unit(null, valuelessUnit)
   *     const c = Unit.parse(str)
   *
   * Example usage:
   *
   *     const a = new Unit(5, 'cm')               // 50 mm
   *     const b = Unit.parse('23 kg')             // 23 kg
   *     const c = math.in(a, new Unit(null, 'm')  // 0.05 m
   *     const d = new Unit(9.81, "m/s^2")         // 9.81 m/s^2
   *
   * @class Unit
   * @constructor Unit
   * @param {number | BigNumber | Fraction | Complex | boolean} [value]  A value like 5.2
   * @param {string | Unit} valuelessUnit   A unit without value. Can have prefix, like "cm"
   */function A(t,r){if(!(this instanceof A))throw Error("Constructor must be called with the new operator");if(!(null==t||x(t)||f(t)))throw TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");if(this.fixPrefix=!1,// best prefix but leave it as initially provided.
// fixPrefix is set true by the method Unit.to
// The justification behind this is that if the constructor is explicitly called,
// the caller wishes the units to be returned exactly as supplied.
this.skipAutomaticSimplification=!0,void 0===r)this.units=[],this.dimensions=q.map(e=>0);else if("string"==typeof r){var n=A.parse(r);this.units=n.units,this.dimensions=n.dimensions}else if(m(r)&&null===r.value)// clone from valuelessUnit
this.fixPrefix=r.fixPrefix,this.skipAutomaticSimplification=r.skipAutomaticSimplification,this.dimensions=r.dimensions.slice(0),this.units=r.units.map(t=>/*@__PURE__*/e(o)({},t));else throw TypeError("Second parameter in Unit constructor must be a string or valueless Unit");this.value=this._normalize(t)}function S(){for(;" "===i||"	"===i;)M()}function C(e){return e>="0"&&e<="9"}function M(){n++,i=r.charAt(n)}function F(e){n=e,i=r.charAt(n)}function B(){var e,t="",r=n;if("+"===i?M():"-"===i&&(t+=i,M()),!((e=i)>="0"&&e<="9"||"."===e))return(// a + or - must be followed by a digit
F(r),null);// get number, can have a single dot
if("."===i){if(t+=i,M(),!C(i))return(// this is no legal number, it is just a dot
F(r),null)}else{for(;C(i);)t+=i,M();"."===i&&(t+=i,M())}for(;C(i);)t+=i,M();// check for exponential notation like "2.3e-4" or "1.23e50"
if("E"===i||"e"===i){// The grammar branches here. This could either be part of an exponent or the start of a unit that begins with the letter e, such as "4exabytes"
var a="",o=n;// Scientific notation MUST be followed by an exponent (otherwise we assume it is not scientific notation)
if(a+=i,M(),("+"===i||"-"===i)&&(a+=i,M()),!C(i))return(// The e or E must belong to something else, so return the number without the e or E.
F(o),t);for(// We can now safely say that this is scientific notation.
t+=a;C(i);)t+=i,M()}return t}function T(e){return i===e?(M(),e):null}/**
   * Attach type information
   */Object.defineProperty(A,"name",{value:"Unit"}),A.prototype.constructor=A,A.prototype.type="Unit",A.prototype.isUnit=!0,/**
   * Parse a string into a unit. The value of the unit is parsed as number,
   * BigNumber, or Fraction depending on the math.js config setting `number`.
   *
   * Throws an exception if the provided string does not contain a valid unit or
   * cannot be parsed.
   * @memberof Unit
   * @param {string} str        A string like "5.2 inch", "4e2 cm/s^2"
   * @return {Unit} unit
   */A.parse=function(e,t){if(t=t||{},n=-1,i="","string"!=typeof(r=e))throw TypeError("Invalid argument in Unit.parse, string expected");var a=new A;a.units=[];var o=1,u=!1;// A unit should follow this pattern:
// [number] ...[ [*/] unit[^number] ]
// unit[^number] ... [ [*/] unit[^number] ]
// Rules:
// number is any floating point number.
// unit is any alphanumeric string beginning with an alpha. Units with names like e3 should be avoided because they look like the exponent of a floating point number!
// The string may optionally begin with a number.
// Each unit may optionally be followed by ^number.
// Whitespace or a forward slash is recommended between consecutive units, although the following technically is parseable:
//   2m^2kg/s^2
// it is not good form. If a unit starts with e, then it could be confused as a floating point number:
//   4erg
M(),S();// Optional number at the start of the string
var l=B(),c=null;if(l){if("BigNumber"===s.number)c=new D(l);else if("Fraction"===s.number)try{// not all numbers can be turned in Fractions, for example very small numbers not
c=new E(l)}catch(e){c=parseFloat(l)}else c=parseFloat(l);S(),T("*")?(o=1,u=!0):T("/")&&(o=-1,u=!0)}for(// Stack to keep track of powerMultipliers applied to each parentheses group
var f=[],p=1;;){// Check for and consume opening parentheses, pushing powerMultiplierCurrent to the stack
// A '(' will always appear directly before a unit.
for(S();"("===i;)f.push(o),p*=o,o=1,M(),S();// Is there something here?
var m=void 0;if(i){var d=i;if(null===(m=function(){// Alphanumeric characters only; matches [a-zA-Z0-9]
for(var e="";C(i)||A.isValidAlpha(i);)e+=i,M();// Must begin with [a-zA-Z]
var t=e.charAt(0);return A.isValidAlpha(t)?e:null}()))throw SyntaxError('Unexpected "'+d+'" in "'+r+'" at index '+n.toString())}else break;// Verify the unit exists and get the prefix (if any)
var h=O(m);if(null===h)throw SyntaxError('Unit "'+m+'" not found.');var g=o*p;if(// Is there a "^ number"?
S(),T("^")){S();var y=B();if(null===y)throw SyntaxError('In "'+e+'", "^" must be followed by a floating-point number');g*=y}// Add the unit to the list
a.units.push({unit:h.unit,prefix:h.prefix,power:g});for(var v=0;v<q.length;v++)a.dimensions[v]+=(h.unit.dimensions[v]||0)*g;for(// Check for and consume closing parentheses, popping from the stack.
// A ')' will always follow a unit.
S();")"===i;){if(0===f.length)throw SyntaxError('Unmatched ")" in "'+r+'" at index '+n.toString());p/=f.pop(),M(),S()}// Replace the unit into the auto unit system
if(// "*" and "/" should mean we are expecting something to come next.
// Is there a forward slash? If so, negate powerMultiplierCurrent. The next unit or paren group is in the denominator.
u=!1,T("*")?(// explicit multiplication
o=1,u=!0):T("/")?(// division
o=-1,u=!0):o=1,h.unit.base){var x=h.unit.base.key;L.auto[x]={unit:h.unit,prefix:h.prefix}}}if(// Has the string been entirely consumed?
S(),i)throw SyntaxError('Could not parse: "'+e+'"');// Is there a trailing slash?
if(u)throw SyntaxError('Trailing characters: "'+e+'"');// Is the parentheses stack empty?
if(0!==f.length)throw SyntaxError('Unmatched "(" in "'+r+'"');// Are there any units at all?
if(0===a.units.length&&!t.allowNoUnits)throw SyntaxError('"'+e+'" contains no units');return a.value=void 0!==c?a._normalize(c):null,a},/**
   * create a copy of this unit
   * @memberof Unit
   * @return {Unit} Returns a cloned version of the unit
   */A.prototype.clone=function(){var e=new A;e.fixPrefix=this.fixPrefix,e.skipAutomaticSimplification=this.skipAutomaticSimplification,e.value=J(this.value),e.dimensions=this.dimensions.slice(0),e.units=[];for(var t=0;t<this.units.length;t++)for(var r in e.units[t]={},this.units[t])K(this.units[t],r)&&(e.units[t][r]=this.units[t][r]);return e},/**
   * Return the type of the value of this unit
   *
   * @memberof Unit
   * @ return {string} type of the value of the unit
   */A.prototype.valueType=function(){return Y(this.value)},/**
   * Return whether the unit is derived (such as m/s, or cm^2, but not N)
   * @memberof Unit
   * @return {boolean} True if the unit is derived
   */A.prototype._isDerived=function(){return 0!==this.units.length&&(this.units.length>1||Math.abs(this.units[0].power-1)>1e-15)},/**
   * Normalize a value, based on its currently set unit(s)
   * @memberof Unit
   * @param {number | BigNumber | Fraction | boolean} value
   * @return {number | BigNumber | Fraction | boolean} normalized value
   * @private
   */A.prototype._normalize=function(e){if(null==e||0===this.units.length)return e;for(var t=e,r=A._getNumberConverter(Y(e)),n=0;n<this.units.length;n++){var i=r(this.units[n].unit.value),a=r(this.units[n].prefix.value),o=r(this.units[n].power);t=c(t,d(c(i,a),o))}return t},/**
   * Denormalize a value, based on its currently set unit(s)
   * @memberof Unit
   * @param {number} value
   * @param {number} [prefixValue]    Optional prefix value to be used (ignored if this is a derived unit)
   * @return {number} denormalized value
   * @private
   */A.prototype._denormalize=function(e,t){if(null==e||0===this.units.length)return e;for(var r=e,n=A._getNumberConverter(Y(e)),i=0;i<this.units.length;i++){var a=n(this.units[i].unit.value),o=n(this.units[i].prefix.value),s=n(this.units[i].power);r=p(r,d(c(a,o),s))}return r};/**
   * Find a unit from a string
   * @memberof Unit
   * @param {string} str              A string like 'cm' or 'inch'
   * @returns {Object | null} result  When found, an object with fields unit and
   *                                  prefix is returned. Else, null is returned.
   * @private
   */var O=sv(e=>{// First, match units names exactly. For example, a user could define 'mm' as 10^-4 m, which is silly, but then we would want 'mm' to match the user-defined unit.
if(K(P,e)){var t=P[e],r=t.prefixes[""];return{unit:t,prefix:r}}for(var n in P)if(K(P,n)&&function(e,t){var r=e.length-t.length,n=e.length;return e.substring(r,n)===t}(e,n)){var i=P[n],a=e.length-n.length,o=e.substring(0,a),s=K(i.prefixes,o)?i.prefixes[o]:void 0;if(void 0!==s)return{unit:i,prefix:s}}return null},{hasher:e=>e[0],limit:100});/**
   * Return the numeric value of this unit if it is dimensionless, has a value, and config.predictable == false; or the original unit otherwise
   * @param {Unit} unit
   * @returns {number | Fraction | BigNumber | Unit}  The numeric value of the unit if conditions are met, or the original unit otherwise
   */function _(e){return e.equalBase(k.NONE)&&null!==e.value&&!s.predictable?e.value:e}/**
   * Test if the given expression is a unit.
   * The unit can have a prefix but cannot have a value.
   * @memberof Unit
   * @param {string} name   A string to be tested whether it is a value less unit.
   *                        The unit can have prefix, like "cm"
   * @return {boolean}      true if the given string is a unit
   */A.isValuelessUnit=function(e){return null!==O(e)},/**
   * check if this unit has given base unit
   * If this unit is a derived unit, this will ALWAYS return false, since by definition base units are not derived.
   * @memberof Unit
   * @param {BASE_UNITS | string | undefined} base
   */A.prototype.hasBase=function(e){if("string"==typeof e&&(e=k[e]),!e)return!1;// All dimensions must be the same
for(var t=0;t<q.length;t++)if(Math.abs((this.dimensions[t]||0)-(e.dimensions[t]||0))>1e-12)return!1;return!0},/**
   * Check if this unit has a base or bases equal to another base or bases
   * For derived units, the exponent on each base also must match
   * @memberof Unit
   * @param {Unit} other
   * @return {boolean} true if equal base
   */A.prototype.equalBase=function(e){// All dimensions must be the same
for(var t=0;t<q.length;t++)if(Math.abs((this.dimensions[t]||0)-(e.dimensions[t]||0))>1e-12)return!1;return!0},/**
   * Check if this unit equals another unit
   * @memberof Unit
   * @param {Unit} other
   * @return {boolean} true if both units are equal
   */A.prototype.equals=function(e){return this.equalBase(e)&&v(this.value,e.value)},/**
   * Multiply this unit with another one or with a scalar
   * @memberof Unit
   * @param {Unit} other
   * @return {Unit} product of this unit and the other unit
   */A.prototype.multiply=function(e){for(var t=this.clone(),r=m(e)?e:new A(e),n=0;n<q.length;n++)t.dimensions[n]=(this.dimensions[n]||0)+(r.dimensions[n]||0);// Append other's units list onto res
for(var i=0;i<r.units.length;i++){// Make a shallow copy of every unit
var a=pW({},r.units[i]);t.units.push(a)}// If at least one operand has a value, then the result should also have a value
if(null!==this.value||null!==r.value){var o=null===this.value?this._normalize(1):this.value,s=null===r.value?r._normalize(1):r.value;t.value=c(o,s)}else t.value=null;return m(e)&&(t.skipAutomaticSimplification=!1),_(t)},/**
   * Divide a number by this unit
   *
   * @memberof Unit
   * @param {numeric} numerator
   * @param {unit} result of dividing numerator by this unit
   */A.prototype.divideInto=function(e){return new A(e).divide(this)},/**
   * Divide this unit by another one
   * @memberof Unit
   * @param {Unit | numeric} other
   * @return {Unit} result of dividing this unit by the other unit
   */A.prototype.divide=function(e){for(var t=this.clone(),r=m(e)?e:new A(e),n=0;n<q.length;n++)t.dimensions[n]=(this.dimensions[n]||0)-(r.dimensions[n]||0);// Invert and append other's units list onto res
for(var i=0;i<r.units.length;i++){// Make a shallow copy of every unit
var a=pW(pW({},r.units[i]),{},{power:-r.units[i].power});t.units.push(a)}// If at least one operand has a value, the result should have a value
if(null!==this.value||null!==r.value){var o=null===this.value?this._normalize(1):this.value,s=null===r.value?r._normalize(1):r.value;t.value=p(o,s)}else t.value=null;return m(e)&&(t.skipAutomaticSimplification=!1),_(t)},/**
   * Calculate the power of a unit
   * @memberof Unit
   * @param {number | Fraction | BigNumber} p
   * @returns {Unit}      The result: this^p
   */A.prototype.pow=function(e){for(var t=this.clone(),r=0;r<q.length;r++)t.dimensions[r]=(this.dimensions[r]||0)*e;// Adjust the power of each unit in the list
for(var n=0;n<t.units.length;n++)t.units[n].power*=e;return null!==t.value?t.value=d(t.value,e):t.value=null,t.skipAutomaticSimplification=!1,_(t)},/**
   * Calculate the absolute value of a unit
   * @memberof Unit
   * @param {number | Fraction | BigNumber} x
   * @returns {Unit}      The result: |x|, absolute value of x
   */A.prototype.abs=function(){var e=this.clone();if(null!==e.value){if(e._isDerived()||0===e.units[0].unit.offset)e.value=h(e.value);else{// To give the correct, but unexpected, results for units with an offset.
// For example, abs(-283.15 degC) = -263.15 degC !!!
// We must take the offset into consideration here
var t=e._numberConverter(),r=c(t(e.units[0].unit.value),t(e.units[0].unit.offset));// convert to Fraction or BigNumber if needed
e.value=l(h(u(e.value,r)),r)}}for(var n in e.units)("VA"===e.units[n].unit.name||"VAR"===e.units[n].unit.name)&&(e.units[n].unit=P.W);return e},/**
   * Convert the unit to a specific unit name.
   * @memberof Unit
   * @param {string | Unit} valuelessUnit   A unit without value. Can have prefix, like "cm"
   * @returns {Unit} Returns a clone of the unit with a fixed prefix and unit.
   */A.prototype.to=function(e){var t,r=null===this.value?this._normalize(1):this.value;if("string"==typeof e)t=A.parse(e);else if(m(e))t=e.clone();else throw Error("String or Unit expected as parameter");if(!this.equalBase(t))throw Error("Units do not match ('".concat(t.toString(),"' != '").concat(this.toString(),"')"));if(null!==t.value)throw Error("Cannot convert to a unit with a value");if(null===this.value||this._isDerived()||this.units[0].unit.offset===t.units[0].unit.offset)t.value=J(r);else{/* Need to adjust value by difference in offset to convert */var n=A._getNumberConverter(Y(r)),i=c(this.units[0].unit.value,this.units[0].unit.offset),a=c(t.units[0].unit.value,t.units[0].unit.offset);// convert to Fraction or BigNumber if needed
t.value=u(r,n(l(i,a)))}return t.fixPrefix=!0,t.skipAutomaticSimplification=!0,t},/**
   * Return the value of the unit when represented with given valueless unit
   * @memberof Unit
   * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
   * @return {number} Returns the unit value as number.
   */// TODO: deprecate Unit.toNumber? It's always better to use toNumeric
A.prototype.toNumber=function(e){return N(this.toNumeric(e))},/**
   * Return the value of the unit in the original numeric type
   * @memberof Unit
   * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
   * @return {number | BigNumber | Fraction} Returns the unit value
   */A.prototype.toNumeric=function(e){var t;return(t=e?this.to(e):this.clone())._isDerived()||0===t.units.length?t._denormalize(t.value):t._denormalize(t.value,t.units[0].prefix.value)},/**
   * Get a string representation of the unit.
   * @memberof Unit
   * @return {string}
   */A.prototype.toString=function(){return this.format()},/**
   * Get a JSON representation of the unit
   * @memberof Unit
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}`
   */A.prototype.toJSON=function(){return{mathjs:"Unit",value:this._denormalize(this.value),unit:this.formatUnits(),fixPrefix:this.fixPrefix}},/**
   * Instantiate a Unit from a JSON object
   * @memberof Unit
   * @param {Object} json  A JSON object structured as:
   *                       `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}`
   * @return {Unit}
   */A.fromJSON=function(e){var t=new A(e.value,e.unit);return t.fixPrefix=e.fixPrefix||!1,t},/**
   * Returns the string representation of the unit.
   * @memberof Unit
   * @return {string}
   */A.prototype.valueOf=A.prototype.toString,/**
   * Simplify this Unit's unit list and return a new Unit with the simplified list.
   * The returned Unit will contain a list of the "best" units for formatting.
   */A.prototype.simplify=function(){var e,t,r=this.clone(),n=[];for(var i in $)if(K($,i)&&r.hasBase(k[i])){e=i;break}if("NONE"===e)r.units=[];else if(e&&K($,e)&&(t=$[e]),t)r.units=[{unit:t.unit,prefix:t.prefix,power:1}];else{for(var a=!1,o=0;o<q.length;o++){var s=q[o];Math.abs(r.dimensions[o]||0)>1e-12&&(K($,s)?n.push({unit:$[s].unit,prefix:$[s].prefix,power:r.dimensions[o]||0}):a=!0)}// Is the proposed unit list "simpler" than the existing one?
n.length<r.units.length&&!a&&(r.units=n)}return r},/**
   * Returns a new Unit in the SI system with the same value as this one
   */A.prototype.toSI=function(){// Multiple units or units with powers are formatted like this:
// 5 (kg m^2) / (s^3 mol)
// Build an representation from the base units of the SI unit system
for(var e=this.clone(),t=[],r=0;r<q.length;r++){var n=q[r];if(Math.abs(e.dimensions[r]||0)>1e-12){if(K(L.si,n))t.push({unit:L.si[n].unit,prefix:L.si[n].prefix,power:e.dimensions[r]||0});else throw Error("Cannot express custom unit "+n+" in SI units")}}return(// Replace this unit list with the proposed list
e.units=t,e.fixPrefix=!0,e.skipAutomaticSimplification=!0,e)},/**
   * Get a string representation of the units of this Unit, without the value. The unit list is formatted as-is without first being simplified.
   * @memberof Unit
   * @return {string}
   */A.prototype.formatUnits=function(){for(var e="",t="",r=0,n=0,i=0;i<this.units.length;i++)this.units[i].power>0?(r++,e+=" "+this.units[i].prefix.name+this.units[i].unit.name,Math.abs(this.units[i].power-1)>1e-15&&(e+="^"+this.units[i].power)):this.units[i].power<0&&n++;if(n>0)for(var a=0;a<this.units.length;a++)this.units[a].power<0&&(r>0?(t+=" "+this.units[a].prefix.name+this.units[a].unit.name,Math.abs(this.units[a].power+1)>1e-15&&(t+="^"+-this.units[a].power)):t+=" "+this.units[a].prefix.name+this.units[a].unit.name+"^"+this.units[a].power);// Remove leading " "
e=e.substr(1),t=t.substr(1),r>1&&n>0&&(e="("+e+")"),n>1&&r>0&&(t="("+t+")");var o=e;return r>0&&n>0&&(o+=" / "),o+=t},/**
   * Get a string representation of the Unit, with optional formatting options.
   * @memberof Unit
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @return {string}
   */A.prototype.format=function(e){// Simplfy the unit list, unless it is valueless or was created directly in the
// constructor or as the result of to or toSI
var t=this.skipAutomaticSimplification||null===this.value?this.clone():this.simplify(),r=!1;for(var n in void 0!==t.value&&null!==t.value&&f(t.value)&&(r=1e-14>Math.abs(t.value.re)),t.units)K(t.units,n)&&t.units[n].unit&&("VA"===t.units[n].unit.name&&r?t.units[n].unit=P.VAR:"VAR"!==t.units[n].unit.name||r||(t.units[n].unit=P.VA));1===t.units.length&&!t.fixPrefix&&1e-14>Math.abs(t.units[0].power-Math.round(t.units[0].power))&&(t.units[0].prefix=t._bestPrefix());var i=t._denormalize(t.value),a=null!==t.value?b(i,e||{}):"",o=t.formatUnits();return t.value&&f(t.value)&&(a="("+a+")"),o.length>0&&a.length>0&&(a+=" "),a+=o},/**
   * Calculate the best prefix using current value.
   * @memberof Unit
   * @returns {Object} prefix
   * @private
   */A.prototype._bestPrefix=function(){if(1!==this.units.length||Math.abs(this.units[0].power-Math.round(this.units[0].power))>=1e-14)throw Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");// find the best prefix value (resulting in the value of which
// the absolute value of the log10 is closest to zero,
// though with a little offset of 1.2 for nicer values: you get a
// sequence 1mm 100mm 500mm 0.6m 1m 10m 100m 500m 0.6km 1km ...
// Note: the units value can be any numeric type, but to find the best
// prefix it's enough to work with limited precision of a regular number
// Update: using mathjs abs since we also allow complex numbers
var e=null!==this.value?h(this.value):0,t=h(this.units[0].unit.value),r=this.units[0].prefix;if(0===e)return r;var n=this.units[0].power,i=Math.log(e/Math.pow(r.value*t,n))/Math.LN10-1.2;if(i>-2.200001&&i<1.800001)return r;// Allow the original prefix
i=Math.abs(i);var a=this.units[0].unit.prefixes;for(var o in a)if(K(a,o)){var s=a[o];if(s.scientific){var u=Math.abs(Math.log(e/Math.pow(s.value*t,n))/Math.LN10-1.2);(u<i||u===i&&s.name.length<r.name.length)&&(// choose the prefix with the smallest diff, or if equal, choose the one
// with the shortest name (can happen with SHORTLONG for example)
r=s,i=u)}}return r},/**
   * Returns an array of units whose sum is equal to this unit
   * @memberof Unit
   * @param {Array} [parts] An array of strings or valueless units.
   *
   *   Example:
   *
   *   const u = new Unit(1, 'm')
   *   u.splitUnit(['feet', 'inch'])
   *     [ 3 feet, 3.3700787401575 inch ]
   *
   * @return {Array} An array of units.
   */A.prototype.splitUnit=function(e){for(var t=this.clone(),r=[],n=0;n<e.length&&(// Convert x to the requested unit
t=t.to(e[n]),n!==e.length-1);n++){// Get the numeric value of this unit
var i=t.toNumeric(),a=y(i),o=new A(v(a,i)?a:g(t.toNumeric()),e[n].toString());r.push(o),t=l(t,o)}for(var s=0,c=0;c<r.length;c++)s=u(s,r[c].value);return v(s,this.value)&&(t.value=0),r.push(t),r};var z={NONE:{"":{name:"",value:1,scientific:!0}},SHORT:{"":{name:"",value:1,scientific:!0},da:{name:"da",value:10,scientific:!1},h:{name:"h",value:100,scientific:!1},k:{name:"k",value:1e3,scientific:!0},M:{name:"M",value:1e6,scientific:!0},G:{name:"G",value:1e9,scientific:!0},T:{name:"T",value:1e12,scientific:!0},P:{name:"P",value:1e15,scientific:!0},E:{name:"E",value:1e18,scientific:!0},Z:{name:"Z",value:1e21,scientific:!0},Y:{name:"Y",value:1e24,scientific:!0},d:{name:"d",value:.1,scientific:!1},c:{name:"c",value:.01,scientific:!1},m:{name:"m",value:.001,scientific:!0},u:{name:"u",value:1e-6,scientific:!0},n:{name:"n",value:1e-9,scientific:!0},p:{name:"p",value:1e-12,scientific:!0},f:{name:"f",value:1e-15,scientific:!0},a:{name:"a",value:1e-18,scientific:!0},z:{name:"z",value:1e-21,scientific:!0},y:{name:"y",value:1e-24,scientific:!0}},LONG:{"":{name:"",value:1,scientific:!0},deca:{name:"deca",value:10,scientific:!1},hecto:{name:"hecto",value:100,scientific:!1},kilo:{name:"kilo",value:1e3,scientific:!0},mega:{name:"mega",value:1e6,scientific:!0},giga:{name:"giga",value:1e9,scientific:!0},tera:{name:"tera",value:1e12,scientific:!0},peta:{name:"peta",value:1e15,scientific:!0},exa:{name:"exa",value:1e18,scientific:!0},zetta:{name:"zetta",value:1e21,scientific:!0},yotta:{name:"yotta",value:1e24,scientific:!0},deci:{name:"deci",value:.1,scientific:!1},centi:{name:"centi",value:.01,scientific:!1},milli:{name:"milli",value:.001,scientific:!0},micro:{name:"micro",value:1e-6,scientific:!0},nano:{name:"nano",value:1e-9,scientific:!0},pico:{name:"pico",value:1e-12,scientific:!0},femto:{name:"femto",value:1e-15,scientific:!0},atto:{name:"atto",value:1e-18,scientific:!0},zepto:{name:"zepto",value:1e-21,scientific:!0},yocto:{name:"yocto",value:1e-24,scientific:!0}},SQUARED:{"":{name:"",value:1,scientific:!0},da:{name:"da",value:100,scientific:!1},h:{name:"h",value:1e4,scientific:!1},k:{name:"k",value:1e6,scientific:!0},M:{name:"M",value:1e12,scientific:!0},G:{name:"G",value:1e18,scientific:!0},T:{name:"T",value:1e24,scientific:!0},P:{name:"P",value:1e30,scientific:!0},E:{name:"E",value:1e36,scientific:!0},Z:{name:"Z",value:1e42,scientific:!0},Y:{name:"Y",value:1e48,scientific:!0},d:{name:"d",value:.01,scientific:!1},c:{name:"c",value:1e-4,scientific:!1},m:{name:"m",value:1e-6,scientific:!0},u:{name:"u",value:1e-12,scientific:!0},n:{name:"n",value:1e-18,scientific:!0},p:{name:"p",value:1e-24,scientific:!0},f:{name:"f",value:1e-30,scientific:!0},a:{name:"a",value:1e-36,scientific:!0},z:{name:"z",value:1e-42,scientific:!0},y:{name:"y",value:1e-48,scientific:!0}},CUBIC:{"":{name:"",value:1,scientific:!0},da:{name:"da",value:1e3,scientific:!1},h:{name:"h",value:1e6,scientific:!1},k:{name:"k",value:1e9,scientific:!0},M:{name:"M",value:1e18,scientific:!0},G:{name:"G",value:1e27,scientific:!0},T:{name:"T",value:1e36,scientific:!0},P:{name:"P",value:1e45,scientific:!0},E:{name:"E",value:1e54,scientific:!0},Z:{name:"Z",value:1e63,scientific:!0},Y:{name:"Y",value:1e72,scientific:!0},d:{name:"d",value:.001,scientific:!1},c:{name:"c",value:1e-6,scientific:!1},m:{name:"m",value:1e-9,scientific:!0},u:{name:"u",value:1e-18,scientific:!0},n:{name:"n",value:1e-27,scientific:!0},p:{name:"p",value:1e-36,scientific:!0},f:{name:"f",value:1e-45,scientific:!0},a:{name:"a",value:1e-54,scientific:!0},z:{name:"z",value:1e-63,scientific:!0},y:{name:"y",value:1e-72,scientific:!0}},BINARY_SHORT_SI:{"":{name:"",value:1,scientific:!0},k:{name:"k",value:1e3,scientific:!0},M:{name:"M",value:1e6,scientific:!0},G:{name:"G",value:1e9,scientific:!0},T:{name:"T",value:1e12,scientific:!0},P:{name:"P",value:1e15,scientific:!0},E:{name:"E",value:1e18,scientific:!0},Z:{name:"Z",value:1e21,scientific:!0},Y:{name:"Y",value:1e24,scientific:!0}},BINARY_SHORT_IEC:{"":{name:"",value:1,scientific:!0},Ki:{name:"Ki",value:1024,scientific:!0},Mi:{name:"Mi",value:1048576,scientific:!0},Gi:{name:"Gi",value:1073741824,scientific:!0},Ti:{name:"Ti",value:1099511627776,scientific:!0},Pi:{name:"Pi",value:0x4000000000000,scientific:!0},Ei:{name:"Ei",value:0x1000000000000000,scientific:!0},Zi:{name:"Zi",value:11805916207174113e5,scientific:!0},Yi:{name:"Yi",value:12089258196146292e8,scientific:!0}},BINARY_LONG_SI:{"":{name:"",value:1,scientific:!0},kilo:{name:"kilo",value:1e3,scientific:!0},mega:{name:"mega",value:1e6,scientific:!0},giga:{name:"giga",value:1e9,scientific:!0},tera:{name:"tera",value:1e12,scientific:!0},peta:{name:"peta",value:1e15,scientific:!0},exa:{name:"exa",value:1e18,scientific:!0},zetta:{name:"zetta",value:1e21,scientific:!0},yotta:{name:"yotta",value:1e24,scientific:!0}},BINARY_LONG_IEC:{"":{name:"",value:1,scientific:!0},kibi:{name:"kibi",value:1024,scientific:!0},mebi:{name:"mebi",value:1048576,scientific:!0},gibi:{name:"gibi",value:1073741824,scientific:!0},tebi:{name:"tebi",value:1099511627776,scientific:!0},pebi:{name:"pebi",value:0x4000000000000,scientific:!0},exi:{name:"exi",value:0x1000000000000000,scientific:!0},zebi:{name:"zebi",value:11805916207174113e5,scientific:!0},yobi:{name:"yobi",value:12089258196146292e8,scientific:!0}},BTU:{"":{name:"",value:1,scientific:!0},MM:{name:"MM",value:1e6,scientific:!0}}};z.SHORTLONG=/*@__PURE__*/e(o)({},z.SHORT,z.LONG),z.BINARY_SHORT=/*@__PURE__*/e(o)({},z.BINARY_SHORT_SI,z.BINARY_SHORT_IEC),z.BINARY_LONG=/*@__PURE__*/e(o)({},z.BINARY_LONG_SI,z.BINARY_LONG_IEC);/* Internally, each unit is represented by a value and a dimension array. The elements of the dimensions array have the following meaning:
   * Index  Dimension
   * -----  ---------
   *   0    Length
   *   1    Mass
   *   2    Time
   *   3    Current
   *   4    Temperature
   *   5    Luminous intensity
   *   6    Amount of substance
   *   7    Angle
   *   8    Bit (digital)
   * For example, the unit "298.15 K" is a pure temperature and would have a value of 298.15 and a dimension array of [0, 0, 0, 0, 1, 0, 0, 0, 0]. The unit "1 cal / (gm °C)" can be written in terms of the 9 fundamental dimensions as [length^2] / ([time^2] * [temperature]), and would a value of (after conversion to SI) 4184.0 and a dimensions array of [2, 0, -2, 0, -1, 0, 0, 0, 0].
   *
   */var q=["MASS","LENGTH","TIME","CURRENT","TEMPERATURE","LUMINOUS_INTENSITY","AMOUNT_OF_SUBSTANCE","ANGLE","BIT"],k={NONE:{dimensions:[0,0,0,0,0,0,0,0,0]},MASS:{dimensions:[1,0,0,0,0,0,0,0,0]},LENGTH:{dimensions:[0,1,0,0,0,0,0,0,0]},TIME:{dimensions:[0,0,1,0,0,0,0,0,0]},CURRENT:{dimensions:[0,0,0,1,0,0,0,0,0]},TEMPERATURE:{dimensions:[0,0,0,0,1,0,0,0,0]},LUMINOUS_INTENSITY:{dimensions:[0,0,0,0,0,1,0,0,0]},AMOUNT_OF_SUBSTANCE:{dimensions:[0,0,0,0,0,0,1,0,0]},FORCE:{dimensions:[1,1,-2,0,0,0,0,0,0]},SURFACE:{dimensions:[0,2,0,0,0,0,0,0,0]},VOLUME:{dimensions:[0,3,0,0,0,0,0,0,0]},ENERGY:{dimensions:[1,2,-2,0,0,0,0,0,0]},POWER:{dimensions:[1,2,-3,0,0,0,0,0,0]},PRESSURE:{dimensions:[1,-1,-2,0,0,0,0,0,0]},ELECTRIC_CHARGE:{dimensions:[0,0,1,1,0,0,0,0,0]},ELECTRIC_CAPACITANCE:{dimensions:[-1,-2,4,2,0,0,0,0,0]},ELECTRIC_POTENTIAL:{dimensions:[1,2,-3,-1,0,0,0,0,0]},ELECTRIC_RESISTANCE:{dimensions:[1,2,-3,-2,0,0,0,0,0]},ELECTRIC_INDUCTANCE:{dimensions:[1,2,-2,-2,0,0,0,0,0]},ELECTRIC_CONDUCTANCE:{dimensions:[-1,-2,3,2,0,0,0,0,0]},MAGNETIC_FLUX:{dimensions:[1,2,-2,-1,0,0,0,0,0]},MAGNETIC_FLUX_DENSITY:{dimensions:[1,0,-2,-1,0,0,0,0,0]},FREQUENCY:{dimensions:[0,0,-1,0,0,0,0,0,0]},ANGLE:{dimensions:[0,0,0,0,0,0,0,1,0]},BIT:{dimensions:[0,0,0,0,0,0,0,0,1]}};for(var I in k)K(k,I)&&(k[I].key=I);var R={name:"",base:{},value:1,offset:0,dimensions:q.map(e=>0)},P={// length
meter:{name:"meter",base:k.LENGTH,prefixes:z.LONG,value:1,offset:0},inch:{name:"inch",base:k.LENGTH,prefixes:z.NONE,value:.0254,offset:0},foot:{name:"foot",base:k.LENGTH,prefixes:z.NONE,value:.3048,offset:0},yard:{name:"yard",base:k.LENGTH,prefixes:z.NONE,value:.9144,offset:0},mile:{name:"mile",base:k.LENGTH,prefixes:z.NONE,value:1609.344,offset:0},link:{name:"link",base:k.LENGTH,prefixes:z.NONE,value:.201168,offset:0},rod:{name:"rod",base:k.LENGTH,prefixes:z.NONE,value:5.0292,offset:0},chain:{name:"chain",base:k.LENGTH,prefixes:z.NONE,value:20.1168,offset:0},angstrom:{name:"angstrom",base:k.LENGTH,prefixes:z.NONE,value:1e-10,offset:0},m:{name:"m",base:k.LENGTH,prefixes:z.SHORT,value:1,offset:0},in:{name:"in",base:k.LENGTH,prefixes:z.NONE,value:.0254,offset:0},ft:{name:"ft",base:k.LENGTH,prefixes:z.NONE,value:.3048,offset:0},yd:{name:"yd",base:k.LENGTH,prefixes:z.NONE,value:.9144,offset:0},mi:{name:"mi",base:k.LENGTH,prefixes:z.NONE,value:1609.344,offset:0},li:{name:"li",base:k.LENGTH,prefixes:z.NONE,value:.201168,offset:0},rd:{name:"rd",base:k.LENGTH,prefixes:z.NONE,value:5.02921,offset:0},ch:{name:"ch",base:k.LENGTH,prefixes:z.NONE,value:20.1168,offset:0},mil:{name:"mil",base:k.LENGTH,prefixes:z.NONE,value:254e-7,offset:0},// 1/1000 inch
// Surface
m2:{name:"m2",base:k.SURFACE,prefixes:z.SQUARED,value:1,offset:0},sqin:{name:"sqin",base:k.SURFACE,prefixes:z.NONE,value:64516e-8,offset:0},// 645.16 mm2
sqft:{name:"sqft",base:k.SURFACE,prefixes:z.NONE,value:.09290304,offset:0},// 0.09290304 m2
sqyd:{name:"sqyd",base:k.SURFACE,prefixes:z.NONE,value:.83612736,offset:0},// 0.83612736 m2
sqmi:{name:"sqmi",base:k.SURFACE,prefixes:z.NONE,value:2589988.110336,offset:0},// 2.589988110336 km2
sqrd:{name:"sqrd",base:k.SURFACE,prefixes:z.NONE,value:25.29295,offset:0},// 25.29295 m2
sqch:{name:"sqch",base:k.SURFACE,prefixes:z.NONE,value:404.6873,offset:0},// 404.6873 m2
sqmil:{name:"sqmil",base:k.SURFACE,prefixes:z.NONE,value:64516e-14,offset:0},// 6.4516 * 10^-10 m2
acre:{name:"acre",base:k.SURFACE,prefixes:z.NONE,value:4046.86,offset:0},// 4046.86 m2
hectare:{name:"hectare",base:k.SURFACE,prefixes:z.NONE,value:1e4,offset:0},// 10000 m2
// Volume
m3:{name:"m3",base:k.VOLUME,prefixes:z.CUBIC,value:1,offset:0},L:{name:"L",base:k.VOLUME,prefixes:z.SHORT,value:.001,offset:0},// litre
l:{name:"l",base:k.VOLUME,prefixes:z.SHORT,value:.001,offset:0},// litre
litre:{name:"litre",base:k.VOLUME,prefixes:z.LONG,value:.001,offset:0},cuin:{name:"cuin",base:k.VOLUME,prefixes:z.NONE,value:16387064e-12,offset:0},// 1.6387064e-5 m3
cuft:{name:"cuft",base:k.VOLUME,prefixes:z.NONE,value:.028316846592,offset:0},// 28.316 846 592 L
cuyd:{name:"cuyd",base:k.VOLUME,prefixes:z.NONE,value:.764554857984,offset:0},// 764.554 857 984 L
teaspoon:{name:"teaspoon",base:k.VOLUME,prefixes:z.NONE,value:5e-6,offset:0},// 5 mL
tablespoon:{name:"tablespoon",base:k.VOLUME,prefixes:z.NONE,value:15e-6,offset:0},// 15 mL
// {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
drop:{name:"drop",base:k.VOLUME,prefixes:z.NONE,value:5e-8,offset:0},// 0.05 mL = 5e-8 m3
gtt:{name:"gtt",base:k.VOLUME,prefixes:z.NONE,value:5e-8,offset:0},// 0.05 mL = 5e-8 m3
// Liquid volume
minim:{name:"minim",base:k.VOLUME,prefixes:z.NONE,value:6161152e-14,offset:0},// 0.06161152 mL
fluiddram:{name:"fluiddram",base:k.VOLUME,prefixes:z.NONE,value:36966911e-13,offset:0},// 3.696691 mL
fluidounce:{name:"fluidounce",base:k.VOLUME,prefixes:z.NONE,value:2957353e-11,offset:0},// 29.57353 mL
gill:{name:"gill",base:k.VOLUME,prefixes:z.NONE,value:1182941e-10,offset:0},// 118.2941 mL
cc:{name:"cc",base:k.VOLUME,prefixes:z.NONE,value:1e-6,offset:0},// 1e-6 L
cup:{name:"cup",base:k.VOLUME,prefixes:z.NONE,value:2365882e-10,offset:0},// 236.5882 mL
pint:{name:"pint",base:k.VOLUME,prefixes:z.NONE,value:4731765e-10,offset:0},// 473.1765 mL
quart:{name:"quart",base:k.VOLUME,prefixes:z.NONE,value:9463529e-10,offset:0},// 946.3529 mL
gallon:{name:"gallon",base:k.VOLUME,prefixes:z.NONE,value:.003785412,offset:0},// 3.785412 L
beerbarrel:{name:"beerbarrel",base:k.VOLUME,prefixes:z.NONE,value:.1173478,offset:0},// 117.3478 L
oilbarrel:{name:"oilbarrel",base:k.VOLUME,prefixes:z.NONE,value:.1589873,offset:0},// 158.9873 L
hogshead:{name:"hogshead",base:k.VOLUME,prefixes:z.NONE,value:.238481,offset:0},// 238.4810 L
// {name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
fldr:{name:"fldr",base:k.VOLUME,prefixes:z.NONE,value:36966911e-13,offset:0},// 3.696691 mL
floz:{name:"floz",base:k.VOLUME,prefixes:z.NONE,value:2957353e-11,offset:0},// 29.57353 mL
gi:{name:"gi",base:k.VOLUME,prefixes:z.NONE,value:1182941e-10,offset:0},// 118.2941 mL
cp:{name:"cp",base:k.VOLUME,prefixes:z.NONE,value:2365882e-10,offset:0},// 236.5882 mL
pt:{name:"pt",base:k.VOLUME,prefixes:z.NONE,value:4731765e-10,offset:0},// 473.1765 mL
qt:{name:"qt",base:k.VOLUME,prefixes:z.NONE,value:9463529e-10,offset:0},// 946.3529 mL
gal:{name:"gal",base:k.VOLUME,prefixes:z.NONE,value:.003785412,offset:0},// 3.785412 L
bbl:{name:"bbl",base:k.VOLUME,prefixes:z.NONE,value:.1173478,offset:0},// 117.3478 L
obl:{name:"obl",base:k.VOLUME,prefixes:z.NONE,value:.1589873,offset:0},// 158.9873 L
// {name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?
// Mass
g:{name:"g",base:k.MASS,prefixes:z.SHORT,value:.001,offset:0},gram:{name:"gram",base:k.MASS,prefixes:z.LONG,value:.001,offset:0},ton:{name:"ton",base:k.MASS,prefixes:z.SHORT,value:907.18474,offset:0},t:{name:"t",base:k.MASS,prefixes:z.SHORT,value:1e3,offset:0},tonne:{name:"tonne",base:k.MASS,prefixes:z.LONG,value:1e3,offset:0},grain:{name:"grain",base:k.MASS,prefixes:z.NONE,value:6479891e-11,offset:0},dram:{name:"dram",base:k.MASS,prefixes:z.NONE,value:.0017718451953125,offset:0},ounce:{name:"ounce",base:k.MASS,prefixes:z.NONE,value:.028349523125,offset:0},poundmass:{name:"poundmass",base:k.MASS,prefixes:z.NONE,value:.45359237,offset:0},hundredweight:{name:"hundredweight",base:k.MASS,prefixes:z.NONE,value:45.359237,offset:0},stick:{name:"stick",base:k.MASS,prefixes:z.NONE,value:.115,offset:0},stone:{name:"stone",base:k.MASS,prefixes:z.NONE,value:6.35029318,offset:0},gr:{name:"gr",base:k.MASS,prefixes:z.NONE,value:6479891e-11,offset:0},dr:{name:"dr",base:k.MASS,prefixes:z.NONE,value:.0017718451953125,offset:0},oz:{name:"oz",base:k.MASS,prefixes:z.NONE,value:.028349523125,offset:0},lbm:{name:"lbm",base:k.MASS,prefixes:z.NONE,value:.45359237,offset:0},cwt:{name:"cwt",base:k.MASS,prefixes:z.NONE,value:45.359237,offset:0},// Time
s:{name:"s",base:k.TIME,prefixes:z.SHORT,value:1,offset:0},min:{name:"min",base:k.TIME,prefixes:z.NONE,value:60,offset:0},h:{name:"h",base:k.TIME,prefixes:z.NONE,value:3600,offset:0},second:{name:"second",base:k.TIME,prefixes:z.LONG,value:1,offset:0},sec:{name:"sec",base:k.TIME,prefixes:z.LONG,value:1,offset:0},minute:{name:"minute",base:k.TIME,prefixes:z.NONE,value:60,offset:0},hour:{name:"hour",base:k.TIME,prefixes:z.NONE,value:3600,offset:0},day:{name:"day",base:k.TIME,prefixes:z.NONE,value:86400,offset:0},week:{name:"week",base:k.TIME,prefixes:z.NONE,value:604800,offset:0},month:{name:"month",base:k.TIME,prefixes:z.NONE,value:2629800,// 1/12th of Julian year
offset:0},year:{name:"year",base:k.TIME,prefixes:z.NONE,value:31557600,// Julian year
offset:0},decade:{name:"decade",base:k.TIME,prefixes:z.NONE,value:315576e3,// Julian decade
offset:0},century:{name:"century",base:k.TIME,prefixes:z.NONE,value:315576e4,// Julian century
offset:0},millennium:{name:"millennium",base:k.TIME,prefixes:z.NONE,value:315576e5,// Julian millennium
offset:0},// Frequency
hertz:{name:"Hertz",base:k.FREQUENCY,prefixes:z.LONG,value:1,offset:0,reciprocal:!0},Hz:{name:"Hz",base:k.FREQUENCY,prefixes:z.SHORT,value:1,offset:0,reciprocal:!0},// Angle
rad:{name:"rad",base:k.ANGLE,prefixes:z.SHORT,value:1,offset:0},radian:{name:"radian",base:k.ANGLE,prefixes:z.LONG,value:1,offset:0},// deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
deg:{name:"deg",base:k.ANGLE,prefixes:z.SHORT,value:null,// will be filled in by calculateAngleValues()
offset:0},degree:{name:"degree",base:k.ANGLE,prefixes:z.LONG,value:null,// will be filled in by calculateAngleValues()
offset:0},// grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
grad:{name:"grad",base:k.ANGLE,prefixes:z.SHORT,value:null,// will be filled in by calculateAngleValues()
offset:0},gradian:{name:"gradian",base:k.ANGLE,prefixes:z.LONG,value:null,// will be filled in by calculateAngleValues()
offset:0},// cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
cycle:{name:"cycle",base:k.ANGLE,prefixes:z.NONE,value:null,// will be filled in by calculateAngleValues()
offset:0},// arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
arcsec:{name:"arcsec",base:k.ANGLE,prefixes:z.NONE,value:null,// will be filled in by calculateAngleValues()
offset:0},// arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
arcmin:{name:"arcmin",base:k.ANGLE,prefixes:z.NONE,value:null,// will be filled in by calculateAngleValues()
offset:0},// Electric current
A:{name:"A",base:k.CURRENT,prefixes:z.SHORT,value:1,offset:0},ampere:{name:"ampere",base:k.CURRENT,prefixes:z.LONG,value:1,offset:0},// Temperature
// K(C) = °C + 273.15
// K(F) = (°F + 459.67) * (5 / 9)
// K(R) = °R * (5 / 9)
K:{name:"K",base:k.TEMPERATURE,prefixes:z.SHORT,value:1,offset:0},degC:{name:"degC",base:k.TEMPERATURE,prefixes:z.SHORT,value:1,offset:273.15},degF:{name:"degF",base:k.TEMPERATURE,prefixes:z.SHORT,value:new E(5,9),offset:459.67},degR:{name:"degR",base:k.TEMPERATURE,prefixes:z.SHORT,value:new E(5,9),offset:0},kelvin:{name:"kelvin",base:k.TEMPERATURE,prefixes:z.LONG,value:1,offset:0},celsius:{name:"celsius",base:k.TEMPERATURE,prefixes:z.LONG,value:1,offset:273.15},fahrenheit:{name:"fahrenheit",base:k.TEMPERATURE,prefixes:z.LONG,value:new E(5,9),offset:459.67},rankine:{name:"rankine",base:k.TEMPERATURE,prefixes:z.LONG,value:new E(5,9),offset:0},// amount of substance
mol:{name:"mol",base:k.AMOUNT_OF_SUBSTANCE,prefixes:z.SHORT,value:1,offset:0},mole:{name:"mole",base:k.AMOUNT_OF_SUBSTANCE,prefixes:z.LONG,value:1,offset:0},// luminous intensity
cd:{name:"cd",base:k.LUMINOUS_INTENSITY,prefixes:z.SHORT,value:1,offset:0},candela:{name:"candela",base:k.LUMINOUS_INTENSITY,prefixes:z.LONG,value:1,offset:0},// TODO: units STERADIAN
// {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
// {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
// Force
N:{name:"N",base:k.FORCE,prefixes:z.SHORT,value:1,offset:0},newton:{name:"newton",base:k.FORCE,prefixes:z.LONG,value:1,offset:0},dyn:{name:"dyn",base:k.FORCE,prefixes:z.SHORT,value:1e-5,offset:0},dyne:{name:"dyne",base:k.FORCE,prefixes:z.LONG,value:1e-5,offset:0},lbf:{name:"lbf",base:k.FORCE,prefixes:z.NONE,value:4.4482216152605,offset:0},poundforce:{name:"poundforce",base:k.FORCE,prefixes:z.NONE,value:4.4482216152605,offset:0},kip:{name:"kip",base:k.FORCE,prefixes:z.LONG,value:4448.2216,offset:0},kilogramforce:{name:"kilogramforce",base:k.FORCE,prefixes:z.NONE,value:9.80665,offset:0},// Energy
J:{name:"J",base:k.ENERGY,prefixes:z.SHORT,value:1,offset:0},joule:{name:"joule",base:k.ENERGY,prefixes:z.LONG,value:1,offset:0},erg:{name:"erg",base:k.ENERGY,prefixes:z.SHORTLONG,// Both kiloerg and kerg are acceptable
value:1e-7,offset:0},Wh:{name:"Wh",base:k.ENERGY,prefixes:z.SHORT,value:3600,offset:0},BTU:{name:"BTU",base:k.ENERGY,prefixes:z.BTU,value:1055.05585262,offset:0},eV:{name:"eV",base:k.ENERGY,prefixes:z.SHORT,value:1602176565e-28,offset:0},electronvolt:{name:"electronvolt",base:k.ENERGY,prefixes:z.LONG,value:1602176565e-28,offset:0},// Power
W:{name:"W",base:k.POWER,prefixes:z.SHORT,value:1,offset:0},watt:{name:"watt",base:k.POWER,prefixes:z.LONG,value:1,offset:0},hp:{name:"hp",base:k.POWER,prefixes:z.NONE,value:745.6998715386,offset:0},// Electrical power units
VAR:{name:"VAR",base:k.POWER,prefixes:z.SHORT,value:w.I,offset:0},VA:{name:"VA",base:k.POWER,prefixes:z.SHORT,value:1,offset:0},// Pressure
Pa:{name:"Pa",base:k.PRESSURE,prefixes:z.SHORT,value:1,offset:0},psi:{name:"psi",base:k.PRESSURE,prefixes:z.NONE,value:6894.75729276459,offset:0},atm:{name:"atm",base:k.PRESSURE,prefixes:z.NONE,value:101325,offset:0},bar:{name:"bar",base:k.PRESSURE,prefixes:z.SHORTLONG,value:1e5,offset:0},torr:{name:"torr",base:k.PRESSURE,prefixes:z.NONE,value:133.322,offset:0},mmHg:{name:"mmHg",base:k.PRESSURE,prefixes:z.NONE,value:133.322,offset:0},mmH2O:{name:"mmH2O",base:k.PRESSURE,prefixes:z.NONE,value:9.80665,offset:0},cmH2O:{name:"cmH2O",base:k.PRESSURE,prefixes:z.NONE,value:98.0665,offset:0},// Electric charge
coulomb:{name:"coulomb",base:k.ELECTRIC_CHARGE,prefixes:z.LONG,value:1,offset:0},C:{name:"C",base:k.ELECTRIC_CHARGE,prefixes:z.SHORT,value:1,offset:0},// Electric capacitance
farad:{name:"farad",base:k.ELECTRIC_CAPACITANCE,prefixes:z.LONG,value:1,offset:0},F:{name:"F",base:k.ELECTRIC_CAPACITANCE,prefixes:z.SHORT,value:1,offset:0},// Electric potential
volt:{name:"volt",base:k.ELECTRIC_POTENTIAL,prefixes:z.LONG,value:1,offset:0},V:{name:"V",base:k.ELECTRIC_POTENTIAL,prefixes:z.SHORT,value:1,offset:0},// Electric resistance
ohm:{name:"ohm",base:k.ELECTRIC_RESISTANCE,prefixes:z.SHORTLONG,// Both Mohm and megaohm are acceptable
value:1,offset:0},/*
     * Unicode breaks in browsers if charset is not specified
    Ω: {
      name: 'Ω',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    */// Electric inductance
henry:{name:"henry",base:k.ELECTRIC_INDUCTANCE,prefixes:z.LONG,value:1,offset:0},H:{name:"H",base:k.ELECTRIC_INDUCTANCE,prefixes:z.SHORT,value:1,offset:0},// Electric conductance
siemens:{name:"siemens",base:k.ELECTRIC_CONDUCTANCE,prefixes:z.LONG,value:1,offset:0},S:{name:"S",base:k.ELECTRIC_CONDUCTANCE,prefixes:z.SHORT,value:1,offset:0},// Magnetic flux
weber:{name:"weber",base:k.MAGNETIC_FLUX,prefixes:z.LONG,value:1,offset:0},Wb:{name:"Wb",base:k.MAGNETIC_FLUX,prefixes:z.SHORT,value:1,offset:0},// Magnetic flux density
tesla:{name:"tesla",base:k.MAGNETIC_FLUX_DENSITY,prefixes:z.LONG,value:1,offset:0},T:{name:"T",base:k.MAGNETIC_FLUX_DENSITY,prefixes:z.SHORT,value:1,offset:0},// Binary
b:{name:"b",base:k.BIT,prefixes:z.BINARY_SHORT,value:1,offset:0},bits:{name:"bits",base:k.BIT,prefixes:z.BINARY_LONG,value:1,offset:0},B:{name:"B",base:k.BIT,prefixes:z.BINARY_SHORT,value:8,offset:0},bytes:{name:"bytes",base:k.BIT,prefixes:z.BINARY_LONG,value:8,offset:0}},j={meters:"meter",inches:"inch",feet:"foot",yards:"yard",miles:"mile",links:"link",rods:"rod",chains:"chain",angstroms:"angstrom",lt:"l",litres:"litre",liter:"litre",liters:"litre",teaspoons:"teaspoon",tablespoons:"tablespoon",minims:"minim",fluiddrams:"fluiddram",fluidounces:"fluidounce",gills:"gill",cups:"cup",pints:"pint",quarts:"quart",gallons:"gallon",beerbarrels:"beerbarrel",oilbarrels:"oilbarrel",hogsheads:"hogshead",gtts:"gtt",grams:"gram",tons:"ton",tonnes:"tonne",grains:"grain",drams:"dram",ounces:"ounce",poundmasses:"poundmass",hundredweights:"hundredweight",sticks:"stick",lb:"lbm",lbs:"lbm",kips:"kip",kgf:"kilogramforce",acres:"acre",hectares:"hectare",sqfeet:"sqft",sqyard:"sqyd",sqmile:"sqmi",sqmiles:"sqmi",mmhg:"mmHg",mmh2o:"mmH2O",cmh2o:"cmH2O",seconds:"second",secs:"second",minutes:"minute",mins:"minute",hours:"hour",hr:"hour",hrs:"hour",days:"day",weeks:"week",months:"month",years:"year",decades:"decade",centuries:"century",millennia:"millennium",hertz:"hertz",radians:"radian",degrees:"degree",gradians:"gradian",cycles:"cycle",arcsecond:"arcsec",arcseconds:"arcsec",arcminute:"arcmin",arcminutes:"arcmin",BTUs:"BTU",watts:"watt",joules:"joule",amperes:"ampere",amps:"ampere",amp:"ampere",coulombs:"coulomb",volts:"volt",ohms:"ohm",farads:"farad",webers:"weber",teslas:"tesla",electronvolts:"electronvolt",moles:"mole",bit:"bits",byte:"bytes"};/**
   * Calculate the values for the angle units.
   * Value is calculated as number or BigNumber depending on the configuration
   * @param {{number: 'number' | 'BigNumber'}} config
   */function U(e){if("BigNumber"===e.number){var t=sR(D);P.rad.value=new D(1),P.deg.value=t.div(180),P.grad.value=t.div(200),P.cycle.value=t.times(2),P.arcsec.value=t.div(648e3),P.arcmin.value=t.div(10800)}else // number
P.rad.value=1,P.deg.value=Math.PI/180,P.grad.value=Math.PI/200,P.cycle.value=2*Math.PI,P.arcsec.value=Math.PI/648e3,P.arcmin.value=Math.PI/10800;// copy to the full names of the angles
P.radian.value=P.rad.value,P.degree.value=P.deg.value,P.gradian.value=P.grad.value}// apply the angle values now
U(s),a&&a("config",function(e,t){e.number!==t.number&&U(e)});/**
   * A unit system is a set of dimensionally independent base units plus a set of derived units, formed by multiplication and division of the base units, that are by convention used with the unit system.
   * A user perhaps could issue a command to select a preferred unit system, or use the default (see below).
   * Auto unit system: The default unit system is updated on the fly anytime a unit is parsed. The corresponding unit in the default unit system is updated, so that answers are given in the same units the user supplies.
   */var L={si:{// Base units
NONE:{unit:R,prefix:z.NONE[""]},LENGTH:{unit:P.m,prefix:z.SHORT[""]},MASS:{unit:P.g,prefix:z.SHORT.k},TIME:{unit:P.s,prefix:z.SHORT[""]},CURRENT:{unit:P.A,prefix:z.SHORT[""]},TEMPERATURE:{unit:P.K,prefix:z.SHORT[""]},LUMINOUS_INTENSITY:{unit:P.cd,prefix:z.SHORT[""]},AMOUNT_OF_SUBSTANCE:{unit:P.mol,prefix:z.SHORT[""]},ANGLE:{unit:P.rad,prefix:z.SHORT[""]},BIT:{unit:P.bits,prefix:z.SHORT[""]},// Derived units
FORCE:{unit:P.N,prefix:z.SHORT[""]},ENERGY:{unit:P.J,prefix:z.SHORT[""]},POWER:{unit:P.W,prefix:z.SHORT[""]},PRESSURE:{unit:P.Pa,prefix:z.SHORT[""]},ELECTRIC_CHARGE:{unit:P.C,prefix:z.SHORT[""]},ELECTRIC_CAPACITANCE:{unit:P.F,prefix:z.SHORT[""]},ELECTRIC_POTENTIAL:{unit:P.V,prefix:z.SHORT[""]},ELECTRIC_RESISTANCE:{unit:P.ohm,prefix:z.SHORT[""]},ELECTRIC_INDUCTANCE:{unit:P.H,prefix:z.SHORT[""]},ELECTRIC_CONDUCTANCE:{unit:P.S,prefix:z.SHORT[""]},MAGNETIC_FLUX:{unit:P.Wb,prefix:z.SHORT[""]},MAGNETIC_FLUX_DENSITY:{unit:P.T,prefix:z.SHORT[""]},FREQUENCY:{unit:P.Hz,prefix:z.SHORT[""]}}};// Clone to create the other unit systems
L.cgs=JSON.parse(JSON.stringify(L.si)),L.cgs.LENGTH={unit:P.m,prefix:z.SHORT.c},L.cgs.MASS={unit:P.g,prefix:z.SHORT[""]},L.cgs.FORCE={unit:P.dyn,prefix:z.SHORT[""]},L.cgs.ENERGY={unit:P.erg,prefix:z.NONE[""]},// there are wholly 4 unique cgs systems for electricity and magnetism,
// so let's not worry about it unless somebody complains
L.us=JSON.parse(JSON.stringify(L.si)),L.us.LENGTH={unit:P.ft,prefix:z.NONE[""]},L.us.MASS={unit:P.lbm,prefix:z.NONE[""]},L.us.TEMPERATURE={unit:P.degF,prefix:z.NONE[""]},L.us.FORCE={unit:P.lbf,prefix:z.NONE[""]},L.us.ENERGY={unit:P.BTU,prefix:z.BTU[""]},L.us.POWER={unit:P.hp,prefix:z.NONE[""]},L.us.PRESSURE={unit:P.psi,prefix:z.NONE[""]},// Add additional unit systems here.
// Choose a unit system to seed the auto unit system.
L.auto=JSON.parse(JSON.stringify(L.si));// Set the current unit system
var $=L.auto;// Add dimensions to each built-in unit
for(var H in /**
   * Set a unit system for formatting derived units.
   * @param {string} [name] The name of the unit system.
   */A.setUnitSystem=function(e){if(K(L,e))$=L[e];else throw Error("Unit system "+e+" does not exist. Choices are: "+Object.keys(L).join(", "))},/**
   * Return the current unit system.
   * @return {string} The current unit system.
   */A.getUnitSystem=function(){for(var e in L)if(K(L,e)&&L[e]===$)return e},/**
   * Converters to convert from number to an other numeric type like BigNumber
   * or Fraction
   */A.typeConverters={BigNumber:function(e){return null!=e&&e.isFraction?new D(e.n).div(e.d).times(e.s):new D(e+"")},Fraction:function(e){return new E(e)},Complex:function(e){return e},number:function(e){return null!=e&&e.isFraction?N(e):e}},/**
   * Retrieve the right converter function corresponding with this unit's
   * value
   *
   * @memberof Unit
   * @return {Function}
   */A.prototype._numberConverter=function(){var e=A.typeConverters[this.valueType()];if(e)return e;throw TypeError('Unsupported Unit value type "'+this.valueType()+'"')},/**
   * Retrieve the right convertor function corresponding with the type
   * of provided exampleValue.
   *
   * @param {string} type   A string 'number', 'BigNumber', or 'Fraction'
   *                        In case of an unknown type,
   * @return {Function}
   */A._getNumberConverter=function(e){if(!A.typeConverters[e])throw TypeError('Unsupported type "'+e+'"');return A.typeConverters[e]},P)if(K(P,H)){var Z=P[H];Z.dimensions=Z.base.dimensions}// Create aliases
for(var G in j)if(K(j,G)){var V=P[j[G]],W={};for(var X in V)K(V,X)&&(W[X]=V[X]);W.name=G,P[G]=W}return(/**
   * Checks if a character is a valid latin letter (upper or lower case).
   * Note that this function can be overridden, for example to allow support of other alphabets.
   * @param {string} c Tested character
   */A.isValidAlpha=function(e){return/^[a-zA-Z]$/.test(e)},/**
   * Wrapper around createUnitSingle.
   * Example:
   *  createUnit({
   *    foo: { },
   *    bar: {
   *      definition: 'kg/foo',
   *      aliases: ['ba', 'barr', 'bars'],
   *      offset: 200
   *    },
   *    baz: '4 bar'
   *  },
   *  {
   *    override: true
   *  })
   * @param {object} obj      Object map. Each key becomes a unit which is defined by its value.
   * @param {object} options
   */A.createUnit=function(e,t){if("object"!=typeof e)throw TypeError("createUnit expects first parameter to be of type 'Object'");// Remove all units and aliases we are overriding
if(t&&t.override){for(var r in e)if(K(e,r)&&A.deleteUnit(r),e[r].aliases)for(var n,i=0;i<e[r].aliases.length;i++)A.deleteUnit(e[r].aliases[i])}for(var a in e)K(e,a)&&(n=A.createUnitSingle(a,e[a]));return n},/**
   * Create a user-defined unit and register it with the Unit type.
   * Example:
   *  createUnitSingle('knot', '0.514444444 m/s')
   *  createUnitSingle('acre', new Unit(43560, 'ft^2'))
   *
   * @param {string} name      The name of the new unit. Must be unique. Example: 'knot'
   * @param {string, Unit, Object} definition      Definition of the unit in terms
   * of existing units. For example, '0.514444444 m / s'. Can be a Unit, a string,
   * or an Object. If an Object, may have the following properties:
   *   - definition {string|Unit} The definition of this unit.
   *   - prefixes {string} "none", "short", "long", "binary_short", or "binary_long".
   *     The default is "none".
   *   - aliases {Array} Array of strings. Example: ['knots', 'kt', 'kts']
   *   - offset {Numeric} An offset to apply when converting from the unit. For
   *     example, the offset for celsius is 273.15 and the offset for farhenheit
   *     is 459.67. Default is 0.
   *   - baseName {string} If the unit's dimension does not match that of any other
   *     base unit, the name of the newly create base unit. Otherwise, this property
   *     has no effect.
   *
   * @return {Unit}
   */A.createUnitSingle=function(e,t){if(null==t&&(t={}),"string"!=typeof e)throw TypeError("createUnitSingle expects first parameter to be of type 'string'");// Check collisions with existing units
if(K(P,e))throw Error('Cannot create unit "'+e+'": a unit with that name already exists');!// TODO: Validate name for collisions with other built-in functions (like abs or cos, for example), and for acceptable variable names. For example, '42' is probably not a valid unit. Nor is '%', since it is also an operator.
function(e){for(var t=0;t<e.length;t++){if(i=e.charAt(t),0===t&&!A.isValidAlpha(i))throw Error('Invalid unit name (must begin with alpha character): "'+e+'"');if(t>0&&!(A.isValidAlpha(i)||C(i)))throw Error('Invalid unit name (only alphanumeric characters are allowed): "'+e+'"')}}(e);var r,n,a,o=null,s=[],u=0;// The Unit from which the new unit will be created.
if(t&&"Unit"===t.type)o=t.clone();else if("string"==typeof t)""!==t&&(r=t);else if("object"==typeof t)r=t.definition,n=t.prefixes,u=t.offset,a=t.baseName,t.aliases&&(s=t.aliases.valueOf());else throw TypeError('Cannot create unit "'+e+'" from "'+t.toString()+'": expecting "string" or "Unit" or "Object"');if(s){for(var l=0;l<s.length;l++)if(K(P,s[l]))throw Error('Cannot create alias "'+s[l]+'": a unit with that name already exists')}if(r&&"string"==typeof r&&!o)try{o=A.parse(r,{allowNoUnits:!0})}catch(t){throw t.message='Could not create unit "'+e+'" from "'+r+'": '+t.message,t}else r&&"Unit"===r.type&&(o=r.clone());s=s||[],u=u||0,n=n&&n.toUpperCase&&z[n.toUpperCase()]||z.NONE;// If defUnit is null, it is because the user did not
// specify a defintion. So create a new base dimension.
var c={};if(o){c={name:e,value:o.value,dimensions:o.dimensions.slice(0),prefixes:n,offset:u};// Create a new base if no matching base exists
var f=!1;for(var p in k)if(K(k,p)){for(var m=!0,d=0;d<q.length;d++)if(Math.abs((c.dimensions[d]||0)-(k[p].dimensions[d]||0))>1e-12){m=!1;break}if(m){f=!0,c.base=k[p];break}}if(!f){a=a||e+"_STUFF";// Add the new base unit
var h={dimensions:o.dimensions.slice(0)};h.key=a,k[a]=h,$[a]={unit:c,prefix:z.NONE[""]},c.base=k[a]}}else{if(// Add a new base dimension
a=a||e+"_STUFF",q.indexOf(a)>=0)throw Error('Cannot create new base unit "'+e+'": a base unit with that name already exists (and cannot be overridden)');// Push 0 onto existing base units
for(var g in q.push(a),k)K(k,g)&&(k[g].dimensions[q.length-1]=0);for(var y={dimensions:[]},v=0;v<q.length;v++)y.dimensions[v]=0;y.dimensions[q.length-1]=1,y.key=a,k[a]=y,c={name:e,value:1,dimensions:k[a].dimensions.slice(0),prefixes:n,offset:u,base:k[a]},$[a]={unit:c,prefix:z.NONE[""]}}A.UNITS[e]=c;for(var x=0;x<s.length;x++){var b=s[x],N={};for(var w in c)K(c,w)&&(N[w]=c[w]);N.name=b,A.UNITS[b]=N}return(// delete the memoization cache, since adding a new unit to the array
// invalidates all old results
delete O.cache,new A(null,e))},A.deleteUnit=function(e){delete A.UNITS[e]},// expose arrays with prefixes, dimensions, units, systems
A.PREFIXES=z,A.BASE_DIMENSIONS=q,A.BASE_UNITS=k,A.UNIT_SYSTEMS=L,A.UNITS=P,A)},{isClass:!0}),pJ="unit",pX=ta(pJ,["typed","Unit"],e=>{var{typed:t,Unit:r}=e;/**
   * Create a unit. Depending on the passed arguments, the function
   * will create and return a new math.Unit object.
   * When a matrix is provided, all elements will be converted to units.
   *
   * Syntax:
   *
   *     math.unit(unit : string)
   *     math.unit(value : number, valuelessUnit : Unit)
   *     math.unit(value : number, valuelessUnit : string)
   *
   * Examples:
   *
   *    const kph = math.unit('km/h')   // returns Unit km/h (valueless)
   *    const v = math.unit(25, kph)    // returns Unit 25 km/h
   *    const a = math.unit(5, 'cm')    // returns Unit 50 mm
   *    const b = math.unit('23 kg')    // returns Unit 23 kg
   *    a.to('m')                       // returns Unit 0.05 m
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, number, string, createUnit
   *
   * @param {* | Array | Matrix} args   A number and unit.
   * @return {Unit | Array | Matrix}    The created unit
   */return t(pJ,{Unit:function(e){return e.clone()},string:function(e){return r.isValuelessUnit(e)?new r(null,e):r.parse(e,{allowNoUnits:!0})// a pure unit
},"number | BigNumber | Fraction | Complex, string | Unit":function(e,t){return new r(e,t)},"number | BigNumber | Fraction":function(e){// dimensionless
return new r(e)},"Array | Matrix":t.referToSelf(e=>t=>tq(t,e))})}),pQ="usolve",pK=ta(pQ,["typed","matrix","divideScalar","multiplyScalar","subtractScalar","equalScalar","DenseMatrix"],e=>{var{typed:t,matrix:r,divideScalar:n,multiplyScalar:i,subtractScalar:a,equalScalar:o,DenseMatrix:s}=e,u=lK({DenseMatrix:s});/**
   * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.
   *
   * `U * x = b`
   *
   * Syntax:
   *
   *    math.usolve(U, b)
   *
   * Examples:
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = usolve(a, b)  // [[8], [9]]
   *
   * See also:
   *
   *    usolveAll, lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} U       A N x N matrix or array (U)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
   */return t(pQ,{"SparseMatrix, Array | Matrix":function(e,t){return function(e,t){// loop columns backwards
for(var r=// make b into a column vector
(t=u(e,t,!0))._data,l=e._size[0],c=e._size[1],f=e._values,p=e._index,m=e._ptr,d=[],h=c-1;h>=0;h--){var g=r[h][0]||0;if(o(g,0))d[h]=[0];else{// values in column, find value at [j, j], loop backwards
for(var y=0,v=[],x=[],b=m[h],N=m[h+1],w=N-1;w>=b;w--){var D=p[w];// check row (rows are not sorted!)
D===h?y=f[w]:D<h&&(// store upper triangular
v.push(f[w]),x.push(D))}// at this point we must have a value in vjj
if(o(y,0))throw Error("Linear system cannot be solved since matrix is singular");for(var E=n(g,y),A=0,S=x.length;A<S;A++){var C=x[A];r[C]=[a(r[C][0],i(E,v[A]))]}d[h]=[E]}}return new s({data:d,size:[l,1]})}(e,t)},"DenseMatrix, Array | Matrix":function(e,t){return l(e,t)},"Array, Array | Matrix":function(e,t){return l(r(e),t).valueOf()}});function l(e,t){// loop columns backwards
for(var r=// make b into a column vector
(t=u(e,t,!0))._data,l=e._size[0],c=e._size[1],f=[],p=e._data,m=c-1;m>=0;m--){// b[j]
var d=r[m][0]||0,h=void 0;if(o(d,0))h=0;else{// value at [j, j]
var g=p[m][m];if(o(g,0))throw Error("Linear system cannot be solved since matrix is singular");h=n(d,g);// loop rows
for(var y=m-1;y>=0;y--)r[y]=[a(r[y][0]||0,i(h,p[y][m]))]}// update x
f[m]=[h]}return new s({data:f,size:[l,1]})}}),p0="usolveAll",p1=ta(p0,["typed","matrix","divideScalar","multiplyScalar","subtractScalar","equalScalar","DenseMatrix"],e=>{var{typed:t,matrix:r,divideScalar:n,multiplyScalar:i,subtractScalar:a,equalScalar:o,DenseMatrix:s}=e,u=lK({DenseMatrix:s});/**
   * Finds all solutions of a linear equation system by backward substitution. Matrix must be an upper triangular matrix.
   *
   * `U * x = b`
   *
   * Syntax:
   *
   *    math.usolveAll(U, b)
   *
   * Examples:
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = usolveAll(a, b)  // [ [[8], [9]] ]
   *
   * See also:
   *
   *    usolve, lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} U       A N x N matrix or array (U)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system
   */return t(p0,{"SparseMatrix, Array | Matrix":function(e,t){return function(e,t){// loop columns backwards
for(var r=[u(e,t,!0)._data.map(e=>e[0])],l=e._size[0],c=e._size[1],f=e._values,p=e._index,m=e._ptr,d=c-1;d>=0;d--)// loop right-hand sides
for(var h=r.length,g=0;g<h;g++){for(var y=r[g],v=[],x=[],b=m[d],N=m[d+1],w=0,D=N-1;D>=b;D--){var E=p[D];// check row
E===d?w=f[D]:E<d&&(// store upper triangular
v.push(f[D]),x.push(E))}if(o(w,0)){if(o(y[d],0)){if(0===g){// singular row, RHS is zero
var A=[...y];A[d]=1;// loop upper triangular
for(var S=0,C=x.length;S<C;S++){var M=x[S];A[M]=a(A[M],v[S])}r.push(A)}}else{// singular row, nonzero RHS
if(0===g)return[];// This RHS is invalid but other solutions may still exist
r.splice(g,1),g-=1,h-=1}}else{// non-singular row
y[d]=n(y[d],w);// loop upper triangular
for(var F=0,B=x.length;F<B;F++){var T=x[F];y[T]=a(y[T],i(y[d],v[F]))}}}return r.map(e=>new s({data:e.map(e=>[e]),size:[l,1]}))}(e,t)},"DenseMatrix, Array | Matrix":function(e,t){return l(e,t)},"Array, Array | Matrix":function(e,t){return l(r(e),t).map(e=>e.valueOf())}});function l(e,t){// loop columns backwards
for(var r=[u(e,t,!0)._data.map(e=>e[0])],l=e._data,c=e._size[0],f=e._size[1],p=f-1;p>=0;p--)// loop right-hand sides
for(var m=r.length,d=0;d<m;d++){var h=r[d];if(o(l[p][p],0)){if(o(h[p],0)){if(0===d){// singular row, RHS is zero
var g=[...h];g[p]=1;for(var y=p-1;y>=0;y--)g[y]=a(g[y],l[y][p]);r.push(g)}}else{// singular row, nonzero RHS
if(0===d)return[];// This RHS is invalid but other solutions may still exist
r.splice(d,1),d-=1,m-=1}}else{// non-singular row
h[p]=n(h[p],l[p][p]);for(var v=p-1;v>=0;v--)h[v]=a(h[v],i(h[p],l[v][p]))}}return r.map(e=>new s({data:e.map(e=>[e]),size:[c,1]}))}}),p2="xgcd",p3=ta(p2,["typed","config","matrix","BigNumber"],e=>{var{typed:t,config:r,matrix:n,BigNumber:i}=e;/**
   * Calculate the extended greatest common divisor for two values.
   * See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
   *
   * Syntax:
   *
   *    math.xgcd(a, b)
   *
   * Examples:
   *
   *    math.xgcd(8, 12)             // returns [4, -1, 1]
   *    math.gcd(8, 12)              // returns 4
   *    math.xgcd(36163, 21199)      // returns [1247, -7, 12]
   *
   * See also:
   *
   *    gcd, lcm
   *
   * @param {number | BigNumber} a  An integer number
   * @param {number | BigNumber} b  An integer number
   * @return {Array}              Returns an array containing 3 integers `[div, m, n]`
   *                              where `div = gcd(a, b)` and `a*m + b*n = div`
   */return t(p2,{"number, number":function(e,t){var i=n7(e,t);return"Array"===r.matrix?i:n(i)},"BigNumber, BigNumber":/**
   * Calculate xgcd for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @return {BigNumber[]} result
   * @private
   */function(e,t){var a,o,s,u,l=new i(0),c=new i(1),f=l,p=c,m=c,d=l;if(!e.isInt()||!t.isInt())throw Error("Parameters in function xgcd must be integer numbers");for(;!t.isZero();)o=e.div(t).floor(),s=e.mod(t),a=f,f=p.minus(o.times(f)),p=a,a=m,m=d.minus(o.times(m)),d=a,e=t,t=s;return u=e.lt(l)?[e.neg(),p.neg(),d.neg()]:[e,e.isZero()?0:p,d],"Array"===r.matrix?u:n(u)}})}),p4=ta("xor",["typed","matrix","DenseMatrix","concat"],e=>{var{typed:t,matrix:r,DenseMatrix:n,concat:i}=e,a=i5({typed:t}),o=ov({typed:t,DenseMatrix:n}),s=i6({typed:t,DenseMatrix:n}),u=iI({typed:t,matrix:r,concat:i});/**
   * Logical `xor`. Test whether one and only one value is defined with a nonzero/nonempty value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.xor(x, y)
   *
   * Examples:
   *
   *    math.xor(2, 4)   // returns false
   *
   *    a = [2, 0, 0]
   *    b = [2, 7, 0]
   *    c = 0
   *
   *    math.xor(a, b)   // returns [false, true, false]
   *    math.xor(a, c)   // returns [true, false, false]
   *
   * See also:
   *
   *    and, not, or
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when one and only one input is defined with a nonzero/nonempty value.
   */return t("xor",{"number, number":iV,"Complex, Complex":function(e,t){return(0!==e.re||0!==e.im)!=(0!==t.re||0!==t.im)},"BigNumber, BigNumber":function(e,t){return(!e.isZero()&&!e.isNaN())!=(!t.isZero()&&!t.isNaN())},"Unit, Unit":t.referToSelf(e=>(t,r)=>e(t.value||0,r.value||0))},u({SS:o,DS:a,Ss:s}))}),p5="zeros",p8=ta(p5,["typed","config","matrix","BigNumber"],e=>{var{typed:t,config:r,matrix:n,BigNumber:i}=e;/**
   * Create a matrix filled with zeros. The created matrix can have one or
   * multiple dimensions.
   *
   * Syntax:
   *
   *    math.zeros(m)
   *    math.zeros(m, format)
   *    math.zeros(m, n)
   *    math.zeros(m, n, format)
   *    math.zeros([m, n])
   *    math.zeros([m, n], format)
   *
   * Examples:
   *
   *    math.zeros()                   // returns []
   *    math.zeros(3)                  // returns [0, 0, 0]
   *    math.zeros(3, 2)               // returns [[0, 0], [0, 0], [0, 0]]
   *    math.zeros(3, 'dense')         // returns [0, 0, 0]
   *
   *    const A = [[1, 2, 3], [4, 5, 6]]
   *    math.zeros(math.size(A))       // returns [[0, 0, 0], [0, 0, 0]]
   *
   * See also:
   *
   *    ones, identity, size, range
   *
   * @param {...(number|BigNumber) | Array} size    The size of each dimension of the matrix
   * @param {string} [format]           The Matrix storage format
   *
   * @return {Array | Matrix}           A matrix filled with zeros
   */return t(p5,{"":function(){return"Array"===r.matrix?a([]):a([],"default")},// math.zeros(m, n, p, ..., format)
// TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
"...number | BigNumber | string":function(e){if("string"==typeof e[e.length-1]){var t=e.pop();return a(e,t)}return"Array"===r.matrix?a(e):a(e,"default")},Array:a,Matrix:function(e){var t=e.storage();return a(e.valueOf(),t)},"Array | Matrix, string":function(e,t){return a(e.valueOf(),t)}});/**
   * Create an Array or Matrix with zeros
   * @param {Array} size
   * @param {string} [format='default']
   * @return {Array | Matrix}
   * @private
   */function a(e,t){var r,a=(r=!1,e.forEach(function(e,t,n){c(e)&&(r=!0,n[t]=e.toNumber())}),r)?new i(0):0;if(// validate arguments
function(e){e.forEach(function(e){if("number"!=typeof e||!eh(e)||e<0)throw Error("Parameters in function zeros must be positive integers")})}(e),t){// return a matrix
var o=n(t);return e.length>0?o.resize(e,a):o}// return an Array
var s=[];return e.length>0?eX(s,e,a):s}}),p6="zeta",p7=ta(p6,["typed","config","multiply","pow","divide","factorial","equal","smallerEq","isNegative","gamma","sin","subtract","add","?Complex","?BigNumber","pi"],e=>{var{typed:t,config:r,multiply:n,pow:i,divide:a,factorial:o,equal:s,smallerEq:u,isNegative:l,gamma:c,sin:f,subtract:p,add:m,Complex:d,BigNumber:h,pi:g}=e;/**
   * Compute the Riemann Zeta function of a value using an infinite series for
   * all of the complex plane using Riemann's Functional equation.
   *
   * Based off the paper by Xavier Gourdon and Pascal Sebah
   * ( http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf )
   *
   * Implementation and slight modification by Anik Patel
   *
   * Note: the implementation is accurate up to about 6 digits.
   *
   * Syntax:
   *
   *    math.zeta(n)
   *
   * Examples:
   *
   *    math.zeta(5)       // returns 1.0369277551433895
   *    math.zeta(-0.5)    // returns -0.2078862249773449
   *    math.zeta(math.i)  // returns 0.0033002236853253153 - 0.4181554491413212i
   *
   * See also:
   *    erf
   *
   * @param {number | Complex | BigNumber} s   A Real, Complex or BigNumber parameter to the Riemann Zeta Function
   * @return {number | Complex | BigNumber}    The Riemann Zeta of `s`
   */return t(p6,{number:e=>y(e,e=>e,()=>20),BigNumber:e=>y(e,e=>new h(e),()=>Math.abs(Math.log10(r.epsilon))),Complex:/**
   * @param {Complex} s
   * @returns {Complex}
   */function(e){return 0===e.re&&0===e.im?new d(-.5):1===e.re?new d(NaN,NaN):e.re===1/0&&0===e.im?new d(1):e.im===1/0||e.re===-1/0?new d(NaN,NaN):v(e,e=>e,e=>Math.round(19.5+.9*Math.abs(e.im)),e=>e.re)}});/**
   * @param {number | BigNumber} s
   * @param {(value: number) => number | BigNumber} createValue
   * @param {(value: number | BigNumber | Complex) => number} determineDigits
   * @returns {number | BigNumber}
   */function y(e,t,r){return s(e,0)?t(-.5):s(e,1)?t(NaN):isFinite(e)?v(e,t,r,e=>e):t(l(e)?NaN:1)}/**
   * @param {number | BigNumber | Complex} s
   * @param {(value: number) => number | BigNumber | Complex} createValue
   * @param {(value: number | BigNumber | Complex) => number} determineDigits
   * @param {(value: number | BigNumber | Complex) => number} getRe
   * @returns {*|number}
   */function v(e,t,r,o){var s=r(e);if(o(e)>-(s-1)/2)return(/**
   * Calculate the positive Riemann Zeta function
   * @param {number} s   a real or complex number with s.re > 1
   * @param {number} n   a positive integer
   * @param {(number) => number | BigNumber | Complex} createValue
   * @return {number}    Riemann Zeta of s
   **/function(e,t,r){for(var o=a(1,n(x(r(0),t),p(1,i(2,p(1,e))))),s=r(0),l=r(1);u(l,t);l=m(l,1))s=m(s,a(n((-1)**(l-1),x(l,t)),i(l,e)));return n(o,s)}(e,t(s),t));// Function Equation for reflection to x < 1
var l=n(i(2,e),i(t(g),p(e,1)));return l=n(l,f(n(a(t(g),2),e))),l=n(l,c(p(1,e))),n(l,v(p(1,e),t,r,o))}/**
   * Calculate a portion of the sum
   * @param {number | BigNumber} k   a positive integer
   * @param {number | BigNumber} n   a positive integer
   * @return {number}    the portion of the sum
   **/function x(e,t){for(var r=e,s=e;u(s,t);s=m(s,1)){var l=a(n(o(m(t,p(s,1))),i(4,s)),n(o(p(t,s)),o(n(2,s))));r=m(r,l)}return n(t,r)}}),p9="zpk2tf",me=ta(p9,["typed","add","multiply","Complex","number"],e=>{var{typed:t,add:r,multiply:n,Complex:i,number:a}=e;/**
     * Compute the transfer function of a zero-pole-gain model.
     *
     * Syntax:
     *      math.zpk2tf(z, p, k)
     *
     * Examples:
     *    math.zpk2tf([1, 2], [-1, -2], 1)    // returns [[1, -3, 2], [1, 3, 2]]
     *
     * See also:
     *   freqz
     *
     * @param {Array} z Array of zeros values
     * @param {Array} p Array of poles values
     * @param {number} k Gain value
     * @return {Array} Two dimensional array containing the numerator (first row) and denominator (second row) polynomials
     *
     */return t(p9,{"Array,Array,number":function(e,t,r){return o(e,t,r)},"Array,Array":function(e,t){return o(e,t,1)},"Matrix,Matrix,number":function(e,t,r){return o(e.valueOf(),t.valueOf(),r)},"Matrix,Matrix":function(e,t){return o(e.valueOf(),t.valueOf(),1)}});function o(e,t,r){e.some(e=>"BigNumber"===e.type)&&(e=e.map(e=>a(e))),t.some(e=>"BigNumber"===e.type)&&(t=t.map(e=>a(e)));for(var o=[i(1,0)],u=[i(1,0)],l=0;l<e.length;l++){var c=e[l];"number"==typeof c&&(c=i(c,0)),o=s(o,[i(1,0),i(-c.re,-c.im)])}for(var f=0;f<t.length;f++){var p=t[f];"number"==typeof p&&(p=i(p,0)),u=s(u,[i(1,0),i(-p.re,-p.im)])}for(var m=0;m<o.length;m++)o[m]=n(o[m],r);return[o,u]}function s(e,t){for(var a=[],o=0;o<e.length+t.length-1;o++){a[o]=i(0,0);for(var s=0;s<e.length;s++)o-s>=0&&o-s<t.length&&(a[o]=r(a[o],n(e[s],t[o-s])))}return a}}),mt=a4({config:ee}),mr=oK({}),mn=sX({BigNumber:mt,config:ee}),mi=sZ({}),ma=aN({BigNumber:mt,config:ee}),mo=uI({}),ms=s5({Complex:mr}),mu=sV({BigNumber:mt,config:ee}),ml=s0({BigNumber:mt,config:ee}),mc=s2({BigNumber:mt,config:ee}),mf=ca({}),mp=sW({BigNumber:mt,config:ee}),mm=sG({}),md=sQ({BigNumber:mt,config:ee}),mh=c9({}),mg=fa({}),my=s3({BigNumber:mt,config:ee}),mv=aj({BigNumber:mt,config:ee}),mx=sJ({BigNumber:mt,config:ee}),mb=sH({}),mN=s8({}),mw=sb({Matrix:mf}),mD=aB({BigNumber:mt,config:ee}),mE=sK({BigNumber:mt,config:ee}),mA=sY({BigNumber:mt,config:ee}),mS=ft({}),mC=s4({BigNumber:mt,config:ee}),mM=pz({BigNumber:mt,Complex:mr,DenseMatrix:mw,Fraction:mo}),mF=p$({BigNumber:mt,config:ee,typed:mM}),mB=aF({BigNumber:mt,config:ee}),mT=it({typed:mM}),mO=ii({Complex:mr,config:ee,typed:mM}),m_=iE({BigNumber:mt,typed:mM}),mz=iM({BigNumber:mt,Complex:mr,config:ee,typed:mM}),mq=ij({typed:mM}),mk=iJ({typed:mM}),mI=i0({BigNumber:mt,Complex:mr,config:ee,typed:mM}),mR=i3({typed:mM}),mP=i4({typed:mM}),mj=at({Complex:mr,config:ee,typed:mM}),mU=a2({BigNumber:mt,typed:mM}),mL=oh({typed:mM}),m$=ow({typed:mM}),mH=oO({typed:mM}),mZ=ok({typed:mM}),mG=oX({Complex:mr,typed:mM}),mV=o3({typed:mM}),mW=o6({typed:mM}),mY=se({BigNumber:mt,typed:mM}),mJ=sl({BigNumber:mt,typed:mM}),mX=sh({typed:mM}),mQ=un({config:ee,typed:mM}),mK=uo({typed:mM}),m0=up({typed:mM}),m1=ug({Complex:mr,typed:mM}),m2=uN({typed:mM}),m3=uT({typed:mM}),m4=uz({typed:mM}),m5=u0({typed:mM}),m8=u3({format:m4,typed:mM}),m6=le({typed:mM}),m7=lf({typed:mM}),m9=lb({typed:mM}),de=lE({typed:mM}),dt=lM({typed:mM}),dr=s1({BigNumber:mt,config:ee}),dn=lZ({Complex:mr,typed:mM}),di=lW({Complex:mr,config:ee,typed:mM}),da=lQ({Complex:mr,config:ee,typed:mM}),ds=ct({typed:mM}),du=cb({typed:mM}),dl=cD({typed:mM}),dc=cM({typed:mM}),df=cB({format:m4,typed:mM}),dp=cY({config:ee,typed:mM}),dm=r5({typed:mM}),dd=c8({config:ee,typed:mM}),dh=fe({typed:mM}),dg=fx({BigNumber:mt,typed:mM}),dy=f$({BigNumber:mt,Fraction:mo,complex:mG,typed:mM}),dv=fH({typed:mM}),dx=ps({Matrix:mf,equalScalar:mQ,typed:mM}),db=pl({typed:mM}),dN=pd({typed:mM}),dw=pb({typed:mM}),dD=pE({typed:mM}),dE=pC({typed:mM}),dA=pP({typed:mM}),dS=iw({Complex:mr,config:ee,typed:mM}),dC=iB({BigNumber:mt,typed:mM}),dM=tp({isInteger:m7,typed:mM}),dF=iQ({BigNumber:mt,Complex:mr,config:ee,typed:mM}),dB=a5({format:m4,typed:mM}),dT=oP({typed:mM}),dO=o9({typed:mM}),d_=sf({BigNumber:mt,typed:mM}),dz=lv({typed:mM}),dq=lS({typed:mM}),dk=c7({config:ee,typed:mM}),dI=fN({BigNumber:mt,typed:mM}),dR=fG({typed:mM}),dP=po({SparseMatrix:dx,typed:mM}),dj=pc({Complex:mr,config:ee,typed:mM}),dU=pM({typed:mM}),dL=pU({typed:mM}),d$=iS({BigNumber:mt,Complex:mr,config:ee,typed:mM}),dH=sr({BigNumber:mt,typed:mM}),dZ=uq({Fraction:mo,typed:mM}),dG=lw({typed:mM}),dV=ci({DenseMatrix:mw,Matrix:mf,SparseMatrix:dx,typed:mM}),dW=cl({isZero:dt,matrix:dV,typed:mM}),dY=ch({isNaN:dz,isNumeric:dG,typed:mM}),dJ=cF({bignumber:mU,fraction:dZ,number:dc}),dX=c2({config:ee,multiplyScalar:du,numeric:dJ,typed:mM}),dQ=fn({isInteger:m7,matrix:dV,typed:mM}),dK=fW({matrix:dV,config:ee,typed:mM}),d0=pg({matrix:dV,typed:mM}),d1=pO({matrix:dV,typed:mM}),d2=p3({BigNumber:mt,config:ee,matrix:dV,typed:mM}),d3=p8({BigNumber:mt,config:ee,matrix:dV,typed:mM}),d4=i2({Complex:mr,config:ee,typed:mM}),d5=oS({BigNumber:mt,Complex:mr,Fraction:mo,config:ee,isNegative:m9,matrix:dV,typed:mM,unaryMinus:dL}),d8=tL({isInteger:m7,matrix:dV,typed:mM}),d6=si({prod:dX,size:dK,typed:mM}),d7=sm({conj:mV,transpose:d1,typed:mM}),d9=sD({DenseMatrix:mw,SparseMatrix:dx,matrix:dV,typed:mM}),he=sM({numeric:dJ,typed:mM}),ht=sT({DenseMatrix:mw,concat:d8,divideScalar:he,equalScalar:mQ,matrix:dV,typed:mM}),hr=ue({DenseMatrix:mw,concat:d8,equalScalar:mQ,matrix:dV,typed:mM}),hn=uS({matrix:dV,typed:mM}),hi=u2({isNumeric:dG,typed:mM}),ha=u6({BigNumber:mt,DenseMatrix:mw,SparseMatrix:dx,config:ee,matrix:dV,typed:mM}),ho=lO({matrix:dV,multiplyScalar:du,typed:mM}),hs=lI({DenseMatrix:mw,concat:d8,config:ee,matrix:dV,typed:mM}),hu=l$({DenseMatrix:mw,concat:d8,equalScalar:mQ,matrix:dV,typed:mM,zeros:d3}),hl=l1({DenseMatrix:mw,divideScalar:he,equalScalar:mQ,matrix:dV,multiplyScalar:du,subtractScalar:dD,typed:mM}),hc=cs({flatten:hn,matrix:dV,size:dK,typed:mM}),hf=cA({BigNumber:mt,concat:d8,equalScalar:mQ,matrix:dV,typed:mM}),hp=cT({BigNumber:mt,config:ee,matrix:dV,typed:mM}),hm=c3({addScalar:mq,complex:mG,conj:mV,divideScalar:he,equal:hr,identity:ha,isZero:dt,matrix:dV,multiplyScalar:du,sign:dy,sqrt:dj,subtractScalar:dD,typed:mM,unaryMinus:dL,zeros:d3}),hd=fi({config:ee,matrix:dV}),hh=fs({DenseMatrix:mw,concat:d8,equalScalar:mQ,matrix:dV,typed:mM,zeros:d3}),hg=fg({BigNumber:mt,DenseMatrix:mw,equalScalar:mQ,matrix:dV,typed:mM,zeros:d3}),hy=f5({DenseMatrix:mw,concat:d8,config:ee,matrix:dV,typed:mM}),hv=pw({DenseMatrix:mw,concat:d8,equalScalar:mQ,matrix:dV,subtractScalar:dD,typed:mM,unaryMinus:dL}),hx=pF({concat:d8,matrix:dV,typed:mM}),hb=pZ({DenseMatrix:mw,concat:d8,config:ee,equalScalar:mQ,matrix:dV,typed:mM}),hN=pK({DenseMatrix:mw,divideScalar:he,equalScalar:mQ,matrix:dV,multiplyScalar:du,subtractScalar:dD,typed:mM}),hw=p4({DenseMatrix:mw,concat:d8,matrix:dV,typed:mM}),hD=iR({DenseMatrix:mw,SparseMatrix:dx,addScalar:mq,concat:d8,equalScalar:mQ,matrix:dV,typed:mM}),hE=i9({BigNumber:mt,DenseMatrix:mw,concat:d8,equalScalar:mQ,matrix:dV,typed:mM}),hA=om({concat:d8,equalScalar:mQ,matrix:dV,typed:mM}),hS=ob({DenseMatrix:mw,concat:d8,matrix:dV,typed:mM}),hC=oE({addScalar:mq,combinations:mZ,divideScalar:he,isInteger:m7,isNegative:m9,multiplyScalar:du,typed:mM}),hM=oH({BigNumber:mt,DenseMatrix:mw,Fraction:mo,concat:d8,config:ee,equalScalar:mQ,matrix:dV,typed:mM}),hF=oJ({concat:d8,matrix:dV,typed:mM}),hB=t8({add:hD,typed:mM,unaryPlus:mF}),hT=sy({equal:hr,typed:mM}),hO=rr({matrix:dV,number:dc,subtract:hv,typed:mM}),h_=sA({abs:mT,addScalar:mq,deepEqual:hT,divideScalar:he,multiplyScalar:du,sqrt:dj,subtractScalar:dD,typed:mM}),hz=sF({addScalar:mq,conj:mV,multiplyScalar:du,size:dK,typed:mM}),hq=ua({compareText:hF,isZero:dt,typed:mM}),hk=uF({DenseMatrix:mw,config:ee,equalScalar:mQ,matrix:dV,round:hg,typed:mM,zeros:d3}),hI=uQ({BigNumber:mt,DenseMatrix:mw,concat:d8,config:ee,equalScalar:mQ,matrix:dV,round:hg,typed:mM,zeros:d3}),hR=u5({abs:mT,addScalar:mq,divideScalar:he,isPositive:de,multiplyScalar:du,smaller:hy,sqrt:dj,typed:mM}),hP=lt({DenseMatrix:mw,smaller:hy}),hj=li({ImmutableDenseMatrix:hP,getMatrixDataType:m5}),hU=lz({DenseMatrix:mw,concat:d8,config:ee,matrix:dV,typed:mM}),hL=lG({Complex:mr,config:ee,divideScalar:he,typed:mM}),h$=l3({DenseMatrix:mw,divideScalar:he,equalScalar:mQ,matrix:dV,multiplyScalar:du,subtractScalar:dD,typed:mM}),hH=cf({flatten:hn,matrix:dV,size:dK,typed:mM}),hZ=r$({config:ee,numeric:dJ,smaller:hy,typed:mM}),hG=uV({DenseMatrix:mw,concat:d8,config:ee,equalScalar:mQ,matrix:dV,round:hg,typed:mM,zeros:d3}),hV=cx({addScalar:mq,dot:hz,equalScalar:mQ,matrix:dV,multiplyScalar:du,typed:mM}),hW=cC({Complex:mr,config:ee,divideScalar:he,typed:mM}),hY=cO({DenseMatrix:mw,concat:d8,equalScalar:mQ,matrix:dV,typed:mM}),hJ=cz({compare:hM,isNaN:dz,isNumeric:dG,typed:mM}),hX=fl({DenseMatrix:mw,concat:d8,equalScalar:mQ,matrix:dV,typed:mM,zeros:d3}),hQ=f3({SparseMatrix:dx,abs:mT,add:hD,divideScalar:he,larger:hU,largerEq:hs,multiply:hV,subtract:hv,transpose:d1,typed:mM}),hK=nB({add:hD,matrix:dV,typed:mM,zeros:d3}),h0=nk({add:hD,config:ee,numeric:dJ,typed:mM}),h1=pB({add:hD,matrix:dV,typed:mM}),h2=p1({DenseMatrix:mw,divideScalar:he,equalScalar:mQ,matrix:dV,multiplyScalar:du,subtractScalar:dD,typed:mM}),h3=me({Complex:mr,add:hD,multiply:hV,number:dc,typed:mM}),h4=oy({DenseMatrix:mw,concat:d8,equalScalar:mQ,matrix:dV,typed:mM}),h5=oB({DenseMatrix:mw,config:ee,equalScalar:mQ,matrix:dV,round:hg,typed:mM,zeros:d3}),h8=oW({compare:hM,typed:mM}),h6=o1({addScalar:mq,combinations:mZ,isInteger:m7,isNegative:m9,isPositive:de,larger:hU,typed:mM}),h7=su({matrix:dV,multiply:hV,subtract:hv,typed:mM}),h9=sN({divideScalar:he,isZero:dt,matrix:dV,multiply:hV,subtractScalar:dD,typed:mM,unaryMinus:dL}),ge=s_({concat:d8,equalScalar:mQ,matrix:dV,multiplyScalar:du,typed:mM}),gt=ub({larger:hU,smaller:hy}),gr=uE({Complex:mr,DenseMatrix:mw,ceil:h5,equalScalar:mQ,floor:hk,matrix:dV,typed:mM,zeros:d3}),gn=ln({Index:hj,typed:mM}),gi=lo({abs:mT,add:hD,addScalar:mq,config:ee,divideScalar:he,equalScalar:mQ,flatten:hn,isNumeric:dG,isZero:dt,matrix:dV,multiply:hV,multiplyScalar:du,smaller:hy,subtract:hv,typed:mM}),ga=ll({BigNumber:mt,add:hD,config:ee,equal:hr,isInteger:m7,mod:hG,smaller:hy,typed:mM,xgcd:d2}),go=lP({concat:d8,equalScalar:mQ,matrix:dV,typed:mM}),gs=lJ({Complex:mr,config:ee,divideScalar:he,log:hL,typed:mM}),gu=rR({config:ee,larger:hU,numeric:dJ,typed:mM}),gl=fD({DenseMatrix:mw,Index:hj,compareNatural:h8,size:dK,subset:hK,typed:mM}),gc=fC({DenseMatrix:mw,Index:hj,compareNatural:h8,size:dK,subset:hK,typed:mM}),gf=fT({Index:hj,compareNatural:h8,size:dK,subset:hK,typed:mM}),gp=fq({Index:hj,compareNatural:h8,size:dK,subset:hK,typed:mM}),gm=f7({DenseMatrix:mw,concat:d8,config:ee,matrix:dV,typed:mM}),gd=pn({compare:hM,compareNatural:h8,matrix:dV,typed:mM}),gh=iY({concat:d8,equalScalar:mQ,matrix:dV,not:dl,typed:mM,zeros:d3}),gg=nu({bignumber:mU,matrix:dV,add:hD,config:ee,isPositive:de,larger:hU,largerEq:hs,smaller:hy,smallerEq:gm,typed:mM}),gy=ng({Index:hj,matrix:dV,range:gg,typed:mM}),gv=fA({DenseMatrix:mw,Index:hj,compareNatural:h8,size:dK,subset:hK,typed:mM}),gx=f_({Index:hj,compareNatural:h8,size:dK,subset:hK,typed:mM}),gb=fP({Index:hj,concat:d8,setDifference:gv,size:dK,subset:hK,typed:mM}),gN=pi({FibonacciHeap:gt,addScalar:mq,equalScalar:mQ}),gw=tB({Index:hj,matrix:dV,range:gg,typed:mM}),gD=ls({abs:mT,addScalar:mq,det:h9,divideScalar:he,identity:ha,matrix:dV,multiply:hV,typed:mM,unaryMinus:dL}),gE=l4({DenseMatrix:mw,Spa:gN,SparseMatrix:dx,abs:mT,addScalar:mq,divideScalar:he,equalScalar:mQ,larger:hU,matrix:dV,multiplyScalar:du,subtractScalar:dD,typed:mM,unaryMinus:dL}),gA=cX({Complex:mr,add:hD,ctranspose:d7,deepEqual:hT,divideScalar:he,dot:hz,dotDivide:ht,equal:hr,inv:gD,matrix:dV,multiply:hV,typed:mM}),gS=c0({Complex:mr,config:ee,fraction:dZ,identity:ha,inv:gD,matrix:dV,multiply:hV,number:dc,typed:mM}),gC=fF({DenseMatrix:mw,Index:hj,compareNatural:h8,size:dK,subset:hK,typed:mM}),gM=fU({Index:hj,concat:d8,setIntersect:gC,setSymDifference:gb,size:dK,subset:hK,typed:mM}),gF=pp({abs:mT,add:hD,identity:ha,inv:gD,map:ds,max:gu,multiply:hV,size:dK,sqrt:dj,subtract:hv,typed:mM}),gB=pY({BigNumber:mt,Complex:mr,Fraction:mo,abs:mT,addScalar:mq,config:ee,divideScalar:he,equal:hr,fix:gr,format:m4,isNumeric:dG,multiplyScalar:du,number:dc,pow:gS,round:hg,subtractScalar:dD}),gT=au({BigNumber:mt,Unit:gB,config:ee}),gO=a$({BigNumber:mt,Unit:gB,config:ee}),g_=aT({BigNumber:mt,Unit:gB,config:ee}),gz=af({BigNumber:mt,Unit:gB,config:ee}),gq=a_({BigNumber:mt,Unit:gB,config:ee}),gk=ap({BigNumber:mt,Unit:gB,config:ee}),gI=al({BigNumber:mt,Unit:gB,config:ee}),gR=aE({BigNumber:mt,Unit:gB,config:ee}),gP=sq({DenseMatrix:mw,concat:d8,equalScalar:mQ,matrix:dV,pow:gS,typed:mM}),gj=as({BigNumber:mt,Unit:gB,config:ee}),gU=ac({BigNumber:mt,Unit:gB,config:ee}),gL=ud({abs:mT,add:hD,identity:ha,inv:gD,multiply:hV,typed:mM}),g$=az({BigNumber:mt,Unit:gB,config:ee}),gH=ux({addScalar:mq,ceil:h5,conj:mV,divideScalar:he,dotDivide:ht,exp:m0,i:ms,log2:da,matrix:dV,multiplyScalar:du,pow:gS,tau:mx,typed:mM}),gZ=uG({BigNumber:mt,Complex:mr,config:ee,multiplyScalar:du,pow:gS,typed:mM}),gG=an({BigNumber:mt,Unit:gB,config:ee}),gV=aw({BigNumber:mt,Unit:gB,config:ee}),gW=u9({conj:mV,dotDivide:ht,fft:gH,typed:mM}),gY=ag({BigNumber:mt,Unit:gB,config:ee}),gJ=ak({BigNumber:mt,Unit:gB,config:ee}),gX=ao({BigNumber:mt,Unit:gB,config:ee}),gQ=aH({BigNumber:mt,Unit:gB,config:ee}),gK=aR({BigNumber:mt,Unit:gB,config:ee}),g0=aA({BigNumber:mt,Unit:gB,config:ee}),g1=ah({BigNumber:mt,Unit:gB,config:ee}),g2=aJ({BigNumber:mt,Unit:gB,config:ee}),g3=aV({BigNumber:mt,Unit:gB,config:ee}),g4=aX({BigNumber:mt,Unit:gB,config:ee}),g5=aD({BigNumber:mt,Unit:gB,config:ee}),g8=aS({BigNumber:mt,Unit:gB,config:ee}),g6=aa({BigNumber:mt,Unit:gB,config:ee}),g7=aC({BigNumber:mt,Unit:gB,config:ee}),g9=aU({BigNumber:mt,Unit:gB,config:ee}),ye=ar({BigNumber:mt,Unit:gB,config:ee}),yt=aL({BigNumber:mt,Unit:gB,config:ee}),yr=aM({BigNumber:mt,Unit:gB,config:ee}),yn=aO({BigNumber:mt,Unit:gB,config:ee}),yi=ay({BigNumber:mt,Unit:gB,config:ee}),ya=so({Unit:gB,typed:mM}),yo=sS({divideScalar:he,equalScalar:mQ,inv:gD,matrix:dV,multiply:hV,typed:mM}),ys=ax({BigNumber:mt,Unit:gB,config:ee}),yu=uv({gamma:gZ,typed:mM}),yl=aq({BigNumber:mt,Unit:gB,config:ee}),yc=aG({BigNumber:mt,Unit:gB,config:ee}),yf=am({BigNumber:mt,Unit:gB,config:ee}),yp=l6({DenseMatrix:mw,lsolve:hl,lup:gE,matrix:dV,slu:hQ,typed:mM,usolve:hN}),ym=ad({BigNumber:mt,Unit:gB,config:ee}),yd=aZ({BigNumber:mt,Unit:gB,config:ee}),yh=cy({add:hD,divide:yo,factorial:yu,isInteger:m7,isPositive:de,multiply:hV,typed:mM}),yg=ck({factorial:yu,typed:mM}),yy=aW({BigNumber:mt,Unit:gB,config:ee}),yv=cK({add:hD,cbrt:d5,divide:yo,equalScalar:mQ,im:m6,isZero:dt,multiply:hV,re:dh,sqrt:dj,subtract:hv,typeOf:dA,typed:mM,unaryMinus:dL}),yx=fI({compareNatural:h8,typed:mM}),yb=pt({abs:mT,add:hD,bignumber:mU,divide:yo,isNegative:m9,isPositive:de,larger:hU,map:ds,matrix:dV,max:gu,multiply:hV,smaller:hy,subtract:hv,typed:mM,unaryMinus:dL}),yN=pv({bignumber:mU,addScalar:mq,combinations:mZ,divideScalar:he,factorial:yu,isInteger:m7,isNegative:m9,larger:hU,multiplyScalar:du,number:dc,pow:gS,subtractScalar:dD,typed:mM}),yw=pX({Unit:gB,typed:mM}),yD=a1({addScalar:mq,isInteger:m7,isNegative:m9,stirlingS2:yN,typed:mM}),yE=s7({abs:mT,add:hD,addScalar:mq,atan:mP,bignumber:mU,column:gw,complex:mG,config:ee,cos:mW,diag:d9,divideScalar:he,dot:hz,equal:hr,flatten:hn,im:m6,inv:gD,larger:hU,matrix:dV,matrixFromColumns:hc,multiply:hV,multiplyScalar:du,number:dc,qr:hm,re:dh,reshape:dQ,sin:dv,size:dK,smaller:hy,sqrt:dj,subtract:hv,typed:mM,usolve:hN,usolveAll:h2}),yA=ab({BigNumber:mt,Unit:gB,config:ee}),yS=aI({BigNumber:mt,Unit:gB,config:ee}),yC=rU({add:hD,divide:yo,typed:mM}),yM=aP({BigNumber:mt,Unit:gB,config:ee}),yF=ai({BigNumber:mt,Unit:gB,config:ee}),yB=ne({bignumber:mU,add:hD,compare:hM,divide:yo,isInteger:m7,larger:hU,multiply:hV,partitionSelect:hJ,smaller:hy,smallerEq:gm,subtract:hv,typed:mM}),yT=n$({add:hD,apply:dM,divide:yo,isNaN:dz,multiply:hV,subtract:hv,typed:mM}),yO=av({BigNumber:mt,Unit:gB,config:ee}),y_=cm({add:hD,compare:hM,divide:yo,partitionSelect:hJ,typed:mM}),yz=o5({add:hD,divide:yo,matrix:dV,mean:yC,multiply:hV,pow:gS,sqrt:dj,subtract:hv,sum:h0,typed:mM}),yq=uP({Complex:mr,add:hD,divide:yo,matrix:dV,multiply:hV,typed:mM}),yk=ce({abs:mT,map:ds,median:y_,subtract:hv,typed:mM}),yI=nC({map:ds,sqrt:dj,typed:mM,variance:yT}),yR=p7({BigNumber:mt,Complex:mr,add:hD,config:ee,divide:yo,equal:hr,factorial:yu,gamma:gZ,isNegative:m9,multiply:hV,pi:mA,pow:gS,sin:dv,smallerEq:gm,subtract:hv,typed:mM}),yP=cw({abs:mT,add:hD,conj:mV,ctranspose:d7,eigs:yE,equalScalar:mQ,larger:hU,matrix:dV,multiply:hV,pow:gS,smaller:hy,sqrt:dj,typed:mM}),yj=fm({BigNumber:mt,DenseMatrix:mw,SparseMatrix:dx,addScalar:mq,config:ee,cos:mW,matrix:dV,multiplyScalar:du,norm:yP,sin:dv,typed:mM,unaryMinus:dL}),yU=lB({divide:yo,dotDivide:ht,isNumeric:dG,log:hL,map:ds,matrix:dV,multiply:hV,sum:h0,typed:mM}),yL=aY({BigNumber:mt,Unit:gB,config:ee}),y$=fv({identity:ha,matrix:dV,multiply:hV,norm:yP,qr:hm,subtract:hv,typed:mM}),yH=ff({multiply:hV,rotationMatrix:yj,typed:mM}),yZ=pS({abs:mT,add:hD,concat:d8,identity:ha,index:gn,lusolve:yp,matrix:dV,matrixFromColumns:hc,multiply:hV,range:gg,schur:y$,subset:hK,subtract:hv,transpose:d1,typed:mM}),yG=l9({matrix:dV,multiply:hV,sylvester:yZ,transpose:d1,typed:mM}),yV={},yW={},yY={},yJ=rZ({mathWithTransform:yW}),yX=rV({Node:yJ}),yQ=rY({Node:yJ}),yK=rX({Node:yJ}),y0=nm({Node:yJ}),y1=tg({Node:yJ}),y2=tA({Node:yJ,ResultSet:mg}),y3=tZ({Node:yJ}),y4=t3({Node:yJ}),y5=nn({Node:yJ}),y8=nh({classes:yY}),y6=tM({math:yV,typed:mM}),y7=rw({Node:yJ,typed:mM}),y9=tC({Chain:y6,typed:mM}),ve=rO({Node:yJ,size:dK}),vt=tc({Node:yJ,subset:hK}),vr=tD({matrix:dV,Node:yJ,subset:hK}),vn=nj({Unit:gB,Node:yJ,math:yV}),vi=rE({Node:yJ,SymbolNode:vn,math:yV}),va=rK({AccessorNode:vt,ArrayNode:y1,AssignmentNode:vr,BlockNode:y2,ConditionalNode:y3,ConstantNode:y4,FunctionAssignmentNode:y7,FunctionNode:vi,IndexNode:ve,ObjectNode:yX,OperatorNode:yQ,ParenthesisNode:yK,RangeNode:y5,RelationalNode:y0,SymbolNode:vn,config:ee,numeric:dJ,typed:mM}),vo=nd({ConstantNode:y4,FunctionNode:vi,OperatorNode:yQ,ParenthesisNode:yK,parse:va,typed:mM}),vs=nE({bignumber:mU,fraction:dZ,AccessorNode:vt,ArrayNode:y1,ConstantNode:y4,FunctionNode:vi,IndexNode:ve,ObjectNode:yX,OperatorNode:yQ,SymbolNode:vn,config:ee,mathWithTransform:yW,matrix:dV,typed:mM}),vu=tj({parse:va,typed:mM}),vl=rB({parse:va}),vc=rq({parse:va,typed:mM}),vf=nS({AccessorNode:vt,ArrayNode:y1,ConstantNode:y4,FunctionNode:vi,IndexNode:ve,ObjectNode:yX,OperatorNode:yQ,ParenthesisNode:yK,SymbolNode:vn,add:hD,divide:yo,equal:hr,isZero:dt,multiply:hV,parse:va,pow:gS,subtract:hv,typed:mM}),vp=rp({parse:va,typed:mM}),vm=rF({Help:vl,mathWithTransform:yW,typed:mM}),vd=r2({evaluate:vp}),vh=nD({bignumber:mU,fraction:dZ,AccessorNode:vt,ArrayNode:y1,ConstantNode:y4,FunctionNode:vi,IndexNode:ve,ObjectNode:yX,OperatorNode:yQ,ParenthesisNode:yK,SymbolNode:vn,add:hD,config:ee,divide:yo,equal:hr,isZero:dt,mathWithTransform:yW,matrix:dV,multiply:hV,parse:va,pow:gS,resolve:vo,simplifyConstant:vs,simplifyCore:vf,subtract:hv,typed:mM}),vg=nP({OperatorNode:yQ,parse:va,simplify:vh,typed:mM}),vy=r1({Parser:vd,typed:mM}),vv=nf({bignumber:mU,fraction:dZ,AccessorNode:vt,ArrayNode:y1,ConstantNode:y4,FunctionNode:vi,IndexNode:ve,ObjectNode:yX,OperatorNode:yQ,ParenthesisNode:yK,SymbolNode:vn,add:hD,config:ee,divide:yo,equal:hr,isZero:dt,mathWithTransform:yW,matrix:dV,multiply:hV,parse:va,pow:gS,simplify:vh,simplifyConstant:vs,simplifyCore:vf,subtract:hv,typed:mM}),vx=re({ConstantNode:y4,FunctionNode:vi,OperatorNode:yQ,ParenthesisNode:yK,SymbolNode:vn,config:ee,equal:hr,isZero:dt,numeric:dJ,parse:va,simplify:vh,typed:mM});/*@__PURE__*/e(o)(yV,{e:mn,false:mi,fineStructure:ma,i:ms,Infinity:mu,LN10:ml,LOG10E:mc,NaN:mp,null:mm,phi:md,SQRT1_2:my,sackurTetrode:mv,tau:mx,true:mb,E:mn,version:mN,efimovFactor:mD,LN2:mE,pi:mA,replacer:mS,reviver:y8,SQRT2:mC,typed:mM,unaryPlus:mF,PI:mA,weakMixingAngle:mB,abs:mT,acos:mO,acot:m_,acsc:mz,addScalar:mq,arg:mk,asech:mI,asinh:mR,atan:mP,atanh:mj,bignumber:mU,bitNot:mL,boolean:m$,clone:mH,combinations:mZ,complex:mG,conj:mV,cos:mW,cot:mY,csc:mJ,cube:mX,equalScalar:mQ,erf:mK,exp:m0,expm1:m1,filter:m2,forEach:m3,format:m4,getMatrixDataType:m5,hex:m8,im:m6,isInteger:m7,isNegative:m9,isPositive:de,isZero:dt,LOG2E:dr,lgamma:dn,log10:di,log2:da,map:ds,multiplyScalar:du,not:dl,number:dc,oct:df,pickRandom:dp,print:dm,random:dd,re:dh,sec:dg,sign:dy,sin:dv,splitUnit:db,square:dN,string:dw,subtractScalar:dD,tan:dE,typeOf:dA,acosh:dS,acsch:dC,apply:dM,asec:dF,bin:dB,chain:y9,combinationsWithRep:dT,cosh:dO,csch:d_,isNaN:dz,isPrime:dq,randomInt:dk,sech:dI,sinh:dR,sparse:dP,sqrt:dj,tanh:dU,unaryMinus:dL,acoth:d$,coth:dH,fraction:dZ,isNumeric:dG,matrix:dV,matrixFromFunction:dW,mode:dY,numeric:dJ,prod:dX,reshape:dQ,size:dK,squeeze:d0,transpose:d1,xgcd:d2,zeros:d3,asin:d4,cbrt:d5,concat:d8,count:d6,ctranspose:d7,diag:d9,divideScalar:he,dotDivide:ht,equal:hr,flatten:hn,hasNumericValue:hi,identity:ha,kron:ho,largerEq:hs,leftShift:hu,lsolve:hl,matrixFromColumns:hc,nthRoot:hf,ones:hp,qr:hm,resize:hd,rightArithShift:hh,round:hg,smaller:hy,subtract:hv,to:hx,unequal:hb,usolve:hN,xor:hw,add:hD,atan2:hE,bitAnd:hA,bitXor:hS,catalan:hC,compare:hM,compareText:hF,cumsum:hB,deepEqual:hT,diff:hO,distance:h_,dot:hz,equalText:hq,floor:hk,gcd:hI,hypot:hR,larger:hU,log:hL,lsolveAll:h$,matrixFromRows:hH,min:hZ,mod:hG,multiply:hV,nthRoots:hW,or:hY,partitionSelect:hJ,rightLogShift:hX,slu:hQ,subset:hK,sum:h0,trace:h1,usolveAll:h2,zpk2tf:h3,bitOr:h4,ceil:h5,compareNatural:h8,composition:h6,cross:h7,det:h9,dotMultiply:ge,fix:gr,index:gn,intersect:gi,invmod:ga,lcm:go,log1p:gs,max:gu,setCartesian:gl,setDistinct:gc,setIsSubset:gf,setPowerset:gp,smallerEq:gm,sort:gd,and:gh,range:gg,row:gy,setDifference:gv,setMultiplicity:gx,setSymDifference:gb,column:gw,inv:gD,lup:gE,pinv:gA,pow:gS,setIntersect:gC,setUnion:gM,sqrtm:gF,vacuumImpedance:gT,wienDisplacement:gO,atomicMass:g_,bohrMagneton:gz,boltzmann:gq,conductanceQuantum:gk,coulomb:gI,deuteronMass:gR,dotPow:gP,electricConstant:gj,elementaryCharge:gU,expm:gL,faraday:g$,fft:gH,gamma:gZ,gravitationConstant:gG,hartreeEnergy:gV,ifft:gW,klitzing:gY,loschmidt:gJ,magneticConstant:gX,molarMass:gQ,molarPlanckConstant:gK,neutronMass:g0,nuclearMagneton:g1,planckCharge:g2,planckLength:g3,planckTemperature:g4,protonMass:g5,quantumOfCirculation:g8,reducedPlanckConstant:g6,rydberg:g7,secondRadiation:g9,speedOfLight:ye,stefanBoltzmann:yt,thomsonCrossSection:yr,avogadro:yn,bohrRadius:yi,createUnit:ya,divide:yo,electronMass:ys,factorial:yu,firstRadiation:yl,gravity:yc,inverseConductanceQuantum:yf,lusolve:yp,magneticFluxQuantum:ym,molarMassC12:yd,multinomial:yh,parse:va,permutations:yg,planckMass:yy,polynomialRoot:yv,resolve:vo,setSize:yx,simplifyConstant:vs,solveODE:yb,stirlingS2:yN,unit:yw,bellNumbers:yD,compile:vu,eigs:yE,fermiCoupling:yA,gasConstant:yS,leafCount:vc,mean:yC,molarVolume:yM,planckConstant:yF,quantileSeq:yB,simplifyCore:vf,variance:yT,classicalElectronRadius:yO,evaluate:vp,help:vm,median:y_,simplify:vh,symbolicEqual:vg,corr:yz,freqz:yq,mad:yk,parser:vy,rationalize:vv,std:yI,zeta:yR,derivative:vx,norm:yP,rotationMatrix:yj,kldivergence:yU,planckTime:yL,schur:y$,rotate:yH,sylvester:yZ,lyap:yG,config:ee}),/*@__PURE__*/e(o)(yW,yV,{filter:ry({typed:mM}),forEach:rx({typed:mM}),map:rk({typed:mM}),apply:td({isInteger:m7,typed:mM}),concat:t$({isInteger:m7,matrix:dV,typed:mM}),max:rP({config:ee,larger:hU,numeric:dJ,typed:mM}),print:r7({add:hD,matrix:dV,typed:mM,zeros:d3}),diff:ra({bignumber:mU,matrix:dV,number:dc,subtract:hv,typed:mM}),min:rH({config:ee,numeric:dJ,smaller:hy,typed:mM}),subset:nq({add:hD,matrix:dV,typed:mM,zeros:d3}),cumsum:t7({add:hD,typed:mM,unaryPlus:mF}),index:r_({Index:hj,getMatrixDataType:m5}),sum:nI({add:hD,config:ee,numeric:dJ,typed:mM}),range:nl({bignumber:mU,matrix:dV,add:hD,config:ee,isPositive:de,larger:hU,largerEq:hs,smaller:hy,smallerEq:gm,typed:mM}),row:ny({Index:hj,matrix:dV,range:gg,typed:mM}),column:tT({Index:hj,matrix:dV,range:gg,typed:mM}),mean:rL({add:hD,divide:yo,typed:mM}),quantileSeq:nt({add:hD,bignumber:mU,compare:hM,divide:yo,isInteger:m7,larger:hU,multiply:hV,partitionSelect:hJ,smaller:hy,smallerEq:gm,subtract:hv,typed:mM}),variance:nZ({add:hD,apply:dM,divide:yo,isNaN:dz,multiply:hV,subtract:hv,typed:mM}),std:nM({map:ds,sqrt:dj,typed:mM,variance:yT})}),/*@__PURE__*/e(o)(yY,{BigNumber:mt,Complex:mr,Fraction:mo,Matrix:mf,Node:yJ,ObjectNode:yX,OperatorNode:yQ,ParenthesisNode:yK,Range:mh,RelationalNode:y0,ResultSet:mg,ArrayNode:y1,BlockNode:y2,ConditionalNode:y3,ConstantNode:y4,DenseMatrix:mw,RangeNode:y5,Chain:y6,FunctionAssignmentNode:y7,SparseMatrix:dx,IndexNode:ve,ImmutableDenseMatrix:hP,Index:hj,AccessorNode:vt,AssignmentNode:vr,FibonacciHeap:gt,Spa:gN,Unit:gB,SymbolNode:vn,FunctionNode:vi,Help:vl,Parser:vd}),y6.createProxy(yV);// variables
const vb=document.querySelector(".displayResult"),vN=document.querySelector(".displayKeyValue"),vw=Array.from(document.querySelectorAll(".grid div")),vD=Array.from(document.querySelectorAll(".themeCon li")),vE=document.querySelector(".themeColor");let vA=0,vS=0;// functions
function vC(e,t){document.documentElement.style.setProperty("--key-color",`var(--key-color${e})`),document.documentElement.style.setProperty("--key-colorShadow",`var(--key-colorShadow${e})`),document.documentElement.style.setProperty("--key-DR",`var(--key-DR${e})`),document.documentElement.style.setProperty("--key-DR-shadow",`var(--key-DR-shadow${e})`),document.documentElement.style.setProperty("--key-last",`var(--key-last${e})`),document.documentElement.style.setProperty("--key-last-shadow",`var(--key-last-shadow${e})`),document.documentElement.style.setProperty("--bg-mainBg",`var(--bg-mainBg${e})`),document.documentElement.style.setProperty("--textColor",`var(--textColor${e})`),document.documentElement.style.setProperty("--bg-keyBgToggle",`var(--bg-keyBgToggle${e})`),document.documentElement.style.setProperty("--key-textColor",`var(--key-textColor${e})`),document.documentElement.style.setProperty("--lastkey-color",`var(--lastkey-color${e})`),document.documentElement.style.setProperty("--bg-screen",`var(--bg-screen${e})`),vE.style.translate=`${t}rem`}function vM(e){// expression = expression.replace(/0[0-9]+/g, match => parseInt(match))
let t=vp(e);return t}function vF(){try{if("delete"===this.dataset.key)return vN.textContent=vN.textContent.slice(0,-1);if("="===this.dataset.key)return vb.textContent=vM(vN.textContent);vN.textContent+=this.dataset.key,"reset"===this.dataset.key&&(vN.textContent="",vb.textContent="")}catch(e){vb.textContent="ERROR !"}}function vB(e){e.target===vD[0]&&(vA=0,vS=0),e.target===vD[1]&&(vA=1,vS=1.25),e.target===vD[2]&&(vA=2,vS=2.25),localStorage.setItem("theme",JSON.stringify(vA)),localStorage.setItem("transX",JSON.stringify(vS)),vC(vA,vS)}console.log(vM("03")),// event handler
window.addEventListener("DOMContentLoaded",function(){vb.textContent="",vN.textContent="",vC(JSON.parse(localStorage.getItem("theme"))||0,JSON.parse(localStorage.getItem("transX"))||0)}),vw.forEach(function(e){e.addEventListener("click",vF)}),vD.forEach(function(e){e.addEventListener("click",vB)});//# sourceMappingURL=index.57e56a99.js.map

//# sourceMappingURL=index.57e56a99.js.map
